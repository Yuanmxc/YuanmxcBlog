<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>FFmpeg 解码视频流 | 陌上尘归处</title><meta name="author" content="Yuanmxc"><meta name="copyright" content="Yuanmxc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="FFmpeg 解码视频流前言本文讲解从网络接收 H.265 视频裸流后使用 FFmpeg 相关库解码得到 YUVJ420P 格式的图片然后转为 RGB 格式图片并使用 jpeglib 库保存为 jpeg 文件。仅展示部分代码。 包含对 FFmpeg 的解码 H.265 视频裸流、图片保存格式 YUV 和 RGB 及两者之间的转换、jpeglib 将 RGB 格式图片保存为 jpeg 文件的相关内容">
<meta property="og:type" content="article">
<meta property="og:title" content="FFmpeg 解码视频流">
<meta property="og:url" content="http://example.com/2024/05/14/FFmpeg%20%E8%A7%A3%E7%A0%81%E8%A7%86%E9%A2%91%E6%B5%81/index.html">
<meta property="og:site_name" content="陌上尘归处">
<meta property="og:description" content="FFmpeg 解码视频流前言本文讲解从网络接收 H.265 视频裸流后使用 FFmpeg 相关库解码得到 YUVJ420P 格式的图片然后转为 RGB 格式图片并使用 jpeglib 库保存为 jpeg 文件。仅展示部分代码。 包含对 FFmpeg 的解码 H.265 视频裸流、图片保存格式 YUV 和 RGB 及两者之间的转换、jpeglib 将 RGB 格式图片保存为 jpeg 文件的相关内容">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p43.png">
<meta property="article:published_time" content="2024-05-14T12:27:59.000Z">
<meta property="article:modified_time" content="2025-02-27T12:56:37.477Z">
<meta property="article:author" content="Yuanmxc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p43.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "FFmpeg 解码视频流",
  "url": "http://example.com/2024/05/14/FFmpeg%20%E8%A7%A3%E7%A0%81%E8%A7%86%E9%A2%91%E6%B5%81/",
  "image": "https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p43.png",
  "datePublished": "2024-05-14T12:27:59.000Z",
  "dateModified": "2025-02-27T12:56:37.477Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yuanmxc",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/other/touxiang2.png"><link rel="canonical" href="http://example.com/2024/05/14/FFmpeg%20%E8%A7%A3%E7%A0%81%E8%A7%86%E9%A2%91%E6%B5%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'FFmpeg 解码视频流',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p2.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/other/touxiang2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p43.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/other/touxiang2.png" alt="Logo"><span class="site-name">陌上尘归处</span></a><a class="nav-page-title" href="/"><span class="site-name">FFmpeg 解码视频流</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">FFmpeg 解码视频流</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-14T12:27:59.000Z" title="发表于 2024-05-14 20:27:59">2024-05-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-27T12:56:37.477Z" title="更新于 2025-02-27 20:56:37">2025-02-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BE%85%E5%88%86%E7%B1%BB/">待分类</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="FFmpeg-解码视频流"><a href="#FFmpeg-解码视频流" class="headerlink" title="FFmpeg 解码视频流"></a>FFmpeg 解码视频流</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文讲解从网络接收 H.265 视频裸流后使用 FFmpeg 相关库解码得到 YUVJ420P 格式的图片然后转为 RGB 格式图片并使用 jpeglib 库保存为 jpeg 文件。仅展示部分代码。</p>
<p>包含对 FFmpeg 的解码 H.265 视频裸流、图片保存格式 YUV 和 RGB 及两者之间的转换、jpeglib 将 RGB 格式图片保存为 jpeg 文件的相关内容。</p>
<h2 id="FFmpeg-库"><a href="#FFmpeg-库" class="headerlink" title="FFmpeg 库"></a>FFmpeg 库</h2><p>包含各种库，本文主要使用到以下库：</p>
<p><a target="_blank" rel="noopener" href="https://ffmpeg.org/doxygen/trunk/group__libavc.html">libavcodec</a> 编码&#x2F;解码库</p>
<p><a target="_blank" rel="noopener" href="https://ffmpeg.org/doxygen/trunk/group__libavf.html">libavformat</a> I&#x2F;O 和复用&#x2F;解复用库</p>
<p><a target="_blank" rel="noopener" href="https://ffmpeg.org/doxygen/trunk/group__lavu.html">libavutil</a> 通用实用程序库</p>
<p><a target="_blank" rel="noopener" href="https://ffmpeg.org/doxygen/trunk/group__libsws.html">libswscale</a> 颜色转换和缩放库</p>
<h2 id="跟解码相关的结构体"><a href="#跟解码相关的结构体" class="headerlink" title="跟解码相关的结构体"></a>跟<strong>解码</strong>相关的结构体</h2><ul>
<li><code>AVCodecContext</code>：可以是 <strong>编码器</strong> 的上下文，也可以是 <strong>解码器</strong> 的上下文，两者使用的是同一种数据结构（后面有些结构体和 API，编码器和解码器都可以使用，但为了方便，后面只提解码器）。</li>
<li><code>AVCodec</code>：存储解码器信息（为了方便，后面简称就是“解码器”了，基本上也可以这么理解）。</li>
<li><code>AVCodecParameters</code>：存储解码参数。</li>
<li><code>AVPacket</code>：原始数据包（已编码压缩的 IBP 帧），这里面的数据通常是一帧视频的数据，或者一帧音频的数据。本身是没有编码数据的，只是管理编码数据。</li>
<li><code>AVFrame</code>：解码之后的帧。<code>AVFrame</code> 跟 <code>AVPacket</code> 类似，是一个管理数据的结构体，本身是没有数据的，只是引用了数据。</li>
</ul>
<h2 id="与解码器相关的-API-函数"><a href="#与解码器相关的-API-函数" class="headerlink" title="与解码器相关的 API 函数"></a>与解码器相关的 API 函数</h2><ul>
<li><p><code>const AVCodec* avcodec_find_decoder(enum AVCodecID id)</code>:</p>
<p>  根据参数传入的解码器的 <code>AVCodecID</code> 返回指定的解码器。<code>AVCodecID</code> 是一个枚举类型，比如：传入 <code>AV_CODEC_ID_H265</code> 返回解码 H265 视频流的解码器。</p>
</li>
<li><p><code>AVCodecContext* avcodec_alloc_context3	(const AVCodec *codec)</code>：</p>
<p>  接收一个<code>AVCodec</code>（ <strong>编解码</strong>）参数，返回根据指定解码器初始化后的解码器上下文。如果为 NULL，则不会初始化特定于解码器的默认值，这可能会导致默认设置不理想。</p>
<p>  使用 <code>void avcodec_free_context	(AVCodecContext **avctx	)</code> 释放解码器上下文资源。</p>
</li>
<li><p><code>AVCodecParameters *avcodec_parameters_alloc()</code>：</p>
<p>  分配新的 AVCodecParameters 并将其字段设置为默认值，返回的AVCodecParameters必须使用 <code>avcodec_parameters_free（）</code> 释放。</p>
</li>
<li><p><code>int avcodec_parameters_from_context(struct AVCodecParameters *par,const AVCodecContext *codec)</code></p>
<p>  根据提供的<code>AVCodecContext</code>中的值填充<code>AVCodecParameters</code>。par 中任何分配的字段都将被释放，并替换为解码器中相应字段的副本。成功时 &gt;&#x3D; 0，失败时为负 AVERROR 代码。</p>
</li>
<li><p><code>int avcodec_parameters_to_context(AVCodecContext *codec, const struct AVCodecParameters *par)</code>：</p>
<p>  根据<code>AVCodecParameters</code> 参数提供的<strong>解码器参数</strong>（宽高，像素格式等信息）复制到 <code>AVCodecContext</code>（解码器上下文）。</p>
</li>
<li><p><code>int avcodec_open2( AVCodecContext *avctx, const AVCodec* codec, AVDictionary **options)</code>：</p>
<p>  使用初始化后<code>AVCodecContext</code>（编解码器上下文）和设定的选项打开一个编&#x2F;解码器。在使用此函数前，必须使用<code>avcodec_alloc_context3()</code>初始化上下文。</p>
</li>
<li><p><code>int avcodec_send_packet(AVCodecContext* avctx, const AVPacket* avpkt)</code>：</p>
<p>  往 <code>AVCodecContext</code> 绑定的解码器发送一个 <code>AVPacket</code> （需要被解码的一个原始数据帧）。帧的所有权仍属于调用者。返回0表示成功；返回 <code>AVERROR(EAGAIN)</code> 表示当前状态不接受输入，必须调用下面的函数读取输出，然后重新发送数据包；调用前必须用 <code>avcodec_open2()</code> 打开 <code>AVCodecContext</code>。</p>
</li>
<li><p><code>int avcodec_receive_frame(AVCcodecContext* avtx, AVFrame* frame)</code>：</p>
<p>  从 <code>AVCodecContext</code> 绑定的解码器读取一个 <code>AVFrame</code>（解码后的一个输出数据帧），返回值为0表示成功，返回一帧；为 <code>AVERROR(EAGAIN)</code> 表示输出不可用，需要继续输入（可能是B\P帧)；为 <code>AVERROR_EOF</code> 表示解码器完全刷新，不会再有输出帧。</p>
</li>
</ul>
<h2 id="与-AVPacket-和-AVFrame-相关的函数"><a href="#与-AVPacket-和-AVFrame-相关的函数" class="headerlink" title="与 AVPacket 和 AVFrame 相关的函数"></a>与 AVPacket 和 AVFrame 相关的函数</h2><ul>
<li><p><code>AVPacket *av_packet_alloc()</code>：</p>
<p>  创建一个 AVPacket 并将其字段设置为默认值，失败时返回 NULL。必须使用<code>av_packet_free（）</code>释放生成的结构。函数仅分配 AVPacket 本身，而不分配数据缓冲区。这些必须通过其他方式分配，例如使用<code>av_new_packet</code>。</p>
</li>
<li><p><code>AVFrame *av_frame_alloc()</code>：</p>
<p>  创建一个 AVFrame 并将其字段设置为默认值。失败时返回 NULL。必须使用<code>av_frame_free()</code>释放生成的结构。函数仅分配 AVFrame 本身，而不分配数据缓冲区。这些必须通过其他方式分配，例如使用<code>av_frame_get_buffer()</code> 。</p>
</li>
<li><p><code>void* av_malloc(size_t *size*)</code></p>
<p>  分配一个内存块，其对齐方式适合所有内存访问（包括 CPU 上可用的矢量）。类似于 malloc。主要用于为初始化后的<code>AVPacket</code>和<code>AVFrame</code>分配 data 内存。</p>
</li>
<li><p><code>int av_packet_from_data(AVPacket *pkt, uint8_t *data, int size)</code>:</p>
<p>  从已经使用 <code>av_malloc()</code> 分配内存的数据初始化引用计数的数据包。<code>pkt</code>指向要初始化的数据包，<code>data</code> 为由<code>av_malloc()</code>分配的数据缓冲区。成功返回 0，数据归基础 AVBuffer 所有。调用方可能无法通过其他方式访问数据。</p>
</li>
</ul>
<h2 id="AVCodec-和-AVCodecParameters补充"><a href="#AVCodec-和-AVCodecParameters补充" class="headerlink" title="AVCodec 和 AVCodecParameters补充"></a><code>AVCodec</code> 和 <code>AVCodecParameters</code>补充</h2><ul>
<li><code>AVCodec</code> 里面放的是 <strong>解码器的相关信息</strong> 。</li>
</ul>
<p><code>AVCodec</code> 是使用 <code>avcodec_find_decoder()</code> 函数获得的（见上文），传递个函数一个 <code>AVCodecID</code>，返回一个对应的解码器指针。这是引入 FFmpeg 库的时候，他初始化了一堆静态的编解码变量给你。</p>
<p>例如：传递的 <code>AVCodecID</code> 是 <code>AV_CODEC_ID_H265</code> ，就会返回与 <code>H265</code> 视频相关的 <code>AVCodec</code> 指针， <code>AVCodecID</code> 是 <code>AV_CODEC_ID_H264</code> ，就会返回与 <code>264</code> 视频相关的 <code>AVCodec</code> 指针。</p>
<p>只要是用 H264 编码的视频，使用的<strong>解码器</strong>都是一样的，用的是同一个 <code>AVCodec</code>。</p>
<ul>
<li><code>AVCodecParameters</code> 里面放的是 <strong>解码参数</strong>。</li>
</ul>
<p>虽然都是 H265 视频文件，但是他们的宽高，采样这些信息，可能会不一样，这些信息就存在<code>AVCodecParameters</code>里，</p>
<p>当 <code>avformat_open_input</code> 函数打开一个 MP4 的时候，解码参数就会放在 <code>codecpar</code> 字段里，如下：</p>
<p><code>int avformat_open_input(AVFormatContext** ps, const char* url, const AVInputFormat* fmt, AVDictionary** options)</code></p>
<p>但是如果直接获得的裸流，比如本问所描述的，没有文件供打开而获得 <code>AVCodecParameters</code>，因此需要使用<code>AVCodecParameters *avcodec_parameters_alloc()</code>和<code>int avcodec_parameters_from_context(struct AVCodecParameters *par,const AVCodecContext *codec)</code>来构建 AVCodecParameters 。</p>
<p>例如：ps 为 NULL 时，自动分配 AVFormatContext 并将其写入 ps 中，url 可以是网络 URL 也可以是本地文件名；fmt为 NULL 时，此参数强制使用个特定的输入格式，不为 NULL 时自动检测格式；options 参数被销毁，并替换为包含未找到的选项的字典，可能为 NULL。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avformat_open_input(&amp;fmt_ctx, filename, <span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">AVCodecContext *avctx = avcodec_alloc_context3(<span class="literal">NULL</span>);</span><br><span class="line">ret = avcodec_parameters_to_context(avctx, fmt_ctx-&gt;streams[<span class="number">0</span>]-&gt;codecpar);</span><br></pre></td></tr></table></figure>

<p>上面的 <code>codecpar</code> 就是一个 <code>AVCodecParameters</code>，只需要用 <code>avcodec_parameters_to_context</code> 函数把 <code>codecpar</code> 的参数复制给 <code>AVCodecContext</code> 即可。</p>
<h2 id="解码流程"><a href="#解码流程" class="headerlink" title="解码流程"></a>解码流程</h2><h3 id="打开解码器的一般流程"><a href="#打开解码器的一般流程" class="headerlink" title="打开解码器的一般流程"></a>打开解码器的一般流程</h3><p><code>avcodec_alloc_context3()</code> ➔ <code>avcodec_parameters_to_context()</code> ➔ <code>avcodec_find_decoder()</code> ➔ <code>avcodec_open2()</code></p>
<p><code>avcodec_alloc_context3</code> 跟 <code>avcodec_open2</code> 这两个函数都可以接受 <code>AVCodec</code> 参数，选一个函数来接受即可，千万不要往这两个函数传递不一样的 <code>AVCodec</code> 参数。</p>
<p><code>avcodec_alloc_context3()</code> 传入 NULL，初始化一个解码器上下文。</p>
<p><code>avcodec_parameters_to_context()</code>将已有的解码参数复制到解码器上下文。</p>
<p><code>avcodec_find_decoder()</code>根据传入 ID 获得对应的解码器，根据传传入的解码器上下文和解码器信息打开解码器。</p>
<p>示例代码部分如下（为了简短均为没有检测返回值，实际应用时应该检测返回值）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="type">char</span> filename[] = <span class="string">&quot;juren-30s.mp4&quot;</span>;</span><br><span class="line"></span><br><span class="line">fmt_ctx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">avformat_open_input(&amp;fmt_ctx, filename,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">AVCodecContext *avctx = avcodec_alloc_context3(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">avcodec_parameters_to_context(avctx, fmt_ctx-&gt;streams[<span class="number">0</span>]-&gt;codecpar);</span><br><span class="line"></span><br><span class="line">AVCodec *codec = avcodec_find_decoder(avctx-&gt;codec_id);</span><br></pre></td></tr></table></figure>

<h2 id="H-265视频解码流程"><a href="#H-265视频解码流程" class="headerlink" title="H.265视频解码流程"></a>H.265视频解码流程</h2><p>首先，我们已经从网络接收到了待处理的一个个原始视频帧的缓冲区，里面是 H.265 视频裸流。这里注意，裸流可能不包含前四个字节：<code>0x00，0x00，0x00，0x01</code>，这四个字节是区分一帧的关键必须包含，如果没有就手动添加到<code>packet-&gt;data</code>开头，否则交由解码器解码时会报错。</p>
<p>开启一个发数据包的循环不断的将其作为 <code>AVPacket</code> 发给解码器。</p>
<p>解码器收到一个 <code>AVPacket</code>后，我们不一定立马就能从解码器读到一个 <code>AVFrame</code>，因为视频可能有 B 帧，一个单独的 B 帧无法得到一个完整的帧。需要继续给解码器提供后续的 <code>AVPacket</code> 才能得到一个完整的帧。同时在我们提供一个 <code>AVPacket</code> 后，也可能会得到两个完整的帧（由于 B 帧的存在）。</p>
<p>因此，我们发一个 <code>AVPacket</code>后，再开启一个循环读解码器，如果返回值为0，就说明得到一帧 YUV 信息，进行一些处理。如果返回值为<code>EAGAIN</code>，它表示解码器需要输入更多的 <code>AVPacket</code> ，才能解码出 <code>AVFrame</code>，我们就跳出第读解码器的循环，进入发 <code>AVPacket</code> 的循环继续发 <code>AVPacket</code> 。</p>
<p>当所有的 <code>AVPacket</code> 都已经发完时，解码器还可能在等待后续的 <code>AVPacket</code> 到来以解码之前收到的 B 帧，但此时我们已经没有 <code>AVPacket</code> 可以发送给解码器了。此时需要往解码器发一个 <code>size</code> 跟 <code>data</code> 都是 0 的 <code>AVPacket</code>（NULL）。这样解码器就会把它内部剩余的帧，全部都刷出来。</p>
<p>当解码器完全没有帧可以输出的时候，就会返回 <code>AVERROR_EOF</code>。</p>
<h2 id="解码后得到的-AVFrame"><a href="#解码后得到的-AVFrame" class="headerlink" title="解码后得到的 AVFrame"></a>解码后得到的 <code>AVFrame</code></h2><p>部分字段：</p>
<ul>
<li><code>frame-&gt;width</code>,<code>frame-&gt;height</code>：帧的宽高。</li>
<li><code>frame-&gt;pts</code>：帧的显示时间点</li>
<li><code>frame-&gt;pkt_duration</code>：帧的持续时间</li>
<li><code>frame-&gt;format</code>：帧的格式，有很多，整数枚举类型，0 代表 <code>AV_PIX_FMT_YUV420P</code>。</li>
<li><code>frame-&gt;key_frame</code>：（已弃用，使用 flags 中的<code>AV_FRAME_FLAG_KEY</code>代替）代表当前帧是不是关键帧，第一帧通常都是关键帧。I 帧为关键帧，可以单独解码出一个<code>AVFrame</code> ，B、P 帧不是关键帧，不能单独解码出一个<code>AVFrame</code> 。</li>
<li><code>frame-&gt;pict_type</code>：这个是 <code>AVPictureType</code> 枚举类型，1 代表 <code>AV_PICTURE_TYPE_I</code> ，即 I 帧。</li>
<li><code>frame-&gt;data</code>：存储帧的 Y、U、V 信息。</li>
</ul>
<p>解码的到的一般是 YUV420P 格式即上面<code>frame-&gt;format</code>的值：<code>AV_PIX_FMT_YUV420P</code>。它是一个存储帧的格式，以一定的方式存储 Y、U、V 信息（这方面展开说有些多，这里只看 YUV420P ）：</p>
<ul>
<li><p>Y 表示一帧的一块区域的明亮度，U 和 V 表示这块区域的色度与浓度。每个 Y U V 在内存中都占8位。</p>
</li>
<li><p>420 表示4:2:0采样，一个像素一个 Y，水平和垂直方向上都是每两个像素采一个 U 和 V。即每四个Y共用一组 UV 分量。内存上 Y 是 UV 大小的四倍。</p>
</li>
<li><p>P 表示Planar，YUV 按平面分开放，三个平面依次存放，YUV都是连续存储的：</p>
  <img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407161638520.png" alt="image-20240716163803984" style="zoom:80%;" /></li>
</ul>
<p><code>AVFrame</code> 结构体里面有一个 <code>data</code> 字段，存储了 YUV  数据， YUV420P 使用 planar 格式的内存布局来存储，YUV420 使用 packed 格式的内存布局来存储，这里以 YUV420P 为例：</p>
<p><code>data[0]</code> 会指向 Y 数据，<code>data[1]</code> 指向 U 数据，<code>data[2]</code> 指向 V 数据。还有一个 <code>linesize</code> 数组字段来管理这些数据的大小。例如<code>linesize[0]</code>表示<code>data[0]</code>指向的 Y 数据的一行的大小。YUV420P 的格式，U 或者 V 的大小应该是 Y的 4 分之一。</p>
<p>如果直接打印出 <code>linesize</code> 的值，会发现 U、V 的值是 Y 的二分之一。这是因为<code>linesize</code> 里存的是 <code>stride</code> 值。</p>
<p>stride 值 &#x3D; 图像宽度 * 分量数 * 单位样本宽度 &#x2F; 水平子采样因子 &#x2F; 8</p>
<p>分量数就是通道数，YUV420P 是 planer 内存布局 ，所以分量数是 1。单位样本宽度是指一个样本的宽度占多少位，YUV420P 为 16 位。</p>
<p>最重要的是水平采样因子，水平子采样因子指在水平方向上每多少个像素采样出一个色度样本。YUV420P 水平方向其实是每两个像素采样一个色度样本，所以是水平采样因子是 2。</p>
<p>还有一个<strong>垂直采样因子</strong>，YUV420P 的 <strong>垂直采样因子</strong> 也是 2 。但是 垂直采样因子不会影响 stride 值。</p>
<p><code>frame-&gt;linesize</code> 并不是 UV 分量的真实数据大小，而是一个 stride 值。并且从上面可以看出，如果使用的是 YUV420P 格式，会有：stride 值 &#x3D; width * 1 * 16 &#x2F; 2 &#x2F; 8 &#x3D; width，实际上就是帧的宽度 width。最终这个值可能还会内存对齐。</p>
<h2 id="YUV420P-格式的帧保存为图片"><a href="#YUV420P-格式的帧保存为图片" class="headerlink" title="YUV420P 格式的帧保存为图片"></a>YUV420P 格式的帧保存为图片</h2><p>通过<code>data</code>字段我们就可以得到帧的 Y、U、V 信息。 通过 <code>linesize</code> 字段我们可以的到他们的大小。但是一般情况下是<code>data</code>字段都是有<strong>内存对齐</strong>现象存在的。如果<code>linesize</code> 里存的 <code>stride</code> 值大小不足2的n次方，则会填充多余数据以达到2的n次方。例如，计算的到的<code>linesize[0]</code>为480，而它实际大小确是512。因此我们需要镜多余的数据剔除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;frame-&gt;height; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(m_YuvBuf + a, frame-&gt;data[<span class="number">0</span>] + i * frame-&gt;linesize[<span class="number">0</span>], frame-&gt;width);</span><br><span class="line">    a += frame-&gt;width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;frame-&gt;height / <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(m_YuvBuf + a, frame-&gt;data[<span class="number">1</span>] + i * frame-&gt;linesize[<span class="number">1</span>], frame-&gt;width / <span class="number">2</span>);</span><br><span class="line">    a += frame-&gt;width / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;frame-&gt;height / <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(m_YuvBuf + a, frame-&gt;data[<span class="number">2</span>] + i * frame-&gt;linesize[<span class="number">2</span>], frame-&gt;width / <span class="number">2</span>);</span><br><span class="line">    a += frame-&gt;width / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，已经将 H265 裸流保存为了 YUV420P 的文件。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.ffmpeg.org/">FFmpeg 官网</a></p>
<p><a target="_blank" rel="noopener" href="https://ffmpeg.org/doxygen/trunk/index.html">FFmpeg doxygen文档</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yuanmxc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/05/14/FFmpeg%20%E8%A7%A3%E7%A0%81%E8%A7%86%E9%A2%91%E6%B5%81/">http://example.com/2024/05/14/FFmpeg%20%E8%A7%A3%E7%A0%81%E8%A7%86%E9%A2%91%E6%B5%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">陌上尘归处</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p43.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/03/25/%E9%9A%8F%E7%AC%94_24-3-25/" title="随笔-24/3/25"><img class="cover" src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p12.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">随笔-24/3/25</div></div><div class="info-2"><div class="info-item-1">随笔-24&#x2F;3&#x2F;25起因3&#x2F;25 晚上整理博客，QQ上看到一段话，还不错，正好博客弄好了，”关于“这部分还不知道放些什么东西。随笔这些写上面感觉还不错，于是开始在博客上写随笔。但是敲来敲去，总觉得哪里有些怪，不自然。看着屏幕上写的东西，总感觉有那么一丝丝奇怪。 逃避—差不多就是这样。选择困难症又开始了，博客上要不要”记录生活”，写写随笔，还是只写技术，写随笔写什么，怎么写。 高中旧物初中高中的时候也有写过一些记录当时所思所想的文字，尤其是高三压力大那时候，晚上猫在被窝打灯写，虽然大部分是和 ys...</div></div></div></a><a class="pagination-related" href="/2024/05/22/RSTP%E3%80%81RTP%E3%80%81RTCP%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="随笔-24/3/25"><img class="cover" src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">随笔-24/3/25</div></div><div class="info-2"><div class="info-item-1">RSTP、RTP、RTCPRTSP RTP RTCPRTP(Real-time Transport Protocol)，即实时传输协议，是一个应用层的协议，定义了在网络上传输音频和视频的标准数据包的格式。通常说的 RTSP 包括 RTSP 协议、RTP 协议、RTCP 协议，对于这些协议的作用简单的理解如下：  RTSP协议：负责服务器与客户端之间的请求与响应   一般RTSP服务器会从设备（如摄像头）中获取媒体流，并提供一个 RTSP URL 供客户端进行连接，客户端通过 RTSP URL 向服务器发起连接请求，服务器响应，两者开始交换数据，最后建立连接。  RTP协议：负责服务器与客户端之间传输媒体数据   RTP 的端口号通常为偶数，在连接建立后，客户端请求媒体数据，之后服务器通过将媒体流封装为 RTP 包发送给客户端。通常 RTP 的端口为偶数。可以使用 TCP 或者 UDP，一般使用 UDP 并使用 RTCP 协议保证流媒体音视频质量。仅仅是发包。  RTCP 协议：负责提供有关RTP传输质量的反馈，就是确保RTP传输的质量   RTCP 的端口号通肠为对应的 RTP...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/other/touxiang2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yuanmxc</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Yuanmxc"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Yuanmxc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">不乱于心，不困于情。不畏将来，不念过往。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#FFmpeg-%E8%A7%A3%E7%A0%81%E8%A7%86%E9%A2%91%E6%B5%81"><span class="toc-number">1.</span> <span class="toc-text">FFmpeg 解码视频流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FFmpeg-%E5%BA%93"><span class="toc-number">1.2.</span> <span class="toc-text">FFmpeg 库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9F%E8%A7%A3%E7%A0%81%E7%9B%B8%E5%85%B3%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.3.</span> <span class="toc-text">跟解码相关的结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9A%84-API-%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">与解码器相关的 API 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E-AVPacket-%E5%92%8C-AVFrame-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">与 AVPacket 和 AVFrame 相关的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AVCodec-%E5%92%8C-AVCodecParameters%E8%A1%A5%E5%85%85"><span class="toc-number">1.6.</span> <span class="toc-text">AVCodec 和 AVCodecParameters补充</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">解码流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">打开解码器的一般流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H-265%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.8.</span> <span class="toc-text">H.265视频解码流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E5%90%8E%E5%BE%97%E5%88%B0%E7%9A%84-AVFrame"><span class="toc-number">1.9.</span> <span class="toc-text">解码后得到的 AVFrame</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#YUV420P-%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%B8%A7%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%9B%BE%E7%89%87"><span class="toc-number">1.10.</span> <span class="toc-text">YUV420P 格式的帧保存为图片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.11.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/10/ArchLinux%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/" title="ArchLinux 使用记录"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ArchLinux 使用记录"/></a><div class="content"><a class="title" href="/2025/01/10/ArchLinux%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/" title="ArchLinux 使用记录">ArchLinux 使用记录</a><time datetime="2025-01-10T07:39:14.000Z" title="发表于 2025-01-10 15:39:14">2025-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/06/%E5%B0%86%20Python%20%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/" title="将 Python 程序打包为可执行文件（Windows &amp; Linux）"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p11.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="将 Python 程序打包为可执行文件（Windows &amp; Linux）"/></a><div class="content"><a class="title" href="/2025/01/06/%E5%B0%86%20Python%20%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/" title="将 Python 程序打包为可执行文件（Windows &amp; Linux）">将 Python 程序打包为可执行文件（Windows &amp; Linux）</a><time datetime="2025-01-06T08:36:14.000Z" title="发表于 2025-01-06 16:36:14">2025-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/06/Arch%20Linux%20%E4%B8%BA%20AppImage%20%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%99%A8%E5%85%A5%E5%8F%A3/" title="将 Python 程序打包为可执行文件（Windows &amp; Linux）"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p45.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="将 Python 程序打包为可执行文件（Windows &amp; Linux）"/></a><div class="content"><a class="title" href="/2024/11/06/Arch%20Linux%20%E4%B8%BA%20AppImage%20%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%99%A8%E5%85%A5%E5%8F%A3/" title="将 Python 程序打包为可执行文件（Windows &amp; Linux）">将 Python 程序打包为可执行文件（Windows &amp; Linux）</a><time datetime="2024-11-06T07:04:01.000Z" title="发表于 2024-11-06 15:04:01">2024-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/13/Arch%20Linux%20%E5%AE%89%E8%A3%85%20openpose%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Arch Linux 安装 openpose 踩坑记录"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p34.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Arch Linux 安装 openpose 踩坑记录"/></a><div class="content"><a class="title" href="/2024/07/13/Arch%20Linux%20%E5%AE%89%E8%A3%85%20openpose%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Arch Linux 安装 openpose 踩坑记录">Arch Linux 安装 openpose 踩坑记录</a><time datetime="2024-07-13T06:18:36.000Z" title="发表于 2024-07-13 14:18:36">2024-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/05/Arch%20Linux%20%E5%AE%89%E8%A3%85%20CUDA%20%E3%80%81TensorRT%20%20%E5%92%8C%20TensorRT-YOLO%20%E8%AE%B0%E5%BD%95/" title="Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p39.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录"/></a><div class="content"><a class="title" href="/2024/07/05/Arch%20Linux%20%E5%AE%89%E8%A3%85%20CUDA%20%E3%80%81TensorRT%20%20%E5%92%8C%20TensorRT-YOLO%20%E8%AE%B0%E5%BD%95/" title="Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录">Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录</a><time datetime="2024-07-05T02:25:58.000Z" title="发表于 2024-07-05 10:25:58">2024-07-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p43.png);"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By Yuanmxc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">不乱于心，不困于情。不畏将来，不念过往。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>