<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>GSteamer 学习笔记 | 陌上尘归处</title><meta name="author" content="Yuanmxc"><meta name="copyright" content="Yuanmxc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="GSteamer 学习笔记前言本文是笔者阅读 GStreamer 官方文档去学习 GStreamer 时的记录，大部分内容可以在 GStreamer 官方文档中找到。 笔者学习 GStreamer 的主要目的是：使用 GStreamer 处理从 TCP Socket 接收到的 H.265 裸流（使用 live555 的 testRTSPclient 程序从 RTSP URL 中获取到），将其解码并">
<meta property="og:type" content="article">
<meta property="og:title" content="GSteamer 学习笔记">
<meta property="og:url" content="http://example.com/2024/06/02/GSteamer%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="陌上尘归处">
<meta property="og:description" content="GSteamer 学习笔记前言本文是笔者阅读 GStreamer 官方文档去学习 GStreamer 时的记录，大部分内容可以在 GStreamer 官方文档中找到。 笔者学习 GStreamer 的主要目的是：使用 GStreamer 处理从 TCP Socket 接收到的 H.265 裸流（使用 live555 的 testRTSPclient 程序从 RTSP URL 中获取到），将其解码并">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p12.png">
<meta property="article:published_time" content="2024-06-02T03:32:35.000Z">
<meta property="article:modified_time" content="2025-03-03T13:34:24.949Z">
<meta property="article:author" content="Yuanmxc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p12.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "GSteamer 学习笔记",
  "url": "http://example.com/2024/06/02/GSteamer%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
  "image": "https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p12.png",
  "datePublished": "2024-06-02T03:32:35.000Z",
  "dateModified": "2025-03-03T13:34:24.949Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yuanmxc",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/other/touxiang2.png"><link rel="canonical" href="http://example.com/2024/06/02/GSteamer%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GSteamer 学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p2.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/other/touxiang2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p12.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/other/touxiang2.png" alt="Logo"><span class="site-name">陌上尘归处</span></a><a class="nav-page-title" href="/"><span class="site-name">GSteamer 学习笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">GSteamer 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-02T03:32:35.000Z" title="发表于 2024-06-02 11:32:35">2024-06-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-03T13:34:24.949Z" title="更新于 2025-03-03 21:34:24">2025-03-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BE%85%E5%88%86%E7%B1%BB/">待分类</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="GSteamer-学习笔记"><a href="#GSteamer-学习笔记" class="headerlink" title="GSteamer 学习笔记"></a>GSteamer 学习笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是笔者阅读 GStreamer 官方文档去学习 GStreamer 时的记录，大部分内容可以在 GStreamer 官方文档中找到。</p>
<p>笔者学习 GStreamer 的主要目的是：使用 GStreamer 处理从 TCP Socket 接收到的 H.265 裸流（使用 live555 的 testRTSPclient 程序从 RTSP URL 中获取到），将其解码并保存为 jpeg 图片。</p>
<p>笔者最终放弃使用 GStreamer 的想法，使用 FFmpeg 完成了上述目的。</p>
<h2 id="Elements-元素"><a href="#Elements-元素" class="headerlink" title="Elements 元素"></a>Elements 元素</h2><p>GStreamer 中最重要的对象是 <code>GstElement</code> 对象。元素是媒体管道的基本构建基块。使用的所有不同的高级组件都派生自 <code>GstElement</code> 。每个解码器、编码器、解复用器、视频或音频输出实际上都是一个 <code>GstElement</code></p>
<p>对于解码器元素，您将输入编码数据，该元素将输出解码数据。</p>
<p>源元素生成供管道使用的数据，例如从磁盘或声卡读取数据。源元素的可视化显示了我们将如何可视化源元素。我们总是在元素的右侧绘制一个源垫。源元素不接受数据，它们只生成数据。您可以在图中看到这一点，因为它只有一个源pad（在右侧）。源键盘只能生成数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407131343463.png" alt="image-20240713134242338"></p>
<h3 id="Filters-convertors-demuxers-muxers-and-codecs-滤波器、转换器、解复用器、多路复用器和编解码器"><a href="#Filters-convertors-demuxers-muxers-and-codecs-滤波器、转换器、解复用器、多路复用器和编解码器" class="headerlink" title="Filters, convertors, demuxers, muxers and codecs  滤波器、转换器、解复用器、多路复用器和编解码器"></a>Filters, convertors, demuxers, muxers and codecs  滤波器、转换器、解复用器、多路复用器和编解码器</h3><p>滤波器和类似滤波器的元件具有输入和输出 pad。它们对输入（接收）pad 上接收的数据进行操作，并将在输出（源）pad 上提供数据。此类元素的示例包括音量元素（滤波器）、视频缩放器（转换器）、Ogg 解复用器或 Vorbis 解码器。</p>
<p>类似过滤器的元件可以具有任意数量的源或接收垫。例如，视频解复用器将有一个接收器 pad 和几个 （1-N） 源 pad，一个用于容器格式中包含的每个基本流。另一方面，解码器只有一个源和接收 pad。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407131342444.png" alt="image-20240713134223075"></p>
<p>过滤器元素的可视化显示了我们将如何可视化类似过滤器的元素。此特定元素具有一个源垫和一个接收垫。接收输入数据的接收垫在元件的左侧绘制;源键盘仍然在右侧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407131342891.png" alt="image-20240713134254302"></p>
<p>具有多个输出 pad 的滤波元件的可视化显示了另一个类似滤波器的滤波器元件，该滤波元件具有多个输出（源）pad。例如，一个此类元素的示例可以是包含音频和视频的 Ogg 流的 Ogg 解复用器。一个源 pad 将包含基本视频流，另一个将包含基本音频流。解复用器通常会在创建新 pad 时触发信号。然后，应用程序程序员可以在信号处理程序中处理新的初级流。</p>
<h3 id="Sink-elements-接收器元素"><a href="#Sink-elements-接收器元素" class="headerlink" title="Sink elements 接收器元素"></a>Sink elements 接收器元素</h3><p>接收器元素是媒体管道中的端点。他们接受数据，但不产生任何东西。磁盘写入、声卡播放和视频输出都将由接收器元素实现。接收器元素的可视化显示接收器元素。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407131344169.png" alt="image-20240713134444575"></p>
<h3 id="Creating-a-GstElement-创建-GstElement"><a href="#Creating-a-GstElement-创建-GstElement" class="headerlink" title="Creating a GstElement 创建 GstElement"></a>Creating a <code>GstElement</code> 创建 <code>GstElement</code></h3><p>创建元素的最简单方法是使用 <code>gst_element_factory_make ()</code> .此函数采用工厂名称和新创建的元素的元素名称。例如，元素的名称是稍后可用于在 bin 中查找元素的名称。该名称也将用于调试输出。可以作为 name 参数传递 <code>NULL</code> 以获取唯一的默认名称。</p>
<p>当您不再需要该元素时，您需要使用 <code>gst_object_unref ()</code> 取消引用它。这会将元素的引用计数减少 1。元素在创建时的引用计数为 1。当 refcount 减少到 0 时，元素将被完全销毁。</p>
<p>下面的示例 [1] 展示了如何从名为 fakesrc 的元素工厂创建名为 source 的元素。它检查创建是否成功。检查后，它会取消引用元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    GstElement *element;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init GStreamer */</span></span><br><span class="line">    gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create element */</span></span><br><span class="line">    element = gst_element_factory_make (<span class="string">&quot;fakesrc&quot;</span>, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!element) &#123;</span><br><span class="line">        g_print (<span class="string">&quot;Failed to create element of type &#x27;fakesrc&#x27;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gst_object_unref (GST_OBJECT (element));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gst_element_factory_make</code> 实际上是两个函数组合的简写。 <code>GstElement</code> 对象是从工厂创建的。要创建元素，您必须使用唯一的工厂名称访问 <code>GstElementFactory</code> 对象。这是用 <code>gst_element_factory_find ()</code> .</p>
<p>以下代码片段用于获取可用于创建 fakesrc 元素（假数据源）的工厂。该函数<code>gst_element_factory_create ()</code> 将使用元素工厂创建具有给定名称的元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span>  argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    GstElementFactory *factory;</span><br><span class="line">    GstElement * element;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init GStreamer */</span></span><br><span class="line">    gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create element, method #2 */</span></span><br><span class="line">    factory = gst_element_factory_find (<span class="string">&quot;fakesrc&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!factory) &#123;</span><br><span class="line">        g_print (<span class="string">&quot;Failed to find factory of type &#x27;fakesrc&#x27;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    element = gst_element_factory_create (factory, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!element) &#123;</span><br><span class="line">        g_print (<span class="string">&quot;Failed to create element, even though its factory exists!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gst_object_unref (GST_OBJECT (element));</span><br><span class="line">    gst_object_unref (GST_OBJECT (factory));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用元素作为-GObject"><a href="#使用元素作为-GObject" class="headerlink" title="使用元素作为 GObject"></a>使用元素作为 <code>GObject</code></h3><p>A <code>GstElement</code> 可以具有多个属性，这些属性是使用标准 <code>GObject</code> 属性实现的。因此，支持查询、设置和获取属性值 <code>GParamSpecs</code> 的常用 <code>GObject</code> 方法。</p>
<p>每个 <code>GstElement</code> 都从其父 <code>GstObject</code> 级继承至少一个属性：“name”属性。这是我们提供给函数 <code>gst_element_factory_make ()</code> 的名称，或者 <code>gst_element_factory_create ()</code> .可以使用函数 <code>gst_object_set_name</code> 获取和设置此属性，或者 <code>gst_object_get_name</code> 使用如下所示的 <code>GObject</code> 属性机制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    GstElement *element;</span><br><span class="line">    gchar *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init GStreamer */</span></span><br><span class="line">    gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create element */</span></span><br><span class="line">    element = gst_element_factory_make (<span class="string">&quot;fakesrc&quot;</span>, <span class="string">&quot;source&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get name */</span></span><br><span class="line">    g_object_get (G_OBJECT (element), <span class="string">&quot;name&quot;</span>, &amp;name, <span class="literal">NULL</span>);</span><br><span class="line">    g_print (<span class="string">&quot;The name of the element is &#x27;%s&#x27;.\n&quot;</span>, name);</span><br><span class="line">    g_free (name);</span><br><span class="line"></span><br><span class="line">    gst_object_unref (GST_OBJECT (element));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数插件都提供额外的属性，以提供有关其配置或配置元素的更多信息。 <code>gst-inspect</code> 是查询特定元素属性的有用工具，它还将使用属性自省来简要说明属性的功能以及它支持的参数类型和范围。有关 的详细信息，请参阅附录中的 gst-inspect <code>gst-inspect</code> 。</p>
<p>有关 <code>GObject</code> 属性的更多信息，我们建议您阅读 GObject 手册和 Glib 对象系统简介。</p>
<p><code>GstElement</code> 还提供了各种 <code>GObject</code> 信号，可用作灵活的回调机制。在这里，您也可以用来 <code>gst-inspect</code> 查看特定元素支持哪些信号。总之，信号和属性是元素和应用程序交互的最基本方式。</p>
<h3 id="有关元件工厂的更多信息"><a href="#有关元件工厂的更多信息" class="headerlink" title="有关元件工厂的更多信息"></a>有关元件工厂的更多信息</h3><p>在上一节中，我们简要介绍了 <code>GstElementFactory</code> 该对象作为创建元素实例的一种方式。然而，元素工厂远不止于此。元素工厂是从 GStreamer 注册表中检索到的基本类型，它们描述了 GStreamer 可以创建的所有插件和元素。这意味着元素工厂对于自动元素实例化（例如自动插件的作用）和创建可用元素列表非常有用。</p>
<h3 id="使用工厂获取有关元素的信息"><a href="#使用工厂获取有关元素的信息" class="headerlink" title="使用工厂获取有关元素的信息"></a>使用工厂获取有关元素的信息</h3><p>像 <code>gst-inspect</code> 这样的工具将提供有关元素的一些通用信息，例如编写插件的人、描述性名称（和简称）、排名和类别。该类别可用于获取可以使用此元素工厂创建的元素的类型。类别的示例包括 <code>Codec/Decoder/Video</code> （视频解码器）、 <code>Codec/Encoder/Video</code> （视频编码器）、 <code>Source/Video</code> （视频生成器）、 <code>Sink/Video</code> （视频输出），当然，所有这些也都存在于音频中。然后， <code>Codec/Demuxer</code> <code>Codec/Muxer</code> 还有更多。 <code>gst-inspect</code> 将列出所有工厂的列表，并 <code>gst-inspect &lt;factory-name&gt;</code> 列出上述所有信息，以及更多。</p>
<p>可以使用 <code>gst_registry_pool_feature_list (GST_TYPE_ELEMENT_FACTORY)</code> 来获取 GStreamer 所知道的所有元素工厂的列表。</p>
<h3 id="找出元素可以包含哪些-pad"><a href="#找出元素可以包含哪些-pad" class="headerlink" title="找出元素可以包含哪些 pad"></a>找出元素可以包含哪些 pad</h3><p>也许元素工厂最强大的功能是它们包含元素可以生成的的完整描述，以及这些 pad 的功能（通俗地说：哪些类型的媒体可以通过这些 pad 进行流式传输），而无需实际将这些插件加载到内存中。这可用于为编码器提供解码器选择列表，也可以用于媒体播放器的自动插入目的。当前所有基于 GStreamer 的媒体播放器和自动插件都以这种方式工作。我们将在 <code>GstPad</code> <code>GstCaps</code> 下一章中更深入地了解这些功能：Pads 和 capabilities</p>
<h3 id="链接元素"><a href="#链接元素" class="headerlink" title="链接元素"></a>链接元素</h3><p>通过将源元素与零个或多个类似筛选器的元素以及最终的接收器元素链接起来，可以设置媒体管道。数据将流经元素。这是 GStreamer 中媒体处理的基本概念。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407131413943.png" alt="image-20240713141346614"></p>
<p>通过链接这三个元素，我们创建了一个非常简单的元素链。这样做的效果是，源元素的输出将用作类似过滤器的元素的输入。类似筛选器的元素将对数据执行某些操作，并将结果发送到最终的接收器元素。</p>
<p>在代码中，上面的图是这样写的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    GstElement *pipeline;</span><br><span class="line">    GstElement *source, *filter, *sink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init */</span></span><br><span class="line">    gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create pipeline */</span></span><br><span class="line">    pipeline = gst_pipeline_new (<span class="string">&quot;my-pipeline&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create elements */</span></span><br><span class="line">    source = gst_element_factory_make (<span class="string">&quot;fakesrc&quot;</span>, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">    filter = gst_element_factory_make (<span class="string">&quot;identity&quot;</span>, <span class="string">&quot;filter&quot;</span>);</span><br><span class="line">    sink = gst_element_factory_make (<span class="string">&quot;fakesink&quot;</span>, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* must add elements to pipeline before linking them */</span></span><br><span class="line">    gst_bin_add_many (GST_BIN (pipeline), source, filter, sink, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* link */</span></span><br><span class="line">    <span class="keyword">if</span> (!gst_element_link_many (source, filter, sink, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        g_warning (<span class="string">&quot;Failed to link elements!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [..]</span><br></pre></td></tr></table></figure>

<p>对于更具体的行为，还有函数 <code>gst_element_link ()</code> 和 <code>gst_element_link_pads ()</code> .您还可以获取对单个焊盘的引用，并使用各种 <code>gst_pad_link_* ()</code> 功能链接这些焊盘。有关更多详细信息，请参阅 API 参考。</p>
<p>重要提示：在链接元素或管道之前，必须将元素添加到图格或管道中，因为将元素添加到图格中会断开任何已存在的链接。此外，不能直接链接不在同一 bin 或管道中的元素;如果要链接不同层次结构级别的元素或填充物，则需要使用 ghost pads（稍后将详细介绍 ghost pads）。</p>
<h3 id="元素状态"><a href="#元素状态" class="headerlink" title="元素状态"></a>元素状态</h3><p>创建后，元素实际上不会执行任何操作。您需要更改元素状态以使其执行某些操作。GStreamer 知道四种元素状态，每种状态都有非常具体的含义。这四个状态是：</p>
<ul>
<li><p><code>GST_STATE_NULL</code> ：这是默认状态。在此状态下不会分配任何资源，因此，过渡到该状态将释放所有资源。当元素的 refcount 达到 0 并被释放时，该元素必须处于此状态。</p>
</li>
<li><p><code>GST_STATE_READY</code> ：在就绪状态下，元素已分配其所有全局资源，即可以保留在流中的资源。您可以考虑打开设备、分配缓冲区等。但是，流不会在此状态下打开，因此流位置自动为零。如果以前打开了流，则应在此状态下关闭该流，并应重置位置、属性等。</p>
</li>
<li><p><code>GST_STATE_PAUSED</code> ：在此状态下，元素已打开流，但未主动处理它。允许元素修改流的位置、读取和处理数据等，以便在状态更改为 PAUSE 后立即准备播放，但不允许播放会使时钟运行的数据。总之，PAUSED 与 PLAYING 相同，但没有运行时钟。</p>
<p>  进入 <code>PAUSED</code> 状态的元素应为尽快进入 <code>PLAYING</code> 状态做好准备。例如，视频或音频输出将等待数据到达并对其进行排队，以便它们可以在状态更改后立即播放。此外，视频接收器已经可以播放第一帧（因为这还不会影响时钟）。自动插拔器可以使用相同的状态转换来将管道插入在一起。但是，大多数其他元素（如编解码器或筛选器）不需要在此状态下显式执行任何操作。</p>
</li>
<li><p><code>GST_STATE_PLAYING</code> ：在 <code>PLAYING</code> 状态中，元素的操作与 <code>PAUSED</code> 状态中的元素完全相同，只是时钟现在运行。</p>
</li>
</ul>
<p>可以使用函数 <code>gst_element_set_state ()</code> 更改元素的状态。如果将元素设置为另一种状态，GStreamer 将在内部遍历所有中间状态。因此，如果将元素从 <code>NULL</code> 设置为 <code>PLAYING</code> ，GStreamer 将在内部将元素设置为介 <code>READY</code> 于 和 <code>PAUSED</code> 之间。</p>
<p>移动到 <code>GST_STATE_PLAYING</code> 时，管道将自动处理数据。它们不需要以任何形式进行迭代。在内部，GStreamer 将启动线程来为他们承担此任务。GStreamer 还将负责将消息从管道的线程切换到应用程序自己的线程，方法是使用 <code>GstBus</code> .有关详细信息，请参阅 Bus 文档。</p>
<p>当您将 bin 或管道设置为特定目标状态时，它通常会自动将状态更改传播到 bin 或管道中的所有元素，因此通常只需设置顶级管道的状态即可启动或关闭管道。但是，当动态地将元素添加到已经运行的管道中时，例如从“pad 添加”信号回调中，您需要使用 <code>gst_element_set_state ()</code> 或 <code>gst_element_sync_state_with_parent ()</code> 自行将其设置为所需的目标状态。</p>
<h2 id="Bins-箱"><a href="#Bins-箱" class="headerlink" title="Bins 箱"></a>Bins 箱</h2><p>bin 是容器元素。您可以将元素添加到 bin 中。由于 bin 本身就是一个元素，因此 bin 的处理方式与任何其他元素相同。因此，上一章（元素）也适用于 bin。</p>
<p>bin 允许您将一组链接的元素组合成一个逻辑元素。您不再处理单个元素，而只处理一个元素，即 bin。我们将看到，当您要构建复杂的管道时，这非常强大，因为它允许您将管道分解为更小的块。</p>
<p>bin 还将管理其中包含的元素。它将对元素执行状态更改，以及收集和转发总线消息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407131424109.png" alt="image-20240713142442923"></p>
<p>GStreamer 程序员可以使用一种特殊类型的 bin：</p>
<ul>
<li>管道：管理所包含元素的同步和总线消息的通用容器。顶层 bin 必须是一个管道，因此每个应用程序至少需要其中一个。</li>
</ul>
<h3 id="Creating-a-bin"><a href="#Creating-a-bin" class="headerlink" title="Creating a bin"></a>Creating a bin</h3><p>bin 的创建方式与其他元素的创建方式相同，即使用元素工厂。还有便利功能可用（ <code>gst_bin_new ()</code> 和 <code>gst_pipeline_new ()</code> ）。要将元素添加到 bin 中或从 bin 中删除元素，可以使用 <code>gst_bin_add ()</code> 和 <code>gst_bin_remove ()</code> 。请注意，添加元素的 bin 将获得该元素的所有权。如果销毁 bin，则该元素将与它一起取消引用。如果从 bin 中删除元素，则该元素将自动取消引用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    GstElement *bin, *pipeline, *source, *sink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init */</span></span><br><span class="line">    gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create */</span></span><br><span class="line">    pipeline = gst_pipeline_new (<span class="string">&quot;my_pipeline&quot;</span>);</span><br><span class="line">    bin = gst_bin_new (<span class="string">&quot;my_bin&quot;</span>);</span><br><span class="line">    source = gst_element_factory_make (<span class="string">&quot;fakesrc&quot;</span>, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">    sink = gst_element_factory_make (<span class="string">&quot;fakesink&quot;</span>, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First add the elements to the bin */</span></span><br><span class="line">    gst_bin_add_many (GST_BIN (bin), source, sink, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* add the bin to the pipeline */</span></span><br><span class="line">    gst_bin_add (GST_BIN (pipeline), bin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* link the elements */</span></span><br><span class="line">    gst_element_link (source, sink);</span><br><span class="line"></span><br><span class="line">    [..]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有多种功能可以在 bin 中查找元素。最常用的是 <code>gst_bin_get_by_name ()</code> 和 <code>gst_bin_get_by_interface ()</code> 。您还可以使用函数 <code>gst_bin_iterate_elements ()</code> 循环访问 bin 包含的所有元素。有关详细信息，请参阅<code>GstBin</code>API 参考。</p>
<h3 id="Bin-管理其子项的状态"><a href="#Bin-管理其子项的状态" class="headerlink" title="Bin 管理其子项的状态"></a>Bin 管理其子项的状态</h3><p>Bins 管理其中包含的所有元素的状态。如果使用 <code>gst_element_set_state ()</code> 将 bin（或管道，这是一种特殊的顶级 bin 类型）设置为特定目标状态，它将确保其中包含的所有元素也将设置为此状态。这意味着通常只需设置顶级管道的状态即可启动或关闭管道。</p>
<p>bin 将对其从 sink 元素到源元素的所有子元素执行状态更改。这可确保下游元素在上游元素被带到 <code>PAUSED</code> 或 <code>PLAYING</code> 时准备好接收数据。同样，在关闭时，接收器元素将设置为 <code>READY</code> or <code>NULL</code> first，这将导致上游元素收到 <code>FLUSHING</code> 错误，并在元素设置为 <code>READY</code> or <code>NULL</code> 状态之前停止流线程。</p>
<p>但是请注意，如果元素被添加到已经在运行的 bin 或管道中，例如从“pad-added”信号回调中，其状态不会自动与添加它的 bin 或管道的当前状态或目标状态保持一致。相反，您需要自己使用 <code>gst_element_set_state ()</code> 或 <code>gst_element_sync_state_with_parent ()</code> 在将元素添加到已运行的管道时将其设置为所需的目标状态。</p>
<h2 id="Bus-总线"><a href="#Bus-总线" class="headerlink" title="Bus 总线"></a>Bus 总线</h2><p>总线是一个简单的系统，它负责将消息从流式处理线程转发到其自己的线程上下文中的应用程序。总线的优点是，即使 GStreamer 本身是大量线程的，应用程序也不需要线程感知即可使用 GStreamer。</p>
<p>默认情况下，每个管道都包含总线，因此应用程序不需要创建总线或任何内容。应用程序唯一应该做的就是在总线上设置消息处理程序，这类似于对象的信号处理程序。当主循环运行时，会定期检查总线是否有新消息，当有消息可用时会调用回调。</p>
<p>有两种不同的总线使用方式：</p>
<ul>
<li><p>运行 GLib&#x2F;Gtk+ 主循环（或自己定期迭代默认的 GLib 主上下文）并将某种监视连接到总线上。这样，GLib 主循环将检查总线是否有新消息，并在有消息时通知您。</p>
<p>  通常，在这种情况下，您会使用 <code>gst_bus_add_watch ()</code> or <code>gst_bus_add_signal_watch ()</code> 。</p>
<p>  要使用总线，请使用 <code>gst_bus_add_watch ()</code> 将消息处理程序附加到管道的总线上。每当管道向总线发出消息时，都会调用此处理程序。在此处理程序中，检查信号类型（请参阅下一节）并执行相应的操作。处理程序的返回值应该是 <code>TRUE</code> 保持处理程序连接到总线，返回 <code>FALSE</code> 以删除它。</p>
</li>
<li><p>自行检查 bus 上的消息。这可以使用 <code>gst_bus_peek ()</code> 和&#x2F;或 <code>gst_bus_poll ()</code> 来完成。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> GMainLoop *loop;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> gboolean</span><br><span class="line"><span class="title function_">my_bus_callback</span> <span class="params">(GstBus * bus, GstMessage * message, gpointer data)</span></span><br><span class="line">&#123;</span><br><span class="line">  g_print (<span class="string">&quot;Got %s message\n&quot;</span>, GST_MESSAGE_TYPE_NAME (message));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (GST_MESSAGE_TYPE (message)) &#123;</span><br><span class="line">    <span class="keyword">case</span> GST_MESSAGE_ERROR:&#123;</span><br><span class="line">      GError *err;</span><br><span class="line">      gchar *debug;</span><br><span class="line"></span><br><span class="line">      gst_message_parse_error (message, &amp;err, &amp;debug);</span><br><span class="line">      g_print (<span class="string">&quot;Error: %s\n&quot;</span>, err-&gt;message);</span><br><span class="line">      g_error_free (err);</span><br><span class="line">      g_free (debug);</span><br><span class="line"></span><br><span class="line">      g_main_loop_quit (loop);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> GST_MESSAGE_EOS:</span><br><span class="line">      <span class="comment">/* end-of-stream */</span></span><br><span class="line">      g_main_loop_quit (loop);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">/* unhandled message */</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* we want to be notified again the next time there is a message</span></span><br><span class="line"><span class="comment">   * on the bus, so returning TRUE (FALSE means we want to stop watching</span></span><br><span class="line"><span class="comment">   * for messages on the bus and our callback should not be called again)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gint</span><br><span class="line"><span class="title function_">main</span> <span class="params">(gint argc, gchar * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  GstElement *pipeline;</span><br><span class="line">  GstBus *bus;</span><br><span class="line">  guint bus_watch_id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* init */</span></span><br><span class="line">  gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* create pipeline, add handler */</span></span><br><span class="line">  pipeline = gst_pipeline_new (<span class="string">&quot;my_pipeline&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* adds a watch for new message on our pipeline&#x27;s message bus to</span></span><br><span class="line"><span class="comment">   * the default GLib main context, which is the main context that our</span></span><br><span class="line"><span class="comment">   * GLib main loop is attached to below</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));</span><br><span class="line">  bus_watch_id = gst_bus_add_watch (bus, my_bus_callback, <span class="literal">NULL</span>);</span><br><span class="line">  gst_object_unref (bus);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* [...] */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* create a mainloop that runs/iterates the default GLib main context</span></span><br><span class="line"><span class="comment">   * (context NULL), in other words: makes the context check if anything</span></span><br><span class="line"><span class="comment">   * it watches for has happened. When a message has been posted on the</span></span><br><span class="line"><span class="comment">   * bus, the default main context will automatically call our</span></span><br><span class="line"><span class="comment">   * my_bus_callback() function to notify us of that message.</span></span><br><span class="line"><span class="comment">   * The main loop will be run until someone calls g_main_loop_quit()</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  loop = g_main_loop_new (<span class="literal">NULL</span>, FALSE);</span><br><span class="line">  g_main_loop_run (loop);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* clean up */</span></span><br><span class="line">  gst_element_set_state (pipeline, GST_STATE_NULL);</span><br><span class="line">  gst_object_unref (pipeline);</span><br><span class="line">  g_source_remove (bus_watch_id);</span><br><span class="line">  g_main_loop_unref (loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的是要知道处理程序将在 mainloop 的线程上下文中调用。这意味着管道和应用程序之间通过总线的交互是异步的，因此不适合某些实时目的，例如音轨之间的交叉淡入淡出、执行（理论上）无缝播放或视频效果。所有这些事情都应该在管道上下文中完成，这可以通过编写 GStreamer 插件来获得最简单的操作。不过，它对于其主要目的非常有用：将消息从管道传递到应用程序。这种方法的优点是 GStreamer 在内部执行的所有线程都对应用程序隐藏，应用程序开发人员根本不需要担心线程问题。</p>
<p>请注意，如果您使用的是默认的 GLib 主环路集成，则可以连接到总线上的“消息”信号，而不是连接总线。这样，您就不必 <code>switch()</code> 处理所有可能的消息类型;只需以 的形式 <code>message::&lt;type&gt;</code> 连接到感兴趣的信号，其中 <code>&lt;type&gt;</code> 是特定的消息类型（有关消息类型的说明，请参阅下一节）。</p>
<p>上面的片段也可以写成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GstBus *bus;</span><br><span class="line"></span><br><span class="line">[..]</span><br><span class="line"></span><br><span class="line">bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));</span><br><span class="line">gst_bus_add_signal_watch (bus);</span><br><span class="line">g_signal_connect (bus, <span class="string">&quot;message::error&quot;</span>, G_CALLBACK (cb_message_error), <span class="literal">NULL</span>);</span><br><span class="line">g_signal_connect (bus, <span class="string">&quot;message::eos&quot;</span>, G_CALLBACK (cb_message_eos), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">[..]</span><br></pre></td></tr></table></figure>

<p>如果不使用 GLib 主循环，则默认情况下异步消息信号将不可用。但是，您可以安装一个自定义同步处理程序，该处理程序用于唤醒自定义主循环并用于 <code>gst_bus_async_signal_func ()</code> 发出信号。（有关详细信息，另请参阅文档）</p>
<h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>GStreamer 有一些预定义的消息类型，可以通过总线传递。但是，这些消息是可扩展的。插件可以定义其他消息，应用程序可以决定为这些消息提供特定代码或忽略它们。强烈建议所有应用程序至少通过向用户提供视觉反馈来处理错误消息。</p>
<p>所有消息都有消息源、类型和时间戳。消息源可用于查看发出消息的元素。例如，对于某些消息，只有顶级管道发出的消息对大多数应用程序（例如状态更改通知）感兴趣。下面是所有消息的列表，以及它们的作用以及如何解析消息特定内容的简短说明。</p>
<h2 id="Pads-和-capabilities"><a href="#Pads-和-capabilities" class="headerlink" title="Pads 和 capabilities"></a>Pads 和 capabilities</h2><p>正如我们在 Elements 中看到的，pads 是元素与外界的接口。数据从一个元素的 source pad 流到另一个元素的 sink pad。元素可以处理的特定类型的媒体将由 pads 的功能公开。我们将在本章后面详细讨论功能（请参阅 <a target="_blank" rel="noopener" href="https://gstreamer.freedesktop.org/documentation/application-development/basics/pads.html#capabilities-of-a-pad">Capabilities of a pad</a>）。</p>
<h3 id="Pads"><a href="#Pads" class="headerlink" title="Pads"></a>Pads</h3><p>Pad 类型由两个属性定义：其方向和可用性。正如我们之前提到的，GStreamer 定义了两个 pad 方向：源 pad 和接收 pad。该术语是从元素内部的视图定义的：元素在其接收 pad 上接收数据，并在其源 pad 上生成数据。从原理上讲，接收 pad 绘制在元素的左侧，而源 pad 绘制在元素的右侧。在此类图形中，数据从左向右流动。</p>
<p>与 pad 可用性相比，pad 方向非常简单。pad 可以有三种可用性中的任何一种：always, sometimes and on-request。这三种类型的含义正如它所说的那样：always pad 始终存在，sometimes pad 只存在于特定情况下（并且可以随机消失），并且 on-request pad 仅在应用程序明确请求时才会出现。</p>
<h3 id="Dynamic-or-sometimes-pads"><a href="#Dynamic-or-sometimes-pads" class="headerlink" title="Dynamic (or sometimes) pads"></a>Dynamic (or sometimes) pads</h3><p>创建元素时，某些元素可能没有所有 pad。例如，使用 Ogg 解复用器元件时可能会发生这种情况。当该元素在 Ogg 流中检测到这样的流时，它将读取 Ogg 流并为每个包含的基本流（vorbis、theora）创建动态 pad。同样，它将在流结束时删除 pad。例如，此原理对于解复用器元件非常有用。</p>
<p>运行 <code>gst-inspect-1.0 oggdemux</code> 将显示该元素只有一个焊盘：一个名为“sink”的 sink 焊盘。其他焊盘处于“休眠状态”。您可以在 pad 模板中看到这一点，因为有一个“可用性：有时”属性。根据您播放的 Ogg 文件的类型，将创建 pad。我们将看到，当您要创建动态管道时，这一点非常重要。您可以将信号处理程序附加到元素，以便在元素从其“sometimes” pad 模板之一创建新 pad 时通知您。以下代码段是执行此操作的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cb_new_pad</span> <span class="params">(GstElement *element, GstPad *pad, gpointer data)</span></span><br><span class="line">&#123;</span><br><span class="line">    gchar *name;</span><br><span class="line"></span><br><span class="line">    name = gst_pad_get_name (pad);</span><br><span class="line">    g_print (<span class="string">&quot;A new pad %s was created\n&quot;</span>, name);</span><br><span class="line">    g_free (name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* here, you would setup a new pad link for the newly created pad */</span></span><br><span class="line">    [..]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">    <span class="title function_">main</span> <span class="params">(<span class="type">int</span>   argc,</span></span><br><span class="line"><span class="params">          <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    GstElement *pipeline, *source, *demux;</span><br><span class="line">    GMainLoop *loop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init */</span></span><br><span class="line">    gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create elements */</span></span><br><span class="line">    pipeline = gst_pipeline_new (<span class="string">&quot;my_pipeline&quot;</span>);</span><br><span class="line">    source = gst_element_factory_make (<span class="string">&quot;filesrc&quot;</span>, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">    g_object_set (source, <span class="string">&quot;location&quot;</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    demux = gst_element_factory_make (<span class="string">&quot;oggdemux&quot;</span>, <span class="string">&quot;demuxer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* you would normally check that the elements were created properly */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* put together a pipeline */</span></span><br><span class="line">    gst_bin_add_many (GST_BIN (pipeline), source, demux, <span class="literal">NULL</span>);</span><br><span class="line">    gst_element_link_pads (source, <span class="string">&quot;src&quot;</span>, demux, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* listen for newly created pads */</span></span><br><span class="line">    g_signal_connect (demux, <span class="string">&quot;pad-added&quot;</span>, G_CALLBACK (cb_new_pad), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start the pipeline */</span></span><br><span class="line">    gst_element_set_state (GST_ELEMENT (pipeline), GST_STATE_PLAYING);</span><br><span class="line">    loop = g_main_loop_new (<span class="literal">NULL</span>, FALSE);</span><br><span class="line">    g_main_loop_run (loop);</span><br><span class="line"></span><br><span class="line">    [..]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅从“pad-added”回调中向管道添加元素的情况并不少见。如果执行此操作，请不要忘记使用 <code>gst_element_set_state ()</code> 或 <code>gst_element_sync_state_with_parent ()</code> 将新添加元素的状态设置为管道的目标状态。</p>
<h3 id="Request-pads"><a href="#Request-pads" class="headerlink" title="Request pads"></a>Request pads</h3><p>元素也可以具有请求 pad。这些 pad 不是自动创建的，而只是按需创建。这对于多路复用器、聚合器和 T 恤元件非常有用。聚合器是将多个输入流的内容合并到一个输出流中的元素。Tee 元素则相反：它们是具有一个输入流并将此流复制到每个输出 pad 的元素，这些输出 pad 是根据请求创建的。每当应用程序需要流的另一个副本时，它只需从 tee 元素请求新的输出 pad 即可。</p>
<p>以下代码段演示如何从“tee”元素请求新的输出 pad ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">some_function</span> <span class="params">(GstElement * tee)</span></span><br><span class="line">&#123;</span><br><span class="line">    GstPad *pad;</span><br><span class="line">    gchar *name;</span><br><span class="line"></span><br><span class="line">    pad = gst_element_request_pad_simple (tee, <span class="string">&quot;src%d&quot;</span>);</span><br><span class="line">    name = gst_pad_get_name (pad);</span><br><span class="line">    g_print (<span class="string">&quot;A new pad %s was created\n&quot;</span>, name);</span><br><span class="line">    g_free (name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* here, you would link the pad */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* [..] */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* and, after doing that, free our reference */</span></span><br><span class="line">    gst_object_unref (GST_OBJECT (pad));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该 <code>gst_element_request_pad_simple ()</code> 方法可用于根据 pad 模板的名称从元素中获取 pad。也可以请求与另一个 pad 模板兼容的 pad。如果要将元件链接到多路复用器元件，并且需要请求兼容的 pad ，这将非常有用。该方法 <code>gst_element_get_compatible_pad ()</code> 可用于请求兼容的 pad，如下例所示。它将从任何输入的 Ogg 多路复用器请求兼容 pad。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">link_to_multiplexer</span> <span class="params">(GstPad * tolink_pad, GstElement * mux)</span></span><br><span class="line">&#123;</span><br><span class="line">  GstPad *pad;</span><br><span class="line">  gchar *srcname, *sinkname;</span><br><span class="line"></span><br><span class="line">  srcname = gst_pad_get_name (tolink_pad);</span><br><span class="line">  pad = gst_element_get_compatible_pad (mux, tolink_pad, <span class="literal">NULL</span>);</span><br><span class="line">  gst_pad_link (tolink_pad, pad);</span><br><span class="line">  sinkname = gst_pad_get_name (pad);</span><br><span class="line">  gst_object_unref (GST_OBJECT (pad));</span><br><span class="line"></span><br><span class="line">  g_print (<span class="string">&quot;A new pad %s was created and linked to %s\n&quot;</span>, sinkname, srcname);</span><br><span class="line">  g_free (sinkname);</span><br><span class="line">  g_free (srcname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Capabilities-of-a-pad"><a href="#Capabilities-of-a-pad" class="headerlink" title="Capabilities of a pad"></a>Capabilities of a pad</h3><p>由于 pad 在外界如何看待元素方面起着非常重要的作用，因此使用 capabilities 实现了一种机制来描述可以流过 pad 或当前流经 pad 的数据。在这里，我们将简要描述什么是 capabilities 以及如何使用它们，足以理解这个概念。</p>
<p> capabilities 附加到 pad 模板和 pad 上。对于 pad 模板，它将描述可能流式传输通过从此模板创建的 pad 的媒体类型。对于 pad ，它可以是可能的上限列表（通常是 pad 模板功能的副本），在这种情况下， pad 尚未协商，或者它是当前流经此 pad 的媒体类型，在这种情况下， pad 已经协商好了。</p>
<h3 id="Dissecting-capabilities-解剖能力"><a href="#Dissecting-capabilities-解剖能力" class="headerlink" title="Dissecting capabilities 解剖能力"></a>Dissecting capabilities 解剖能力</h3><p>打击垫的功能在 <code>GstCaps</code> 对象中描述。在内部，a <code>GstCaps</code> 将包含一个或多个 <code>GstStructure</code> 将描述一种媒体类型的内容。协商 pad 将具有仅包含一个结构的功能集。此外，此结构将仅包含固定值。对于未协商的 pad 或 pad 模板，这些约束不成立。</p>
<p>例如，下面是“vorbisdec”元素功能的转储，您将通过运行 <code>gst-inspect vorbisdec</code> .您将看到两个 pad ：源 pad 和接收 pad 。这两个 pad 始终可用，并且都附加了功能。接收器 pad 将接受 vorbis 编码的音频数据，媒体类型为“audio&#x2F;x-vorbis”。源 pad 将用于将原始（解码）音频样本发送到下一个元素，其原始音频媒体类型（在本例中为“audio&#x2F;x-raw”）。源 pad 还将包含音频采样率和通道数量的属性，以及一些您现在无需担心的属性。</p>
<h3 id="使用什么-capabilities"><a href="#使用什么-capabilities" class="headerlink" title="使用什么 capabilities"></a>使用什么 capabilities</h3><p>capabilities（简称：caps）描述在两个 pad 之间传输的数据类型，或者一个 pad（模板）支持的数据类型。这使得它们对于各种目的非常有用：</p>
<ul>
<li><p>Autoplugging：根据其功能自动查找要链接到 pad 的元素。所有自动插入器都使用此方法。</p>
</li>
<li><p>Compatibility detection：当两个 pad 连接时，GStreamer 可以验证两个 pad 是否正在谈论相同的媒体类型。连接两个 pad 并检查它们是否兼容的过程称为“上限协商”。</p>
</li>
<li><p>Metadata：通过读取 pad 的功能，应用程序可以提供有关通过 pad 传输的媒体类型的信息，即有关当前正在播放的流的信息。</p>
</li>
<li><p>Filtering：应用程序可以使用功能将两个 pad 之间流式传输的可能媒体类型限制为其支持的流类型的特定子集。例如，应用程序可以使用“过滤上限”来设置应在两个 pad 之间流式传输的特定（固定或非固定）视频大小。您将在本手册后面的“手动向管道添加或删除数据”中看到过滤上限的示例。您可以通过将 capsfilter 元素插入管道并设置其“caps”属性来进行 caps 过滤。 Caps 过滤器通常放置在 audioconvert、audioresample、videoconvert 或 videoscale 等转换器元素之后，以强制这些转换器在流中的某个点将数据转换为特定的输出格式。</p>
</li>
</ul>
<h3 id="Using-capabilities-for-metadata"><a href="#Using-capabilities-for-metadata" class="headerlink" title="Using capabilities for metadata"></a>Using capabilities for metadata</h3><p>垫可以附加一组（即一个或多个）功能。功能 ( <code>GstCaps</code> ) 表示为一个或多个 <code>GstStructure</code> 的数组，每个 <code>GstStructure</code> 是一个字段数组，其中每个字段由一个字段名称组成字符串（例如“width”）和键入的值（例如 <code>G_TYPE_INT</code> 或 <code>GST_TYPE_INT_RANGE</code> ）。</p>
<p>请注意，pad 的可能功能（即，通常您发现的 pad 模板的上限，如 gst-inspect 中所示）、pad 允许的上限（可以与 pad 的上限相同）之间存在明显差异。模板上限或其子集，具体取决于对等 pad 的可能上限）和最后协商的上限（这些描述了流或缓冲区的确切格式，并且仅包含一个结构，并且没有像范围或列表之类的可变位，即。它们是固定 caps）。</p>
<p>您可以通过查询一个结构的各个属性来获取一组功能中的属性值。您可以使用 <code>gst_caps_get_structure ()</code> 从大写中获取结构，并使用 <code>gst_caps_get_size ()</code> 获取 <code>GstCaps</code> 中的结构数量。</p>
<p>当 Caps 仅包含一种结构时，称为 <em>simple caps</em> ；当 Caps 仅包含一种结构且没有可变字段类型（如可能值的范围或列表）时，称为 <em>fixed caps</em> 。另外两种特殊类型的 caps 是 ANY caps 和 empty caps。</p>
<p>以下是如何从一组固定视频上限中提取宽度和高度的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_video_props</span> <span class="params">(GstCaps *caps)</span></span><br><span class="line">&#123;</span><br><span class="line">    gint width, height;</span><br><span class="line">    <span class="type">const</span> GstStructure *str;</span><br><span class="line"></span><br><span class="line">    g_return_if_fail (gst_caps_is_fixed (caps));</span><br><span class="line"></span><br><span class="line">    str = gst_caps_get_structure (caps, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!gst_structure_get_int (str, <span class="string">&quot;width&quot;</span>, &amp;width) ||</span><br><span class="line">        !gst_structure_get_int (str, <span class="string">&quot;height&quot;</span>, &amp;height)) &#123;</span><br><span class="line">        g_print (<span class="string">&quot;No width/height available\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_print (<span class="string">&quot;The video size of this set of capabilities is %dx%d\n&quot;</span>,</span><br><span class="line">             width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Creating-capabilities-for-filtering"><a href="#Creating-capabilities-for-filtering" class="headerlink" title="Creating capabilities for filtering"></a>Creating capabilities for filtering</h3><p>虽然功能主要在插件内部用于描述 pad 的媒体类型，但应用程序程序员通常还必须对功能有基本的了解，以便与插件交互，尤其是在使用 filtered caps 时。当您使用 filtered caps 或 fixation 时，您将允许在两个 pad 之间传输的媒体类型限制为其支持的媒体类型的子集。您可以使用管道中的 <code>capsfilter</code> 元素来执行此操作。为此，您还需要创建自己的 <code>GstCaps</code> 。最简单的方法是使用函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> gboolean</span><br><span class="line">    <span class="title function_">link_elements_with_filter</span> <span class="params">(GstElement *element1, GstElement *element2)</span></span><br><span class="line">&#123;</span><br><span class="line">    gboolean link_ok;</span><br><span class="line">    GstCaps *caps;</span><br><span class="line"></span><br><span class="line">    caps = gst_caps_new_simple (<span class="string">&quot;video/x-raw&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;format&quot;</span>, G_TYPE_STRING, <span class="string">&quot;I420&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;width&quot;</span>, G_TYPE_INT, <span class="number">384</span>,</span><br><span class="line">                                <span class="string">&quot;height&quot;</span>, G_TYPE_INT, <span class="number">288</span>,</span><br><span class="line">                                <span class="string">&quot;framerate&quot;</span>, GST_TYPE_FRACTION, <span class="number">25</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    link_ok = gst_element_link_filtered (element1, element2, caps);</span><br><span class="line">    gst_caps_unref (caps);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!link_ok) &#123;</span><br><span class="line">        g_warning (<span class="string">&quot;Failed to link element1 and element2!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> link_ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将强制这两个元素之间的数据流达到特定的视频格式、宽度、高度和帧速率（或者，如果在所涉及的元素的上下文中无法实现链接将失败）。请记住，当您使用 <code>gst_element_link_filtered ()</code> 时，它会自动为您创建一个 <code>capsfilter</code> 元素，并将其插入到您要连接的两个元素之间的容器或管道中（如果您曾经想要断开这些元件的连接，因为这样您就必须将这两个元件与 capsfilter 断开连接）。</p>
<h2 id="Buffers-and-Events-缓冲区和事件"><a href="#Buffers-and-Events-缓冲区和事件" class="headerlink" title="Buffers and Events 缓冲区和事件"></a>Buffers and Events 缓冲区和事件</h2><p>流经管道的数据由缓冲区和事件的组合组成。缓冲区包含实际的媒体数据。事件包含控制信息，例如寻找信息和流结束通知程序。所有这些都会在管道运行时自动流过。本章主要是为了向您解释这个概念；您不需要为此做任何事情。</p>
<h3 id="Buffers-缓冲器"><a href="#Buffers-缓冲器" class="headerlink" title="Buffers 缓冲器"></a>Buffers 缓冲器</h3><p>缓冲区包含将流经您创建的管道的数据。源元素通常会创建一个新的缓冲区，并将其通过 pad 传递到链中的下一个元素。当使用 GStreamer 基础设施创建媒体管道时，您不必自己处理缓冲区；这些元素会为你做到这一点。</p>
<p>除其他外，缓冲区还包括：</p>
<ul>
<li><p>指向内存对象的指针。内存对象封装了内存中的一个区域。</p>
</li>
<li><p>缓冲区的时间戳。</p>
</li>
<li><p>指示有多少元素正在使用此缓冲区的引用计数。当没有元素引用缓冲区时，该引用计数将用于销毁缓冲区。</p>
</li>
<li><p>缓冲区标志。</p>
</li>
</ul>
<p>简单的情况是创建一个缓冲区，分配内存，将数据放入其中，然后传递到下一个元素。该元素读取数据，执行某些操作（例如创建新缓冲区并对其进行解码），然后取消引用该缓冲区。这会导致数据被释放并且缓冲区被破坏。典型的视频或音频解码器的工作原理如下。</p>
<p>不过，还有更复杂的场景。元素可以就地修改缓冲区，即无需分配新缓冲区。元素还可以写入硬件内存（例如来自视频捕获源）或从 X 服务器分配的内存（使用 XShm）。缓冲区可以是只读的，等等。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yuanmxc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/02/GSteamer%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2024/06/02/GSteamer%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">陌上尘归处</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p12.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/05/22/RSTP%E3%80%81RTP%E3%80%81RTCP%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="随笔-24/3/25"><img class="cover" src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">随笔-24/3/25</div></div><div class="info-2"><div class="info-item-1">RSTP、RTP、RTCPRTSP RTP RTCPRTP(Real-time Transport Protocol)，即实时传输协议，是一个应用层的协议，定义了在网络上传输音频和视频的标准数据包的格式。通常说的 RTSP 包括 RTSP 协议、RTP 协议、RTCP 协议，对于这些协议的作用简单的理解如下：  RTSP协议：负责服务器与客户端之间的请求与响应   一般RTSP服务器会从设备（如摄像头）中获取媒体流，并提供一个 RTSP URL 供客户端进行连接，客户端通过 RTSP URL 向服务器发起连接请求，服务器响应，两者开始交换数据，最后建立连接。  RTP协议：负责服务器与客户端之间传输媒体数据   RTP 的端口号通常为偶数，在连接建立后，客户端请求媒体数据，之后服务器通过将媒体流封装为 RTP 包发送给客户端。通常 RTP 的端口为偶数。可以使用 TCP 或者 UDP，一般使用 UDP 并使用 RTCP 协议保证流媒体音视频质量。仅仅是发包。  RTCP 协议：负责提供有关RTP传输质量的反馈，就是确保RTP传输的质量   RTCP 的端口号通肠为对应的 RTP...</div></div></div></a><a class="pagination-related" href="/2024/06/05/GStreamer%20%E6%95%99%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="GStreamer 示例代码学习记录"><img class="cover" src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p41.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">GStreamer 示例代码学习记录</div></div><div class="info-2"><div class="info-item-1">GStreamer 示例代码学习记录前言本文是笔者阅读 GStreamer 官方文档中的基础教程和播放教程去学习 GStreamer 时的记录，大部分内容可以在 GStreamer 官方文档中找到。 笔者学习 GStreamer 的主要目的是：使用 GStreamer 处理从 TCP Socket 接收到的 H.265 裸流（使用 live555 的 testRTSPclient 程序从 RTSP URL 中获取到），将其解码并保存为 jpeg 图片。 部分教程与目的关系不大，为涉及到。笔者最终放弃使用 GStreamer 的想法，使用 FFmpeg 完成了上述目的。 基础教程1：媒体流从 source 元素到 sink 元素，中间通过一系列中间元素比如 filter过滤器元素，所有这些的集合称为 pipeline。管道是一种特殊类型的 bin，也是用于包含其他元素的元素。因此，适用于 bin 的所有方法也适用于管道。pipeline 的状态为 GST_STATE_PLAYING 时播放流经的音&#x2F;视频。 playbin...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/other/touxiang2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yuanmxc</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Yuanmxc"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Yuanmxc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">不乱于心，不困于情。不畏将来，不念过往。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GSteamer-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">GSteamer 学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Elements-%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.</span> <span class="toc-text">Elements 元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Filters-convertors-demuxers-muxers-and-codecs-%E6%BB%A4%E6%B3%A2%E5%99%A8%E3%80%81%E8%BD%AC%E6%8D%A2%E5%99%A8%E3%80%81%E8%A7%A3%E5%A4%8D%E7%94%A8%E5%99%A8%E3%80%81%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">Filters, convertors, demuxers, muxers and codecs  滤波器、转换器、解复用器、多路复用器和编解码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sink-elements-%E6%8E%A5%E6%94%B6%E5%99%A8%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.2.</span> <span class="toc-text">Sink elements 接收器元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Creating-a-GstElement-%E5%88%9B%E5%BB%BA-GstElement"><span class="toc-number">1.2.3.</span> <span class="toc-text">Creating a GstElement 创建 GstElement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%83%E7%B4%A0%E4%BD%9C%E4%B8%BA-GObject"><span class="toc-number">1.2.4.</span> <span class="toc-text">使用元素作为 GObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E5%85%83%E4%BB%B6%E5%B7%A5%E5%8E%82%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.5.</span> <span class="toc-text">有关元件工厂的更多信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E8%8E%B7%E5%8F%96%E6%9C%89%E5%85%B3%E5%85%83%E7%B4%A0%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.6.</span> <span class="toc-text">使用工厂获取有关元素的信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E5%85%83%E7%B4%A0%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B-pad"><span class="toc-number">1.2.7.</span> <span class="toc-text">找出元素可以包含哪些 pad</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.8.</span> <span class="toc-text">链接元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.9.</span> <span class="toc-text">元素状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bins-%E7%AE%B1"><span class="toc-number">1.3.</span> <span class="toc-text">Bins 箱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Creating-a-bin"><span class="toc-number">1.3.1.</span> <span class="toc-text">Creating a bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bin-%E7%AE%A1%E7%90%86%E5%85%B6%E5%AD%90%E9%A1%B9%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.2.</span> <span class="toc-text">Bin 管理其子项的状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bus-%E6%80%BB%E7%BA%BF"><span class="toc-number">1.4.</span> <span class="toc-text">Bus 总线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">消息类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pads-%E5%92%8C-capabilities"><span class="toc-number">1.5.</span> <span class="toc-text">Pads 和 capabilities</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pads"><span class="toc-number">1.5.1.</span> <span class="toc-text">Pads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic-or-sometimes-pads"><span class="toc-number">1.5.2.</span> <span class="toc-text">Dynamic (or sometimes) pads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Request-pads"><span class="toc-number">1.5.3.</span> <span class="toc-text">Request pads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Capabilities-of-a-pad"><span class="toc-number">1.5.4.</span> <span class="toc-text">Capabilities of a pad</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dissecting-capabilities-%E8%A7%A3%E5%89%96%E8%83%BD%E5%8A%9B"><span class="toc-number">1.5.5.</span> <span class="toc-text">Dissecting capabilities 解剖能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88-capabilities"><span class="toc-number">1.5.6.</span> <span class="toc-text">使用什么 capabilities</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-capabilities-for-metadata"><span class="toc-number">1.5.7.</span> <span class="toc-text">Using capabilities for metadata</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Creating-capabilities-for-filtering"><span class="toc-number">1.5.8.</span> <span class="toc-text">Creating capabilities for filtering</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buffers-and-Events-%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.6.</span> <span class="toc-text">Buffers and Events 缓冲区和事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffers-%E7%BC%93%E5%86%B2%E5%99%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">Buffers 缓冲器</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/10/ArchLinux%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E5%B0%8F%E7%82%B9%E6%9D%82%E8%AE%B0%20%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/" title="ArchLinux 使用记录"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p43.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ArchLinux 使用记录"/></a><div class="content"><a class="title" href="/2025/01/10/ArchLinux%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E5%B0%8F%E7%82%B9%E6%9D%82%E8%AE%B0%20%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/" title="ArchLinux 使用记录">ArchLinux 使用记录</a><time datetime="2025-01-10T07:39:14.000Z" title="发表于 2025-01-10 15:39:14">2025-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/06/%E5%B0%86%20Python%20%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/" title="将 Python 程序打包为可执行文件（Windows &amp; Linux）"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p26.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="将 Python 程序打包为可执行文件（Windows &amp; Linux）"/></a><div class="content"><a class="title" href="/2025/01/06/%E5%B0%86%20Python%20%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/" title="将 Python 程序打包为可执行文件（Windows &amp; Linux）">将 Python 程序打包为可执行文件（Windows &amp; Linux）</a><time datetime="2025-01-06T08:36:14.000Z" title="发表于 2025-01-06 16:36:14">2025-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/06/Arch%20Linux%20%E4%B8%BA%20AppImage%20%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%99%A8%E5%85%A5%E5%8F%A3/" title="将 Python 程序打包为可执行文件（Windows &amp; Linux）"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="将 Python 程序打包为可执行文件（Windows &amp; Linux）"/></a><div class="content"><a class="title" href="/2024/11/06/Arch%20Linux%20%E4%B8%BA%20AppImage%20%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%99%A8%E5%85%A5%E5%8F%A3/" title="将 Python 程序打包为可执行文件（Windows &amp; Linux）">将 Python 程序打包为可执行文件（Windows &amp; Linux）</a><time datetime="2024-11-06T07:04:01.000Z" title="发表于 2024-11-06 15:04:01">2024-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/13/Arch%20Linux%20%E5%AE%89%E8%A3%85%20openpose%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Arch Linux 安装 openpose 踩坑记录"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p29.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Arch Linux 安装 openpose 踩坑记录"/></a><div class="content"><a class="title" href="/2024/07/13/Arch%20Linux%20%E5%AE%89%E8%A3%85%20openpose%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Arch Linux 安装 openpose 踩坑记录">Arch Linux 安装 openpose 踩坑记录</a><time datetime="2024-07-13T06:18:36.000Z" title="发表于 2024-07-13 14:18:36">2024-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/05/Arch%20Linux%20%E5%AE%89%E8%A3%85%20CUDA%20%E3%80%81TensorRT%20%20%E5%92%8C%20TensorRT-YOLO%20%E8%AE%B0%E5%BD%95/" title="Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p31.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录"/></a><div class="content"><a class="title" href="/2024/07/05/Arch%20Linux%20%E5%AE%89%E8%A3%85%20CUDA%20%E3%80%81TensorRT%20%20%E5%92%8C%20TensorRT-YOLO%20%E8%AE%B0%E5%BD%95/" title="Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录">Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录</a><time datetime="2024-07-05T02:25:58.000Z" title="发表于 2024-07-05 10:25:58">2024-07-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p12.png);"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By Yuanmxc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">不乱于心，不困于情。不畏将来，不念过往。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>