<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>GStreamer 示例代码学习记录 | 陌上尘归处</title><meta name="author" content="Yuanmxc"><meta name="copyright" content="Yuanmxc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="GStreamer 示例代码学习记录前言本文是笔者阅读 GStreamer 官方文档中的基础教程和播放教程去学习 GStreamer 时的记录，大部分内容可以在 GStreamer 官方文档中找到。 笔者学习 GStreamer 的主要目的是：使用 GStreamer 处理从 TCP Socket 接收到的 H.265 裸流（使用 live555 的 testRTSPclient 程序从 RTSP">
<meta property="og:type" content="article">
<meta property="og:title" content="GStreamer 示例代码学习记录">
<meta property="og:url" content="http://example.com/2024/06/05/GStreamer%20%E6%95%99%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="陌上尘归处">
<meta property="og:description" content="GStreamer 示例代码学习记录前言本文是笔者阅读 GStreamer 官方文档中的基础教程和播放教程去学习 GStreamer 时的记录，大部分内容可以在 GStreamer 官方文档中找到。 笔者学习 GStreamer 的主要目的是：使用 GStreamer 处理从 TCP Socket 接收到的 H.265 裸流（使用 live555 的 testRTSPclient 程序从 RTSP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p41.png">
<meta property="article:published_time" content="2024-06-05T08:51:20.000Z">
<meta property="article:modified_time" content="2025-03-03T13:35:45.770Z">
<meta property="article:author" content="Yuanmxc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p41.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "GStreamer 示例代码学习记录",
  "url": "http://example.com/2024/06/05/GStreamer%20%E6%95%99%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/",
  "image": "https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p41.png",
  "datePublished": "2024-06-05T08:51:20.000Z",
  "dateModified": "2025-03-03T13:35:45.770Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yuanmxc",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/other/touxiang2.png"><link rel="canonical" href="http://example.com/2024/06/05/GStreamer%20%E6%95%99%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GStreamer 示例代码学习记录',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p2.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/other/touxiang2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p41.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/other/touxiang2.png" alt="Logo"><span class="site-name">陌上尘归处</span></a><a class="nav-page-title" href="/"><span class="site-name">GStreamer 示例代码学习记录</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">GStreamer 示例代码学习记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-05T08:51:20.000Z" title="发表于 2024-06-05 16:51:20">2024-06-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-03T13:35:45.770Z" title="更新于 2025-03-03 21:35:45">2025-03-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BE%85%E5%88%86%E7%B1%BB/">待分类</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="GStreamer-示例代码学习记录"><a href="#GStreamer-示例代码学习记录" class="headerlink" title="GStreamer 示例代码学习记录"></a>GStreamer 示例代码学习记录</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是笔者阅读 GStreamer 官方文档中的基础教程和播放教程去学习 GStreamer 时的记录，大部分内容可以在 GStreamer 官方文档中找到。</p>
<p>笔者学习 GStreamer 的主要目的是：使用 GStreamer 处理从 TCP Socket 接收到的 H.265 裸流（使用 live555 的 testRTSPclient 程序从 RTSP URL 中获取到），将其解码并保存为 jpeg 图片。</p>
<p>部分教程与目的关系不大，为涉及到。笔者最终放弃使用 GStreamer 的想法，使用 FFmpeg 完成了上述目的。</p>
<h2 id="基础教程1："><a href="#基础教程1：" class="headerlink" title="基础教程1："></a>基础教程1：</h2><p>媒体流从 source 元素到 sink 元素，中间通过一系列中间元素比如 filter过滤器元素，所有这些的集合称为 pipeline。管道是一种特殊类型的 bin，也是用于包含其他元素的元素。因此，适用于 bin 的所有方法也适用于管道。pipeline 的状态为 GST_STATE_PLAYING 时播放流经的音&#x2F;视频。</p>
<p>playbin 是一个特殊的元素，它既作为源又作为接收器，是一个完整的流水线。在内部，它创建并连接所有必要的元素来播放媒体，见下例，URI 作为唯一参数传递给playbin。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gst_init</span> (&amp;argc, &amp;argv); <span class="comment">// 初始化，必须是第一个GStreamer命令</span></span><br><span class="line"><span class="comment">// gst_parse_launch 采用管道的文本表示，并将其转换为实际的管</span></span><br><span class="line">pipeline = <span class="built_in">gst_parse_launch</span> (</span><br><span class="line">    <span class="string">&quot;playbin uri=https://gstreamer.freedesktop.org/data/media/sintel_trailer-480p.webm&quot;</span>, </span><br><span class="line">    <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 元素相关</span></span><br><span class="line"><span class="comment">// 可以使用gst_element_factory_make（）创建新元素。第一个参数是要创建的元素的类型，第二个参数是我们要给这个特定实例的名称。</span></span><br><span class="line">source = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;videotestsrc&quot;</span>, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">sink = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;autovideosink&quot;</span>, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总线和消息</span></span><br><span class="line"><span class="comment">// 从总线上获得消息msg，本例的调用将阻塞，直到通过该总线接收到ERROR或 EOS （End-Of-Stream）(参数所设置，可设置其他参数)</span></span><br><span class="line">GstBus *bus = <span class="built_in">gst_element_get_bus</span> (pipeline); <span class="comment">// 得到管道的总线</span></span><br><span class="line">GstMessage *msg =</span><br><span class="line">      <span class="built_in">gst_bus_timed_pop_filtered</span> (bus, GST_CLOCK_TIME_NONE,</span><br><span class="line">      GST_MESSAGE_ERROR | GST_MESSAGE_EOS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置某个元素的状态，每个元素只有一个关联的状态，</span></span><br><span class="line"><span class="built_in">gst_element_set_state</span> (pipeline, GST_STATE_PLAYING);</span><br><span class="line"><span class="keyword">if</span> (ret == GST_STATE_CHANGE_FAILURE) &#123;</span><br><span class="line">    <span class="built_in">g_printerr</span> (<span class="string">&quot;Unable to set the pipeline to the playing state.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">gst_object_unref</span> (pipeline);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理</span></span><br><span class="line"><span class="built_in">gst_message_unref</span> (msg); <span class="comment">//  上面获得的总线返回的消息必须由此释放</span></span><br><span class="line"><span class="built_in">gst_object_unref</span> (bus); <span class="comment">// 上面获得的总线必须由此释放</span></span><br><span class="line"><span class="built_in">gst_element_set_state</span> (pipeline, GST_STATE_NULL); <span class="comment">// 将管道设置为NULL状态将确保它释放它已分配的任何资源</span></span><br><span class="line"><span class="built_in">gst_object_unref</span> (pipeline); <span class="comment">// 上面获得的管道取消引用管道将销毁管道及其所有内容。</span></span><br></pre></td></tr></table></figure>

<h2 id="基础教程2"><a href="#基础教程2" class="headerlink" title="基础教程2:"></a>基础教程2:</h2><p>videotestsrc 是一个源元素（产生数据），它创建一个测试视频模式。此元素对于调试目的（和教程）很有用，通常在真实的应用程序中找不到。</p>
<p>autovideosink 是一个接收器元素（消耗数据），它在窗口上显示它接收的图像。根据操作系统的不同，存在几个具有不同功能范围的视频接收器。autovideosink 会自动选择并实例化最好的一个，因此不必担心细节，并且代码更加独立于平台。</p>
<p>管道：</p>
<p>GStreamer 中的所有元素通常必须包含在管道中才能使用，因为它负责一些时钟和消息传递功能。我们使用gst_pipeline_new（）创建管道。</p>
<p>属性：</p>
<p>GStreamer元素都是一种特殊的GObject，它是提供属性设施的实体。大多数 GStreamer 元素都具有可自定义的属性：命名属性，可以修改这些属性以更改元素的行为（可写属性），或者查询这些属性以了解元素的内部状态（可读属性）。</p>
<p>使用g_object_get（）读取属性，使用g_object_set（）写入属性。g_object_set() 接受以 NULL 结尾的属性名称、属性值对列表，因此可以一次性更改多个属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将元素添加到管道中（注意强制转换为bin类型）。此函数接受要添加的元素列表，以NULL结尾。可以使用gst_bin_add（）添加单个元素。</span></span><br><span class="line">GstElement *pipeline, *source, *sink;   <span class="comment">// 元素类型</span></span><br><span class="line">pipeline = <span class="built_in">gst_pipeline_new</span> (<span class="string">&quot;test-pipeline&quot;</span>); <span class="comment">// 创建管道</span></span><br><span class="line"><span class="built_in">gst_bin_add_many</span> (<span class="built_in">GST_BIN</span> (pipeline), source, sink, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// gst_element_link (source, sink)将管道中的元素连接起来，需要注意顺序，第一个参数是源，第二个参数是目的地。只有同一bin中的元素才能连接在一起。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">gst_element_link</span> (source, sink) != TRUE) &#123;</span><br><span class="line">    <span class="built_in">g_printerr</span> (<span class="string">&quot;Elements could not be linked.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">gst_object_unref</span> (pipeline);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更改了源的pattern属性，该属性控制元素输出的测试视频的类型。</span></span><br><span class="line"><span class="built_in">g_object_set</span> (source, <span class="string">&quot;pattern&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得总线，阻塞等待错误或者结尾消息，与教程1一样</span></span><br><span class="line">bus = <span class="built_in">gst_element_get_bus</span> (pipeline);</span><br><span class="line">msg =</span><br><span class="line">    <span class="built_in">gst_bus_timed_pop_filtered</span> (bus, GST_CLOCK_TIME_NONE,</span><br><span class="line">                                GST_MESSAGE_ERROR | GST_MESSAGE_EOS);</span><br><span class="line"><span class="comment">// 但这次简称msg可能的其他错误输出：</span></span><br><span class="line"><span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    GError *err;</span><br><span class="line">    gchar *debug_info;</span><br><span class="line"><span class="comment">// GST_MESSAGE_TYPE() 宏可以分析错误类型，gst_message_parse_error() 可以返回一个错误结构和一个对调试有用的字符串。</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">GST_MESSAGE_TYPE</span> (msg)) &#123;</span><br><span class="line">        <span class="keyword">case</span> GST_MESSAGE_ERROR:</span><br><span class="line">            <span class="built_in">gst_message_parse_error</span> (msg, &amp;err, &amp;debug_info);</span><br><span class="line">            <span class="built_in">g_printerr</span> (<span class="string">&quot;Error received from element %s: %s\n&quot;</span>,</span><br><span class="line">                        <span class="built_in">GST_OBJECT_NAME</span> (msg-&gt;src), err-&gt;message);</span><br><span class="line">            <span class="built_in">g_printerr</span> (<span class="string">&quot;Debugging information: %s\n&quot;</span>,</span><br><span class="line">                        debug_info ? debug_info : <span class="string">&quot;none&quot;</span>);</span><br><span class="line">            <span class="built_in">g_clear_error</span> (&amp;err);</span><br><span class="line">            <span class="built_in">g_free</span> (debug_info);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GST_MESSAGE_EOS:</span><br><span class="line">            <span class="built_in">g_print</span> (<span class="string">&quot;End-Of-Stream reached.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* We should not reach here because we only asked for ERRORs and EOS */</span></span><br><span class="line">            <span class="built_in">g_printerr</span> (<span class="string">&quot;Unexpected message received.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">gst_message_unref</span> (msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基础教程3动态管道"><a href="#基础教程3动态管道" class="headerlink" title="基础教程3动态管道"></a>基础教程3动态管道</h2><p>pad：GStreamer 元素相互通信的端口称为 pad ( <code>GstPad</code> )。存在 sink pad（数据通过其进入元素）和 source pad（数据通过其退出元素）。自然地，source 元素仅包含 source pad，sink 元素仅包含 sink pad，而 filter 元素包含两者。</p>
<p>多路分配器 demuxer 包含一个 sink pad（多路复用数据通过其到达）和多个 source pads（一个用于在容器中找到的每个流）：</p>
<p>demuxer 只有在收到视频流之后，收集到流的信息，才会创建自己的 source pad，因此，不能事先构建 demuxer 之后的连接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存在结构体中便于处理</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CustomData</span> &#123;</span><br><span class="line">  GstElement *pipeline;</span><br><span class="line">  GstElement *source;</span><br><span class="line">  GstElement *convert;</span><br><span class="line">  GstElement *resample;</span><br><span class="line">  GstElement *sink;</span><br><span class="line">&#125; CustomData;</span><br><span class="line"><span class="comment">/* Create the elements */</span></span><br><span class="line">data.source = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;uridecodebin&quot;</span>, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">data.convert = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;audioconvert&quot;</span>, <span class="string">&quot;convert&quot;</span>);</span><br><span class="line">data.resample = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;audioresample&quot;</span>, <span class="string">&quot;resample&quot;</span>);</span><br><span class="line">data.sink = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;autoaudiosink&quot;</span>, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line"><span class="comment">// 链接元素转换器、重采样和接收器，但我们不将它们与源链接，因为此时它不包含源焊盘。我们只是让这个分支（转换器+接收器）不链接，直到稍后。</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gst_element_link_many</span> (data.convert, data.resample, data.sink, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">  <span class="built_in">g_printerr</span> (<span class="string">&quot;Elements could not be linked.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">gst_object_unref</span> (data.pipeline);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过属性设置要播放的文件的 URI</span></span><br><span class="line"><span class="built_in">g_object_set</span> (data.source, <span class="string">&quot;uri&quot;</span>, <span class="string">&quot;https://gstreamer.freedesktop.org/data/media/sintel_trailer-480p.webm&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p> <code>uridecodebin</code> 将在内部实例化所有必要的元素（源、解复用器和解码器），以将 URI 转换为原始音频和&#x2F;或视频流。它完成了 <code>playbin</code> 一半的工作。由于它包含解复用器，因此它的源焊盘最初不可用，我们需要动态链接到它们。</p>
<p><code>audioconvert</code> 对于在不同音频格式之间进行转换非常有用，确保此示例可以在任何平台上运行，因为音频解码器生成的格式可能与音频接收器期望的格式不同。</p>
<p><code>audioresample</code> 对于在不同音频采样率之间进行转换非常有用，同样确保此示例适用于任何平台，因为音频解码器产生的音频采样率可能不是音频接收器支持的采样率。</p>
<p><code>autoaudiosink</code> 相当于上一教程中的 <code>autovideosink</code> 。它将音频流渲染到声卡。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加给源（uridecodebin 元素）一个“pad-added”信号，第三个参数提供回调函数，第四个参数是数据指针（CustomData 结构的指针），对数据指针不执行任何操作，只是转发到回调函数便于共享信息。</span></span><br><span class="line"><span class="built_in">g_signal_connect</span> (data.source, <span class="string">&quot;pad-added&quot;</span>, <span class="built_in">G_CALLBACK</span> (pad_added_handler), &amp;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调：src 是触发信号的 GstElement，本例只能是uridecodebin，因为它是我们附加的唯一信号。信号处理程序的第一个参数始终是触发它的对象。</span></span><br><span class="line"><span class="comment">// new_pad 是刚刚添加到 src 元素的 GstPad 。这通常是我们想要链接的pad。</span></span><br><span class="line"><span class="comment">// data 是上面提到的数据指针。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">pad_added_handler</span> <span class="params">(GstElement *src, GstPad *new_pad, CustomData *data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// gst_element_get_static_pad () 检索uridercodebin 的 sink pad，之前我们直接连接元素（实际上连接的pad，由 GStreamer 自己完成了），现在我们自己连接 pad</span></span><br><span class="line">    <span class="comment">// uridecodebin 可以创建任意数量的 pad，对于每一个 pad，都会调用此回调。一旦我们已经链接，下面的代码行将阻止我们尝试链接到新的 pad。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">gst_pad_is_linked</span> (sink_pad)) &#123;</span><br><span class="line">        <span class="built_in">g_print</span> (<span class="string">&quot;We are already linked. Ignoring.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得pad 当前输出的数据类型，存在 GstCaps 结构中。</span></span><br><span class="line">    new_pad_caps = <span class="built_in">gst_pad_get_current_caps</span> (new_pad, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 本例中我们想要的 pad 只有一个音频，使用下面的函数获得第一个 GstStructure</span></span><br><span class="line">    new_pad_struct = <span class="built_in">gst_caps_get_structure</span> (new_pad_caps, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 得到结构的名称，其中包含格式的主要描述（实际上是其媒体类型）</span></span><br><span class="line">    <span class="comment">// 如果名称不是 audio/x-raw ，则这不是解码的音频，忽略。    </span></span><br><span class="line">    new_pad_type = <span class="built_in">gst_structure_get_name</span> (new_pad_struct);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">g_str_has_prefix</span> (new_pad_type, <span class="string">&quot;audio/x-raw&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">g_print</span> (<span class="string">&quot;It has type &#x27;%s&#x27; which is not raw audio. Ignoring.\n&quot;</span>, new_pad_type);</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// gst_pad_link() 尝试链接两个 pad。必须指定从 source 到 sink 的链接，并且两个 pad 必须由驻留在同一容器（或管道）中的元素拥有。</span></span><br><span class="line">    ret = <span class="built_in">gst_pad_link</span> (new_pad, sink_pad);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GST_PAD_LINK_FAILED</span> (ret)) &#123;</span><br><span class="line">        <span class="built_in">g_print</span> (<span class="string">&quot;Type is &#x27;%s&#x27; but link failed.\n&quot;</span>, new_pad_type);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">g_print</span> (<span class="string">&quot;Link succeeded (type &#x27;%s&#x27;).\n&quot;</span>, new_pad_type);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="基础教程4"><a href="#基础教程4" class="headerlink" title="基础教程4"></a>基础教程4</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="built_in">gst_bus_timed_pop_filtered</span> (bus, <span class="number">100</span> * GST_MSECOND,</span><br><span class="line">    GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_ERROR | GST_MESSAGE_EOS | GST_MESSAGE_DURATION);</span><br></pre></td></tr></table></figure>

<p>从总线上获取消息的函数，这次加上超时，如果100毫秒没消息，返回 NULL，依次来更新终端显示。</p>
<p>事件用数字乘以 GST_MSECOND 等宏表示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">gst_element_query_position</span> (data.pipeline, GST_FORMAT_TIME, &amp;current)) &#123;</span><br><span class="line">  <span class="built_in">g_printerr</span> (<span class="string">&quot;Could not query current position.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">GST_CLOCK_TIME_IS_VALID</span> (data.duration)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">gst_element_query_duration</span> (data.pipeline, GST_FORMAT_TIME, &amp;data.duration)) &#123;</span><br><span class="line">     <span class="built_in">g_printerr</span> (<span class="string">&quot;Could not query current duration.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gst_element_query_position()</code> 隐藏了查询对象的管理，直接为我们提供结果。直接获得当前流的播放的位置。</p>
<p> <code>gst_element_query_duration()</code>函数获得流的总长度。</p>
<p> <code>GST_TIME_FORMAT</code> 和 <code>GST_TIME_ARGS</code> 宏的使用提供用户友好的 GStreamer 时间表示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data.seek_enabled &amp;&amp; !data.seek_done &amp;&amp; current &gt; <span class="number">10</span> * GST_SECOND) &#123;</span><br><span class="line">  <span class="built_in">g_print</span> (<span class="string">&quot;\nReached 10s, performing seek...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">gst_element_seek_simple</span> (data.pipeline, GST_FORMAT_TIME,</span><br><span class="line">      GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, <span class="number">30</span> * GST_SECOND);</span><br><span class="line">  data.seek_done = TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>gst_element_seek_simple()</code> 来“简单地”执行查找。第二个参数表示以时间为单位指定目的地。</p>
<p>第三个参数是<code>GstSeekFlags</code>，本例中的两个选项：</p>
<p><code>GST_SEEK_FLAG_FLUSH</code> ：这会在执行查找之前丢弃当前管道中的所有数据。当管道重新填充并且新数据开始显示时可能会暂停一点，但会大大提高应用程序的“响应能力”。如果未提供此标志，则“陈旧”数据可能会显示一段时间，直到新位置出现在管道末尾。</p>
<p><code>GST_SEEK_FLAG_KEY_UNIT</code> ：对于大多数编码视频流，不可能寻找任意位置，而只能寻找称为关键帧的某些帧。使用此标志时，搜索实际上会移动到最近的关键帧并立即开始生成数据。如果不使用此标志，管道将在内部移动到最近的关键帧（它没有其他选择），但数据在到达请求的位置之前不会显示。最后一种选择更准确，但可能需要更长的时间。</p>
<p>第四个参数提供搜索位置，本例是30秒，即跳转到30秒处继续播放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> GST_MESSAGE_DURATION:</span><br><span class="line"><span class="comment">/* The duration has changed, mark the current one as invalid */</span></span><br><span class="line">data-&gt;duration = GST_CLOCK_TIME_NONE;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>消息类型为<code>GST_MESSAGE_DURATION</code>时，每当流的总长度发生变化时，该消息就会发布到总线上。这里我们只是将总长度（时间）标记为无效，以便稍后重新查询。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> GST_MESSAGE_STATE_CHANGED: &#123;</span><br><span class="line">    GstState old_state, new_state, pending_state;</span><br><span class="line">    <span class="built_in">gst_message_parse_state_changed</span> (msg, &amp;old_state, &amp;new_state, &amp;pending_state);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GST_MESSAGE_SRC</span> (msg) == <span class="built_in">GST_OBJECT</span> (data-&gt;pipeline)) &#123;</span><br><span class="line">        <span class="built_in">g_print</span> (<span class="string">&quot;Pipeline state changed from %s to %s:\n&quot;</span>,</span><br><span class="line">                 <span class="built_in">gst_element_state_get_name</span> (old_state), <span class="built_in">gst_element_state_get_name</span> (new_state));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remember whether we are in the PLAYING state or not */</span></span><br><span class="line">        data-&gt;playing = (new_state == GST_STATE_PLAYING);</span><br></pre></td></tr></table></figure>

<p>消息类型为<code>GST_MESSAGE_STATE_CHANGED</code>时打印流的前后状态，搜索和时间查询通常仅在处于 <code>PAUSED</code> 或 <code>PLAYING</code> 状态时才能获得有效答复，因为所有元素都有机会接收信息并配置自身。在这里，我们使用 <code>playing</code> 变量来跟踪管道是否处于 <code>PLAYING</code> 状态。另外，如果我们刚刚进入 <code>PLAYING</code> 状态，我们将执行第一个查询。我们询问管道是否允许在此流上查找：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data-&gt;playing) &#123;</span><br><span class="line">    <span class="comment">/* We just moved to PLAYING. Check if seeking is possible */</span></span><br><span class="line">    GstQuery *query;</span><br><span class="line">    gint64 start, end;</span><br><span class="line">    query = <span class="built_in">gst_query_new_seeking</span> (GST_FORMAT_TIME);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">gst_element_query</span> (data-&gt;pipeline, query)) &#123;</span><br><span class="line">        <span class="built_in">gst_query_parse_seeking</span> (query, <span class="literal">NULL</span>, &amp;data-&gt;seek_enabled, &amp;start, &amp;end);</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;seek_enabled) &#123;</span><br><span class="line">            <span class="built_in">g_print</span> (<span class="string">&quot;Seeking is ENABLED from %&quot;</span> GST_TIME_FORMAT <span class="string">&quot; to %&quot;</span> GST_TIME_FORMAT <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                     <span class="built_in">GST_TIME_ARGS</span> (start), <span class="built_in">GST_TIME_ARGS</span> (end));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">g_print</span> (<span class="string">&quot;Seeking is DISABLED for this stream.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">g_printerr</span> (<span class="string">&quot;Seeking query failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">gst_query_unref</span> (query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gst_query_new_seeking()</code> 创建一个“寻求”类型的新查询对象，格式为 <code>GST_FORMAT_TIME</code> 。这表明我们有兴趣通过指定我们想要移动到的新时间来进行搜索。我们还可以请求 <code>GST_FORMAT_BYTES</code> ，然后查找源文件内的特定字节位置，但这通常不太有用。<br>然后，该查询对象通过 <code>gst_element_query()</code> 传递到管道。结果存储在同一查询中，并且可以使用 <code>gst_query_parse_seeking()</code> 轻松检索。它提取一个布尔值，指示是否允许查找以及可以查找的范围。</p>
<h2 id="基础教程6"><a href="#基础教程6" class="headerlink" title="基础教程6"></a>基础教程6</h2><p>Pad 允许信息进入和离开元素，Pad 可以指定 Pad 传输的信息类型，比如“分辨率为 320x200 像素、每秒 30 帧的 RGB 视频”，可以支持多种功能。从 Pad 到 Pad 传输的实际信息必须只有一种明确指定的类型。通过”协商“，两个链接的 Pad 就通用类型达成一致，因此 Pad 的功能变得固定（它们只有一种类型且不包含范围）。</p>
<p>为了将两个元素连接在一起，他们必须有一个公共的功能子集。</p>
<p>Pad 是根据 Pad 模板创建的，该模板指示 Pad 可能具有的所有可能功能。模板可用于创建多个相似的 Pad，并且还允许提前拒绝元素之间的连接：如果其 Pad 模板的功能没有公共子集（它们的交集为空），则无需进一步协商。Pad 模板可以被视为谈判过程的第一步。随着流程的发展，实际的 Pad 会被实例化，其功能也会得到完善，直到它们被修复（或协商失败）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Shows the CURRENT capabilities of the requested pad in the given element */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print_pad_capabilities</span> <span class="params">(GstElement *element, gchar *pad_name)</span> </span>&#123;</span><br><span class="line">    GstPad *pad = <span class="literal">NULL</span>;</span><br><span class="line">    GstCaps *caps = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Retrieve pad */</span></span><br><span class="line">   <span class="comment">// 从给定元素中获得指定的 Pad。此 Pad 是静态的，因为它始终存在于元素中。</span></span><br><span class="line">    pad = <span class="built_in">gst_element_get_static_pad</span> (element, pad_name);</span><br><span class="line">    <span class="keyword">if</span> (!pad) &#123;</span><br><span class="line">        <span class="built_in">g_printerr</span> (<span class="string">&quot;Could not retrieve pad &#x27;%s&#x27;\n&quot;</span>, pad_name);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Retrieve negotiated caps (or acceptable caps if negotiation is not finished yet) */</span></span><br><span class="line">    <span class="comment">// 获得 Pad 的当前 Capability，可能有可能无，可能固定可能不固定</span></span><br><span class="line">    caps = <span class="built_in">gst_pad_get_current_caps</span> (pad);</span><br><span class="line">    <span class="keyword">if</span> (!caps)</span><br><span class="line">        <span class="comment">//  获得当前可接受的 Pad 功能</span></span><br><span class="line">        caps = <span class="built_in">gst_pad_query_caps</span> (pad, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Print and free */</span></span><br><span class="line">    <span class="comment">// 打印并释放</span></span><br><span class="line">    <span class="built_in">g_print</span> (<span class="string">&quot;Caps for the %s pad:\n&quot;</span>, pad_name);</span><br><span class="line">    <span class="built_in">print_caps</span> (caps, <span class="string">&quot;      &quot;</span>);</span><br><span class="line">    <span class="built_in">gst_caps_unref</span> (caps);</span><br><span class="line">    <span class="built_in">gst_object_unref</span> (pad);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建元素工厂 */</span></span><br><span class="line">source_factory = <span class="built_in">gst_element_factory_find</span> (<span class="string">&quot;audiotestsrc&quot;</span>);</span><br><span class="line">sink_factory = <span class="built_in">gst_element_factory_find</span> (<span class="string">&quot;autoaudiosink&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!source_factory || !sink_factory) &#123;</span><br><span class="line">  <span class="built_in">g_printerr</span> (<span class="string">&quot;Not all element factories could be created.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印工厂的 Pad 信息 */</span></span><br><span class="line"><span class="built_in">print_pad_templates_information</span> (source_factory);</span><br><span class="line"><span class="built_in">print_pad_templates_information</span> (sink_factory);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 让工厂实例化实际的元素 */</span></span><br><span class="line">source = <span class="built_in">gst_element_factory_create</span> (source_factory, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">sink = <span class="built_in">gst_element_factory_create</span> (sink_factory, <span class="string">&quot;sink&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在之前的教程中，我们直接使用 <code>gst_element_factory_make()</code> 创建元素且没有谈论工厂，但现在我们用 <code>GstElementFactory</code> 负责实例化特定类型的元素，由其工厂名称标识。</p>
<p><code>gst_element_factory_find()</code> 创建类型为“videotestsrc”的工厂，然后使用它通过 <code>gst_element_factory_create()</code> 实例化多个“videotestsrc”元素。 <code>gst_element_factory_make()</code> 实际上是 <code>gst_element_factory_find()</code> + <code>gst_element_factory_create()</code> 的快捷方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> GST_MESSAGE_STATE_CHANGED:</span><br><span class="line"><span class="comment">/* We are only interested in state-changed messages from the pipeline */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GST_MESSAGE_SRC</span> (msg) == <span class="built_in">GST_OBJECT</span> (pipeline)) &#123;</span><br><span class="line">    GstState old_state, new_state, pending_state;</span><br><span class="line">    <span class="built_in">gst_message_parse_state_changed</span> (msg, &amp;old_state, &amp;new_state, &amp;pending_state);</span><br><span class="line">    <span class="built_in">g_print</span> (<span class="string">&quot;\nPipeline state changed from %s to %s:\n&quot;</span>,</span><br><span class="line">             <span class="built_in">gst_element_state_get_name</span> (old_state), <span class="built_in">gst_element_state_get_name</span> (new_state));</span><br><span class="line">    <span class="comment">/* Print the current capabilities of the sink element */</span></span><br><span class="line">    <span class="built_in">print_pad_capabilities</span> (sink, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>每次管道状态发生变化时，这都会简单地打印当前的 Pad Caps。您应该在输出中看到初始 Caps（Pad 模板的 Caps）如何逐渐细化，直到完全固定（它们包含没有范围的单一类型）。</p>
<h2 id="基础教程7-多线程和Pad可用性"><a href="#基础教程7-多线程和Pad可用性" class="headerlink" title="基础教程7:多线程和Pad可用性"></a>基础教程7:多线程和Pad可用性</h2><p>GStreamer 是一个多线程框架。这意味着，它在内部根据需要创建和销毁线程，例如，将流与应用程序线程解耦。此外，插件还可以自由创建线程用于自己的处理，例如，视频解码器可以创建 4 个线程以充分利用 4 核 CPU。</p>
<p>除此之外，在构建管道时，应用程序可以明确指定分支（管道的一部分）在不同的线程上运行（例如，让音频和视频解码器同时执行）。</p>
<p>这是使用 <code>queue</code> 元素完成的，其工作原理为：接收器 Pad 只是将数据排队并返回控制。在不同的线程上，数据出队并推送到下游。该元素还用于缓冲，如后面的流教程中所示。队列的大小可以通过属性来控制。</p>
<p>此示例构建以下管道：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407120920861.png" alt="image-20240712092033912"></p>
<p>source 是一个合成音频信号（连续音调），它使用 <code>tee</code> 元素进行分割（它把 sink pad 接收的所有内容用 source pad 发送出去）。然后，一个分支将信号发送到声卡，另一个分支渲染波形视频并将其发送到屏幕。</p>
<p>如图所示，队列创建一个新线程，因此该管道在 3 个线程中运行。具有多个接收器的管道通常需要多线程，因为为了同步，接收器通常会阻塞执行，直到所有其他接收器准备好为止，并且如果只有一个线程，则它们无法准备好，会被第一个接收器阻塞。</p>
<p>在基础教程 3：动态管道中，我们看到一个元素 ( <code>uridecodebin</code> ) 一开始就没有 pad，它们随着数据开始流动并且媒体流经元素而出现。这些称为 <strong>Sometimes Pads</strong>，与始终可用且称为 <strong>Always Pads</strong>的常规 pad 形成对比。</p>
<p>第三种 pad 是 Request Pad，它是按需创建的。典型的示例是 <code>tee</code> 元素，它有一个 sink pad 并且没有初始 source pad：需要请求它们，然后 <code>tee</code> 添加它们。通过这种方式，输入流可以被复制任意多次。缺点是使用 Request Pads 链接元素并不像链接 Always Pads 那样自动，如本示例的演练所示。</p>
<p>此外，要在 <code>PLAYING</code> 或 <code>PAUSED</code> 状态下请求（或释放）Pad，需要采取额外的注意事项（Pad 阻塞），本教程中未对此进行描述。不过，在 <code>NULL</code> 或 <code>READY</code> 状态下请求（或释放）pad 是安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建元素 */</span></span><br><span class="line"><span class="comment">// 都是直接使用gst_element_factory_make()，参数是类型和名称</span></span><br><span class="line">audio_source = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;audiotestsrc&quot;</span>, <span class="string">&quot;audio_source&quot;</span>);</span><br><span class="line">tee = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;tee&quot;</span>, <span class="string">&quot;tee&quot;</span>);</span><br><span class="line">audio_queue = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;queue&quot;</span>, <span class="string">&quot;audio_queue&quot;</span>);</span><br><span class="line">audio_convert = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;audioconvert&quot;</span>, <span class="string">&quot;audio_convert&quot;</span>);</span><br><span class="line">audio_resample = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;audioresample&quot;</span>, <span class="string">&quot;audio_resample&quot;</span>);</span><br><span class="line">audio_sink = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;autoaudiosink&quot;</span>, <span class="string">&quot;audio_sink&quot;</span>);</span><br><span class="line">video_queue = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;queue&quot;</span>, <span class="string">&quot;video_queue&quot;</span>);</span><br><span class="line">visual = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;wavescope&quot;</span>, <span class="string">&quot;visual&quot;</span>);</span><br><span class="line">video_convert = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;videoconvert&quot;</span>, <span class="string">&quot;video_convert&quot;</span>);</span><br><span class="line">video_sink = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;autovideosink&quot;</span>, <span class="string">&quot;video_sink&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>audiotestsrc</code> 产生合成音。 <code>wavescope</code> 消耗音频信号并呈现波形，就像它是一个示波器一样。我们已经使用过 <code>autoaudiosink</code> 和 <code>autovideosink</code> 。</p>
<p>转换元素（ <code>audioconvert</code> 、 <code>audioresample</code> 和 <code>videoconvert</code> ）对于保证管道可以链接是必需的。事实上，音频和视频接收器的功能取决于硬件，并且您在设计时不知道它们是否与 <code>audiotestsrc</code> 和 <code>wavescope</code> 生成的 Caps 匹配。不过，如果 Caps 匹配，这些元素将以“直通”模式运行，不会修改信号，对性能的影响可以忽略不计。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 配置元素 */</span></span><br><span class="line"><span class="built_in">g_object_set</span> (audio_source, <span class="string">&quot;freq&quot;</span>, <span class="number">215.0f</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">g_object_set</span> (visual, <span class="string">&quot;shader&quot;</span>, <span class="number">0</span>, <span class="string">&quot;style&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p><code>audiotestsrc</code> 的“freq”属性控制波的频率（215Hz 使波在窗口中看起来几乎静止）， <code>wavescope</code> 使波连续。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Link all elements that can be automatically linked because they have &quot;Always&quot; pads */</span></span><br><span class="line"><span class="comment">// 放在一个管道中</span></span><br><span class="line"><span class="built_in">gst_bin_add_many</span> (<span class="built_in">GST_BIN</span> (pipeline), audio_source, tee, audio_queue, audio_convert, audio_sink,</span><br><span class="line">                  video_queue, visual, video_convert, video_sink, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 连接所有可以自动连接的元素，如上图所示的三部分</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">gst_element_link_many</span> (audio_source, tee, <span class="literal">NULL</span>) != TRUE ||</span><br><span class="line">    <span class="built_in">gst_element_link_many</span> (audio_queue, audio_convert, audio_sink, <span class="literal">NULL</span>) != TRUE ||</span><br><span class="line">    <span class="built_in">gst_element_link_many</span> (video_queue, visual, video_convert, video_sink, <span class="literal">NULL</span>) != TRUE) &#123;</span><br><span class="line">    <span class="built_in">g_printerr</span> (<span class="string">&quot;Elements could not be linked.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">gst_object_unref</span> (pipeline);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码块将所有元素添加到管道中，然后链接可以自动链接的元素（带有 Always Pads 的元素）。</p>
<p><code>gst_element_link_many()</code> 实际上可以将元素与 Request Pads 链接起来。它在内部请求 Pad，因此不必担心链接的元素具有 Always 或者 Request Pads。这实际上很不方便，因为之后您仍然需要释放所请求的 Pad，而且，如果 Pad 是由<code>gst_element_link_many()</code> 自动请求的，会很容易忘记。始终手动请求 Request Pads ，以避免出现麻烦，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 手动连接具有 &quot;Request&quot; pads 的 tee 元素*/</span></span><br><span class="line"><span class="comment">// 用下面的函数请求 tee 的 source pad（Request pad），负责 audio</span></span><br><span class="line">tee_audio_pad = <span class="built_in">gst_element_request_pad_simple</span> (tee, <span class="string">&quot;src_%u&quot;</span>);</span><br><span class="line"><span class="built_in">g_print</span> (<span class="string">&quot;Obtained request pad %s for audio branch.\n&quot;</span>, <span class="built_in">gst_pad_get_name</span> (tee_audio_pad));</span><br><span class="line"><span class="comment">// 用下面的函数请求 tee 的 sink pad（Always Pad），负责 audio</span></span><br><span class="line">queue_audio_pad = <span class="built_in">gst_element_get_static_pad</span> (audio_queue, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line"><span class="comment">// 用下面的函数请求 tee 的 source pad（Request pad），负责 video</span></span><br><span class="line">tee_video_pad = <span class="built_in">gst_element_request_pad_simple</span> (tee, <span class="string">&quot;src_%u&quot;</span>);</span><br><span class="line"><span class="built_in">g_print</span> (<span class="string">&quot;Obtained request pad %s for video branch.\n&quot;</span>, <span class="built_in">gst_pad_get_name</span> (tee_video_pad));</span><br><span class="line"><span class="comment">// 用下面的函数请求 tee 的 sink pad（Always Pad），负责 video</span></span><br><span class="line">queue_video_pad = <span class="built_in">gst_element_get_static_pad</span> (video_queue, <span class="string">&quot;sink&quot;</span>)</span><br><span class="line"><span class="comment">// 连接</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">gst_pad_link</span> (tee_audio_pad, queue_audio_pad) != GST_PAD_LINK_OK ||</span><br><span class="line">    <span class="built_in">gst_pad_link</span> (tee_video_pad, queue_video_pad) != GST_PAD_LINK_OK) &#123;</span><br><span class="line">    <span class="built_in">g_printerr</span> (<span class="string">&quot;Tee could not be linked.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">gst_object_unref</span> (pipeline);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">gst_object_unref</span> (queue_audio_pad);</span><br><span class="line"><span class="built_in">gst_object_unref</span> (queue_video_pad);</span><br></pre></td></tr></table></figure>

<p>要链接 request pad，需要通过向元素“请求”它们来获取它们。一个元素可能能够生成不同类型的请求 pad，因此，在请求它们时，必须提供所需的 pad 模板名称。tee 有两个 pad 模板，分别为“sink”（用于其接收器 pad）和“src_%u”（用于Request pad）。我们使用<code>gst_element_request_pad_simple()</code>从 tee（用于音频和视频分支）请求两个 pad  。</p>
<p>然后，我们从这些请求 Pad 需要链接到的下游元素获取 Pad。这些是普通的 Always Pad，因此我们使用 <code>gst_element_get_static_pad()</code> 获取它们。</p>
<p>最后，我们将 pad 与 <code>gst_pad_link()</code> 链接起来。这是 <code>gst_element_link()</code> 和 <code>gst_element_link_many()</code> 内部使用的函数。</p>
<p>我们获得的sink Pad需要通过 <code>gst_object_unref()</code> 来释放。当我们不再需要它们时，在程序结束时，请求垫将被释放。</p>
<p>然后，我们将管道设置为正常播放，并等待生成错误消息或 EOS。剩下要做的唯一一件事就是清理请求的 Pad：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gst_element_release_request_pad</span> (tee, tee_audio_pad);</span><br><span class="line"><span class="built_in">gst_element_release_request_pad</span> (tee, tee_video_pad);</span><br><span class="line"><span class="built_in">gst_object_unref</span> (tee_audio_pad);</span><br><span class="line"><span class="built_in">gst_object_unref</span> (tee_video_pad);</span><br></pre></td></tr></table></figure>

<p><code>gst_element_release_request_pad()</code> 从 <code>tee</code> 释放 pad，但仍需要使用 <code>gst_object_unref()</code> 取消引用（释放）它。</p>
<h2 id="基础教程8：简化管道"><a href="#基础教程8：简化管道" class="headerlink" title="基础教程8：简化管道"></a>基础教程8：简化管道</h2><p>用于将应用程序数据注入 GStreamer 管道的元素是 <code>appsrc</code> ，其对应元素用于将 GStreamer 数据提取回应用程序是 <code>appsink</code> 。 <code>appsrc</code> 只是一个常规源，由应用程序提供数据（在GStreamer中视为<code>appsrc</code> 提供。 <code>appsink</code> 是一个常规接收器，流经 GStreamer 管道的数据将被消费（实际上由应用程序获得并使用）。</p>
<p><code>appsrc</code> 可以在多种模式下工作：在拉模式下，它每次需要时都会向应用程序请求数据。在推送模式下，应用程序按照自己的节奏推送数据。此外，在推送模式下，当已经提供了足够的数据时，应用程序可以选择在推送功能中阻塞，或者可以监听 <code>enough-data</code> 和 <code>need-data</code> 信号来控制流量。</p>
<p>数据以称为缓冲区（buffers）的块的形式通过 GStreamer 管道。类型是<code>GstBuffer</code>，Source Pad 产生缓冲区，由 Sink Pad 消耗； GStreamer 获取这些缓冲区并将它们从一个元素传递到另一个元素。</p>
<p>缓冲区仅表示一个数据单元，不要假设所有缓冲区都具有相同的大小，或表示相同的时间量。如果单个缓冲区进入一个元素，那么单个缓冲区也不一定会出来。元素可以随意处理接收到的缓冲区。 <code>GstBuffer</code> 也可能包含多个实际内存缓冲区。实际的内存缓冲区是使用 <code>GstMemory</code> 对象抽象出来的，一个 <code>GstBuffer</code> 可以包含多个 <code>GstMemory</code> 对象。</p>
<p>每个缓冲区都附加了时间戳和持续时间，描述了缓冲区内容应在哪个时刻被解码、渲染或显示。例如， <code>filesrc</code> （读取文件的 GStreamer 元素）生成具有“ANY”上限且没有时间戳信息的缓冲区。解复用后（请参阅基础教程 3：动态管道），缓冲区可以具有一些特定的上限，例如“video&#x2F;x-h264”。解码后，每个缓冲区将包含一个带有原始上限的视频帧（例如“video&#x2F;x-raw-yuv”）和非常精确的时间戳（指示何时应显示该帧）。</p>
<p>本教程以两种方式扩展了基础教程 7：多线程和 Pad 可用性：首先，将 <code>audiotestsrc</code> 替换为将生成音频数据的 <code>appsrc</code> 。其次，一个新分支被添加到 <code>tee</code> 中，因此进入音频接收器和波形显示的数据也被复制到 <code>appsink</code> 中。 <code>appsink</code> 将信息上传回应用程序，然后应用程序仅通知用户已收到数据，但它显然可以执行更复杂的任务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407121011878.png" alt="image-20240712101109001"></p>
<p>创建管道的代码是基础教程 7：多线程和 Pad 可用性的放大版本。它涉及实例化所有元素，将元素与Always Pads 链接，并手动链接 <code>tee</code> 元素的Request Pads。</p>
<p>关于 <code>appsrc</code> 和 <code>appsink</code> 元素的配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Configure appsrc */</span></span><br><span class="line"><span class="comment">// 构建一个 GstAudioInfo info，生成 audio_caps并设置到data.app_source</span></span><br><span class="line">gst_audio_info_set_format (&amp;info, GST_AUDIO_FORMAT_S16, SAMPLE_RATE, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">audio_caps = gst_audio_info_to_caps (&amp;info);</span><br><span class="line">g_object_set (data.app_source, <span class="string">&quot;caps&quot;</span>, audio_caps, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 连接信号，当源队列需要数据和数据足够时触发回调函数来启动/停止信号生成</span></span><br><span class="line">g_signal_connect (data.app_source, <span class="string">&quot;need-data&quot;</span>, G_CALLBACK (start_feed), &amp;data);</span><br><span class="line">g_signal_connect (data.app_source, <span class="string">&quot;enough-data&quot;</span>, G_CALLBACK (stop_feed), &amp;data);</span><br></pre></td></tr></table></figure>

<p>需要在 <code>appsrc</code> 上设置的第一个属性是 <code>caps</code> 。它指定元素将生成的数据类型，因此 GStreamer 可以检查是否可以与下游元素链接（即，下游元素是否能够理解此类数据）。此属性必须是 <code>GstCaps</code> 对象，可以使用 <code>gst_caps_from_string()</code> 轻松地从字符串构建该对象。</p>
<p>然后我们连接到 <code>need-data</code> 和 <code>enough-data</code> 信号。当 <code>appsrc</code> 的内部数据队列不足或几乎满时，它们会分别被触发。我们将使用这些信号来（分别）启动和停止我们的信号生成过程。</p>
<p>启动管道、等待消息和最终清理都像往常一样完成。让我们回顾一下我们刚刚注册的回调：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当 appsrc 需要数据时，触发下面的回调函数。主循环添加一个空闲处理程序以开始将数据推送到 appsrc</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">start_feed</span> <span class="params">(GstElement *source, guint size, CustomData *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data-&gt;sourceid == <span class="number">0</span>) &#123;</span><br><span class="line">        g_print (<span class="string">&quot;Start feeding\n&quot;</span>);</span><br><span class="line">        data-&gt;sourceid = g_idle_add ((GSourceFunc) push_data, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>appsrc</code> 的内部队列即将耗尽（数据耗尽）时调用此函数。我们在这里做的唯一一件事就是向 <code>g_idle_add()</code> 注册一个 GLib 空闲函数，该函数将数据提供给 <code>appsrc</code> 直到它再次填满。 GLib 空闲函数是 GLib 在“空闲”时（即没有更高优先级的任务要执行时）从其主循环调用的方法。显然，它需要一个 GLib <code>GMainLoop</code> 来实例化并运行。</p>
<p>这只是 <code>appsrc</code> 允许的多种方法之一。特别是，缓冲区不需要使用 GLib 从主线程输入 <code>appsrc</code> ，并且不需要使用 <code>need-data</code> 和 <code>enough-data</code> 信号来与 <code>appsrc</code> 同步（尽管据称这是最方便的）。</p>
<p>我们记下 <code>g_idle_add()</code> 返回的 sourceid，以便稍后禁用它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当 appsrc 有足够的数据时，此回调会触发，我们可以停止发送。</span></span><br><span class="line"><span class="comment">//我们从主循环中删除空闲处理程序</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stop_feed</span> <span class="params">(GstElement *source, CustomData *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data-&gt;sourceid != <span class="number">0</span>) &#123;</span><br><span class="line">        g_print (<span class="string">&quot;Stop feeding\n&quot;</span>);</span><br><span class="line">        g_source_remove (data-&gt;sourceid);</span><br><span class="line">        data-&gt;sourceid = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>appsrc</code> 的内部队列足够满时调用此函数，因此我们停止推送数据。这里我们简单地使用 <code>g_source_remove()</code> 删除空闲函数（空闲函数被实现为 <code>GSource</code> ）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此方法由主循环中的空闲 GSource 调用，将 CHUNK_SIZE 字节输入到 appsrc 中。</span></span><br><span class="line"><span class="comment">* 当 appsrc 请求我们开始发送数据（需要数据信号）时，ide 处理程序会添加到主循环中</span></span><br><span class="line"><span class="comment">* 并在 appsrc 有足够的数据（足够数据信号）时被删除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> gboolean <span class="title function_">push_data</span> <span class="params">(CustomData *data)</span> &#123;</span><br><span class="line">    GstBuffer *buffer;</span><br><span class="line">    GstFlowReturn ret;</span><br><span class="line">    GstMapInfo <span class="built_in">map</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    gint num_samples = CHUNK_SIZE / <span class="number">2</span>; <span class="comment">/* Because each sample is 16 bits */</span></span><br><span class="line">    gfloat freq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个新的空缓冲区，本例被设置为固定1024字节 */</span></span><br><span class="line">    buffer = gst_buffer_new_and_alloc (CHUNK_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set its timestamp and duration */</span></span><br><span class="line">    <span class="comment">// CustomData.num_samples 变量计算到目前为止生成的样本数量（即当前时间是多少）</span></span><br><span class="line">    <span class="comment">// 因此可以使用 GstBuffer 中的 GST_BUFFER_TIMESTAMP 宏对该缓冲区添加时间戳。</span></span><br><span class="line">    GST_BUFFER_TIMESTAMP (buffer) = gst_util_uint64_scale (data-&gt;num_samples, GST_SECOND, SAMPLE_RATE);</span><br><span class="line">    <span class="comment">// 由于我们生成相同大小的缓冲区，因此它们的持续时间相同</span></span><br><span class="line">    <span class="comment">// num_samples是缓冲区的样本数量，即16bits</span></span><br><span class="line">    <span class="comment">// 使用 GstBuffer 中的 GST_BUFFER_DURATION 设置缓冲区的持续总时间。</span></span><br><span class="line">    GST_BUFFER_DURATION (buffer) = gst_util_uint64_scale (num_samples, GST_SECOND, SAMPLE_RATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 产生一些迷幻波形，跳过 */</span></span><br><span class="line">    <span class="keyword">if</span> (gst_buffer_map (buf, &amp;<span class="built_in">map</span>, GST_MAP_READ)) &#123;</span><br><span class="line">        gint16 *raw = (gint16 *) <span class="built_in">map</span>.data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在此处创建样本 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 完成后取消映射缓冲区 */</span> </span><br><span class="line">        gst_buffer_unmap (buf, &amp;<span class="built_in">map</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这是提供 <code>appsrc</code> 的函数。 GLib 会以我们无法控制的时间和速率调用它，但我们知道，当它的工作完成时（当 <code>appsrc</code> 中的队列已满时），我们将禁用它。</p>
<p><code>gst_util_uint64_scale()</code> 是一个实用函数，可以缩放（乘法和除法）可能很大的数字，而不必担心溢出。</p>
<p>为了访问缓冲区的内存，您首先必须将其映射到 <code>gst_buffer_map()</code> ，这将为您提供 <code>GstMapInfo</code> 结构内的指针和大小，其中 <code>gst_buffer_map()</code> 将在成功时填充。请小心，不要写入超过缓冲区末尾的内容：您分配了它，因此您知道它的大小（以字节和样本为单位）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Push the buffer into the appsrc */</span></span><br><span class="line">g_signal_emit_by_name (data-&gt;app_source, <span class="string">&quot;push-buffer&quot;</span>, buffer, &amp;ret);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free the buffer now that we are done with it */</span></span><br><span class="line">gst_buffer_unref (buffer);</span><br></pre></td></tr></table></figure>

<p>请注意，还有 <code>gst_app_src_push_buffer()</code> 作为 <code>gstreamer-app-1.0</code> 库的一部分，与上面的信回调相比，它可能是一个更好的用于将缓冲区推送到 appsrc 的函数，因为它具有适当的键入签名，这样就很难出错。但是，请注意，如果您使用 <code>gst_app_src_push_buffer()</code> ，它将获得传递的缓冲区的所有权，因此在这种情况下，您不必在推送后取消引用它。</p>
<p>准备好缓冲区后，我们将其与 <code>push-buffer</code> 操作信号一起传递给 <code>appsrc</code> （请参阅播放教程 1：Playbin 用法末尾的信息框），然后 <code>gst_buffer_unref()</code> 因为我们不再需要它了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Configure appsink */</span></span><br><span class="line"><span class="comment">// 设置收到新缓冲区时的回调函数，当 sink 收到新缓冲区时调用，</span></span><br><span class="line">  g_object_set (data.app_sink, <span class="string">&quot;emit-signals&quot;</span>, TRUE, <span class="string">&quot;caps&quot;</span>, audio_caps, <span class="literal">NULL</span>);</span><br><span class="line">  g_signal_connect (data.app_sink, <span class="string">&quot;new-sample&quot;</span>, G_CALLBACK (new_sample),</span><br><span class="line">      &amp;data);</span><br><span class="line">  gst_caps_unref (audio_caps);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The appsink has received a buffer */</span></span><br><span class="line"><span class="type">static</span> GstFlowReturn <span class="title function_">new_sample</span> <span class="params">(GstElement *sink, CustomData *data)</span> &#123;</span><br><span class="line">    GstSample *sample;</span><br><span class="line">    <span class="comment">/* Retrieve the buffer */</span></span><br><span class="line">    <span class="comment">// 使用 pull-sample 操作信号来获得缓冲区 sample，这里仅仅打印提示符</span></span><br><span class="line">    g_signal_emit_by_name (sink, <span class="string">&quot;pull-sample&quot;</span>, &amp;sample);</span><br><span class="line">    <span class="keyword">if</span> (sample) &#123;</span><br><span class="line">        <span class="comment">/* The only thing we do in this example is print a * to indicate a received buffer */</span></span><br><span class="line">        g_print (<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        gst_sample_unref (sample);</span><br><span class="line">        <span class="keyword">return</span> GST_FLOW_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> GST_FLOW_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>appsink</code> 接收缓冲区时调用上面的函数。使用 <code>pull-sample</code> 操作信号来检索缓冲区，然后在屏幕上打印一些指示符。</p>
<p> <code>gst_app_src_pull_sample()</code> 作为 <code>gstreamer-app-1.0</code> 库的一部分，与上面的信号发射相比，它可能是一个更好的用于从 appsink 中提取样本&#x2F;缓冲区的函数，因为它有一个正确的类型签名，所以很难出错。</p>
<p>为了获取数据指针，我们需要像上面一样使用 <code>gst_buffer_map()</code> ，它将使用指向数据的指针和数据大小（以字节为单位）填充 <code>GstMapInfo</code> 辅助结构。处理完数据后，不要忘记再次 <code>gst_buffer_unmap()</code> 缓冲区。</p>
<p>此缓冲区不必与我们在 <code>push_data</code> 函数中生成的缓冲区匹配，路径中的任何元素都可以以任何方式更改缓冲区（本例中没有：只有一个 <code>tee</code> 在 <code>appsrc</code> 和 <code>appsink</code> 之间的路径中，并且 <code>tee</code> 不会更改缓冲区的内容）。</p>
<p>最后 <code>gst_sample_unref()</code> 检索到的样本，本教程就完成了。</p>
<p>基础教程9：媒体信息采集</p>
<p>感觉用处不大</p>
<p>基础教程10：</p>
<p>无用</p>
<h2 id="基础教程11：调试工具"><a href="#基础教程11：调试工具" class="headerlink" title="基础教程11：调试工具"></a>基础教程11：调试工具</h2><p>GStreamer 及其插件充满了调试跟踪，即代码中将特别有趣的信息打印到控制台的位置，以及时间戳、进程、类别、源代码文件、函数和元素信息。调试输出由 <code>GST_DEBUG</code> 环境变量控制。</p>
<p>GStreamer 调试日志非常详细，完全启用会打印很多。设置 <code>GST_DEBUG=2</code>就可以获得 <code>ERROR</code> 和 <code>WARNING</code> 消息。</p>
<p>使用 <code>GST_ERROR()</code> 、 <code>GST_WARNING()</code> 、 <code>GST_INFO()</code> 、 <code>GST_LOG()</code> 和 <code>GST_DEBUG()</code> 宏。它们接受与 <code>printf</code> 相同的参数，并使用 <code>default</code> 类别（ <code>default</code> 将在输出日志中显示为“DEBUG”类别，对应值为5）。</p>
<p>获取管道图：</p>
<p>GStreamer 能够输出图形文件。这些是 <code>.dot</code> 文件，可以使用 GraphViz 等免费程序读取，描述管道的拓扑结构以及每个链接中协商的上限。</p>
<p>要获取 <code>.dot</code> 文件，只需将 <code>GST_DEBUG_DUMP_DOT_DIR</code> 环境变量设置为指向要放置文件的文件夹即可。 <code>gst-launch-1.0</code> 将在每次状态更改时创建一个 <code>.dot</code> 文件，因此您可以看到上限协商的演变。取消设置变量以禁用此功能。在您的应用程序中，您可以在方便时使用 <code>GST_DEBUG_BIN_TO_DOT_FILE()</code> 和 <code>GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS()</code> 宏生成 <code>.dot</code> 文件。</p>
<p>基础教程 12：流式传输</p>
<p>感觉用处不大</p>
<h3 id="基础教程13：播放速度"><a href="#基础教程13：播放速度" class="headerlink" title="基础教程13：播放速度"></a>基础教程13：播放速度</h3><p>所要做的就是改变播放速率，该变量对于正常播放来说等于 1.0，对于快速模式大于 1.0（绝对值），对于慢速模式小于 1.0（绝对值），对于向前播放为正值，反向播放时为负值。</p>
<p>GStreamer 提供了两种更改播放速率的机制：Step Events 和 Seek Events。除了更改后续播放速率（仅限正值）之外，Step Events 还允许跳过给定数量的媒体。此外，“Seek Events”允许跳转到流中的任何位置并设置正和负播放速率。</p>
<p>Step Events 是更改播放速率的更方便的方法，因为创建它们所需的参数数量减少了；但是，它们有一些缺点，因此本教程中使用 Seek Events。Step Events 仅影响接收器（在管道末端），因此只有当管道的其余部分可以支持以不同的速度运行时，它们才会起作用， Seek Events 会一直通过管道，因此每个元素都可以对它们做出反应。 Step Events 事件的优点是行动速度更快。步骤事件也无法改变播放方向。</p>
<p>要使用这些事件，需要创建它们，然后将其传递到管道，它们在管道中向上游传播，直到到达可以处理它们的元素。如果一个事件被传递到像 <code>playbin</code> 这样的 bin 元素上，它只会将事件提供给它的所有接收器，这将导致执行多次查找。常见的方法是通过 <code>video-sink</code> 或 <code>audio-sink</code> 属性检索 <code>playbin</code> 的接收器之一，并将事件直接送入接收器。</p>
<p>帧步进是一种允许逐帧播放视频的技术。它是通过暂停管道，然后发送 Step Events 每次跳过一帧来实现的。</p>
<p>main 函数中的初始化代码没有什么新内容：实例化了 <code>playbin</code> 管道，安装了 I&#x2F;O 监视器来跟踪击键，并执行了 GLib 主循环。然后，在键盘处理函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process keyboard input */</span></span><br><span class="line"><span class="type">static</span> gboolean <span class="title function_">handle_keyboard</span> <span class="params">(GIOChannel *source, GIOCondition cond, CustomData *data)</span> &#123;</span><br><span class="line">    gchar *str = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_io_channel_read_line (source, &amp;str, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) != G_IO_STATUS_NORMAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (g_ascii_tolower (str[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            data-&gt;playing = !data-&gt;playing;</span><br><span class="line">            gst_element_set_state (data-&gt;pipeline, data-&gt;playing ? GST_STATE_PLAYING : GST_STATE_PAUSED);</span><br><span class="line">            g_print (<span class="string">&quot;Setting state to %s\n&quot;</span>, data-&gt;playing ? <span class="string">&quot;PLAYING&quot;</span> : <span class="string">&quot;PAUSE&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>与之前的教程一样，暂停&#x2F;播放切换是通过 <code>gst_element_set_state()</code> 处理的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">	<span class="keyword">if</span> (g_ascii_isupper (str[<span class="number">0</span>])) &#123;</span><br><span class="line">    	data-&gt;rate *= <span class="number">2.0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	data-&gt;rate /= <span class="number">2.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	send_seek_event (data);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">	data-&gt;rate *= <span class="number">-1.0</span>;</span><br><span class="line">	send_seek_event (data);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>使用“S”和“s”将当前播放速率加倍或减半，使用“d”反转当前播放方向。在这两种情况下，都会更新 <code>rate</code> 变量并调用 <code>send_seek_event</code> 。我们来回顾一下这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send seek event to change rate */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">send_seek_event</span> <span class="params">(CustomData *data)</span> &#123;</span><br><span class="line">    gint64 position;</span><br><span class="line">    GstEvent *seek_event;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Obtain the current position, needed for the seek event */</span></span><br><span class="line">    <span class="keyword">if</span> (!gst_element_query_position (data-&gt;pipeline, GST_FORMAT_TIME, &amp;position)) &#123;</span><br><span class="line">        g_printerr (<span class="string">&quot;Unable to retrieve current position.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该函数创建一个新的 Seek Event 并将其发送到管道以更新速率。首先，使用 <code>gst_element_query_position()</code> 恢复当前位置。这是必需的，因为 Seek  Events 跳转到流中的另一个位置，并且由于我们实际上不想移动，所以我们跳转到当前位置。使用 Step Events 会更简单，但该事件目前尚未完全发挥作用，如简介中所述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create the seek event */</span></span><br><span class="line"><span class="keyword">if</span> (data-&gt;rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    seek_event = gst_event_new_seek (data-&gt;rate, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH </span><br><span class="line">| GST_SEEK_FLAG_ACCURATE, GST_SEEK_TYPE_SET, position, GST_SEEK_TYPE_END, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    seek_event = gst_event_new_seek (data-&gt;rate, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH </span><br><span class="line">| GST_SEEK_FLAG_ACCURATE, GST_SEEK_TYPE_SET, <span class="number">0</span>, GST_SEEK_TYPE_SET, position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Seek 事件是使用 <code>gst_event_new_seek()</code> 创建的。它的参数基本上是新的速率、新的开始位置和新的停止位置。无论哪种播放方向，起始位置都必须小于停止位置，因此两个播放方向要区别对待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data-&gt;video_sink == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* If we have not done so, obtain the sink through which we will send the seek events */</span></span><br><span class="line">    g_object_get (data-&gt;pipeline, <span class="string">&quot;video-sink&quot;</span>, &amp;data-&gt;video_sink, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新的事件最终通过 <code>gst_element_send_event()</code> 发送到选定的接收器。</p>
<p>回到键盘处理程序及，看一下帧步进代码，这非常简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (data-&gt;video_sink == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* If we have not done so, obtain the sink through which we will send the step events */</span></span><br><span class="line">    g_object_get (data-&gt;pipeline, <span class="string">&quot;video-sink&quot;</span>, &amp;data-&gt;video_sink, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gst_element_send_event (data-&gt;video_sink,</span><br><span class="line">                        gst_event_new_step (GST_FORMAT_BUFFERS, <span class="number">1</span>, ABS (data-&gt;rate), TRUE, FALSE));</span><br><span class="line">g_print (<span class="string">&quot;Stepping one frame\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>使用 <code>gst_event_new_step()</code> 创建一个新的步进事件，其参数基本上指定要跳过的量（示例中为 1 帧）和新速率（我们不更改）。</p>
<p>视频接收器是从 <code>playbin</code> 获取的，以防万一我们还没有，就像以前一样。</p>
<p>这样我们就完成了。测试本教程时，请记住，向后播放在许多元素中都不是最佳的。</p>
<h2 id="基础教程-14：方便的元素："><a href="#基础教程-14：方便的元素：" class="headerlink" title="基础教程 14：方便的元素："></a>基础教程 14：方便的元素：</h2><p>都是用在 <code>gst-launch-1.0</code> 工具中的参数，其中部分：</p>
<h3 id="uridecodebin"><a href="#uridecodebin" class="headerlink" title="uridecodebin"></a><code>uridecodebin</code></h3><p>该元素将数据从 URI 解码为原始媒体。它选择一个可以处理给定 URI 方案的源元素并将其连接到 <code>decodebin</code> 元素。它的作用就像一个解复用器，因此它提供与媒体中找到的流一样多的源 pad。</p>
<h3 id="decodebin"><a href="#decodebin" class="headerlink" title="decodebin"></a><code>decodebin</code></h3><p>该元素通过自动插入使用可用的解码器和解复用器自动构建解码管道，直到获得原始媒体。它由 <code>uridecodebin</code> 内部使用，通常使用起来更方便，因为它也创建了合适的源元素。它取代了旧的 <code>decodebin</code> 元素。它的作用就像一个解复用器，因此它提供与媒体中找到的流一样多的源 pad。</p>
<h3 id="videoconvert"><a href="#videoconvert" class="headerlink" title="videoconvert"></a><code>videoconvert</code></h3><p>元素从一种颜色空间（例如 RGB）转换为另一种颜色空间（例如 YUV）。它还可以在不同的 YUV 格式（例如 I420、NV12、YUY2 …）或 RGB 格式排列（例如 RGBA、ARGB、BGRA …）之间进行转换。这通常是解决谈判问题时的首选。当不需要时，由于其上游和下游元素已经可以相互理解，因此它以直通模式运行，对性能的影响最小。根据经验，每当您使用大写字母在设计时未知的元素（如 <code>autovideosink</code> ）或可能因外部因素（如解码用户）而变化时，请始终使用 <code>videoconvert</code> 。提供的文件。</p>
<h3 id="videorate"><a href="#videorate" class="headerlink" title="videorate"></a><code>videorate</code></h3><p>该元素接受带有时间戳的视频帧的传入流，并生成与源板的帧速率匹配的流。校正是通过丢弃和复制帧来执行的，没有使用花哨的算法来插值帧。这对于允许需要不同帧速率的元素进行链接非常有用。与其他适配器一样，如果不需要（因为两个 Pad 都可以同意帧速率），它会以直通模式运行并且不会影响性能。</p>
<h3 id="videoscale"><a href="#videoscale" class="headerlink" title="videoscale"></a><code>videoscale</code></h3><p>该元素调整视频帧的大小。默认情况下，元素会尝试在源焊盘和接收焊盘上协商到相同的大小，以便不需要缩放。因此，如果不需要扩展，则可以安全地将此元素插入管道中以获得更稳健的行为，而无需任何成本。该元素支持广泛的色彩空间，包括各种 YUV 和 RGB 格式，因此通常能够在管道中的任何位置运行。如果要将视频输出到大小由用户控制的窗口，则最好使用 <code>videoscale</code> 元素，因为并非所有视频接收器都能够执行缩放操作。</p>
<h2 id="播放教程3：缩短管道"><a href="#播放教程3：缩短管道" class="headerlink" title="播放教程3：缩短管道"></a>播放教程3：缩短管道</h2><p>基础教程 8：缩短管道展示了应用程序如何使用名为 appsrc 和 appsink 的两个特殊元素手动提取数据或将数据注入到管道中。<code>playbin</code> 也允许使用这些元素，但连接它们的方法不同。要将 <code>appsink</code> 连接到 <code>playbin</code> ，请参阅播放教程 7：自定义 playbin 接收器。本教程展示 如何将 <code>appsrc</code> 与 <code>playbin</code> 连接并配置<code>appsrc</code></p>
<p>要使用 <code>appsrc</code> 作为管道源，只需实例化 <code>playbin</code> 并将其 URI 设置为 <code>appsrc://</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create the playbin element */</span></span><br><span class="line">data.pipeline = gst_parse_launch (<span class="string">&quot;playbin uri=appsrc://&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p><code>playbin</code> 将创建一个内部 <code>appsrc</code> 元素并触发 <code>source-setup</code> 信号以允许应用程序对其进行配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_signal_connect (data.pipeline, <span class="string">&quot;source-setup&quot;</span>, G_CALLBACK (source_setup), &amp;data);</span><br></pre></td></tr></table></figure>

<p>设置 <code>appsrc</code> 的<code>caps</code> 属性非常重要，因为一旦信号处理程序返回， <code>playbin</code> 将根据这些上限实例化管道中的下一个元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当 playbin 创建 appsrc 元素时会调用此函数，因此我们有机会对其进行配置。*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">source_setup</span> <span class="params">(GstElement *pipeline, GstElement *source, CustomData *data)</span> &#123;</span><br><span class="line">    GstAudioInfo info;</span><br><span class="line">    GstCaps *audio_caps;</span><br><span class="line"></span><br><span class="line">    g_print (<span class="string">&quot;Source has been created. Configuring.\n&quot;</span>);</span><br><span class="line">    data-&gt;app_source = source;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configure appsrc */</span></span><br><span class="line">    gst_audio_info_set_format (&amp;info, GST_AUDIO_FORMAT_S16, SAMPLE_RATE, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    audio_caps = gst_audio_info_to_caps (&amp;info);</span><br><span class="line">    g_object_set (source, <span class="string">&quot;caps&quot;</span>, audio_caps, <span class="string">&quot;format&quot;</span>, GST_FORMAT_TIME, <span class="literal">NULL</span>);</span><br><span class="line">    g_signal_connect (source, <span class="string">&quot;need-data&quot;</span>, G_CALLBACK (start_feed), data);</span><br><span class="line">    g_signal_connect (source, <span class="string">&quot;enough-data&quot;</span>, G_CALLBACK (stop_feed), data);</span><br><span class="line">    gst_caps_unref (audio_caps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>appsrc</code> 的配置与基础教程 8：缩短管道完全相同：将 caps 设置为 <code>audio/x-raw</code> ，并注册了两个回调，因此元素可以告诉应用程序何时需要启动和停止推送数据。有关更多详细信息，请参阅基础教程 8：缩短管道。</p>
<p>从这一点开始， <code>playbin</code> 负责处理管道的其余部分，应用程序只需要担心在被告知时生成更多数据。</p>
<p>要了解如何使用 <code>appsink</code> 元素从 <code>playbin</code> 中提取数据，请参阅播放教程 7：自定义 playbin 接收器。</p>
<h2 id="播放教程-7：自定义-playbin-接收器"><a href="#播放教程-7：自定义-playbin-接收器" class="headerlink" title="播放教程 7：自定义 playbin 接收器"></a>播放教程 7：自定义 playbin 接收器</h2><p><code>playbin</code> 可以通过手动选择其音频和视频接收器来进一步自定义。这允许应用程序依赖 <code>playbin</code> 来检索和解码媒体，然后自行管理最终的渲染&#x2F;显示。</p>
<p><code>playbin</code> 的两个属性允许选择所需的音频和视频接收器： <code>audio-sink</code> 和 <code>video-sink</code> （分别）。应用程序只需要实例化适当的 <code>GstElement</code> 并通过这些属性将其传递给 <code>playbin</code> 。但是，此方法只允许使用单个元素作为接收器。如果需要更复杂的管道，例如均衡器加音频接收器，则需要将其包装在 Bin 中，因此它看起来 <code>playbin</code> 就好像它是单个 Element 一样。</p>
<p>Bin ( <code>GstBin</code> ) 是一个封装部分管道的容器，因此可以将它们作为单个元素进行管理。例如，我们在所有教程中使用的 <code>GstPipeline</code> 是 <code>GstBin</code> 的类型，它不与外部元素交互。 Bin 内的元素通过 Ghost Pad ( <code>GstGhostPad</code> ) 连接到外部元素，这是 Bin 表面上的 Pad，它只是将数据从外部 Pad 转发到内部元素上的给定 Pad。</p>
<p><code>GstBin</code> 也是 <code>GstElement</code> 的一种类型，因此它们可以在需要 Element 的任何地方使用，特别是作为 <code>playbin</code> 的接收器（然后它们被称为水槽）。</p>
<img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407121449898.png" alt="image-20240712144952972" style="zoom: 67%;" />

<p>图 1：带有两个 Elements 和一个 Ghost Pad 的 Bin。</p>
<p><code>GstBin</code> 也是 <code>GstElement</code> 的一种类型，因此它们可以在需要 Element 的任何地方使用，特别是作为 <code>playbin</code> 的接收器（然后它们被称为水槽）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create the elements inside the sink bin */</span></span><br><span class="line">equalizer = gst_element_factory_make (<span class="string">&quot;equalizer-3bands&quot;</span>, <span class="string">&quot;equalizer&quot;</span>);</span><br><span class="line">convert = gst_element_factory_make (<span class="string">&quot;audioconvert&quot;</span>, <span class="string">&quot;convert&quot;</span>);</span><br><span class="line">sink = gst_element_factory_make (<span class="string">&quot;autoaudiosink&quot;</span>, <span class="string">&quot;audio_sink&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!equalizer || !convert || !sink) &#123;</span><br><span class="line">    g_printerr (<span class="string">&quot;Not all elements could be created.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组成的 sink-bin 的所有元素都被实例化。我们使用 <code>equalizer-3bands</code> 和 <code>autoaudiosink</code> ，中间有 <code>audioconvert</code> ，因为我们不确定音频接收器的功能（因为它们是硬件 -依赖）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create the sink bin, add the elements and link them */</span></span><br><span class="line">bin = gst_bin_new (<span class="string">&quot;audio_sink_bin&quot;</span>);</span><br><span class="line">gst_bin_add_many (GST_BIN (bin), equalizer, convert, sink, <span class="literal">NULL</span>);</span><br><span class="line">gst_element_link_many (equalizer, convert, sink, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>这会将新元素添加到 Bin 中并将它们链接起来，就像我们在管道中所做的那样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取bin的第一个元素 equalize r的 sink pad</span></span><br><span class="line">pad = gst_element_get_static_pad (equalizer, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line"><span class="comment">// 用上面获取的pad new 一个 ghost_pad 并启用</span></span><br><span class="line">ghost_pad = gst_ghost_pad_new (<span class="string">&quot;sink&quot;</span>, pad);</span><br><span class="line">gst_pad_set_active (ghost_pad, TRUE);</span><br><span class="line"><span class="comment">// 为 bin 添加 ghost_pad</span></span><br><span class="line">gst_element_add_pad (bin, ghost_pad);</span><br><span class="line"><span class="comment">// 释放旧 pad，ghost_pad 所有权在 bin</span></span><br><span class="line">gst_object_unref (pad);</span><br></pre></td></tr></table></figure>

<p>现在我们需要创建一个 Ghost Pad，以便 Bin 内的部分管道可以连接到外部。该 Ghost Pad 将连接到内部 Elements 之一的 Pad（均衡器的接收器 pad），因此我们使用 <code>gst_element_get_static_pad()</code> 检索该 Pad。请记住基础教程 7：多线程和 Pad 可用性，如果这是 Request Pad 而不是 Always Pad，我们将需要使用 <code>gst_element_request_pad()</code> 。</p>
<p>Ghost Pad 使用 <code>gst_ghost_pad_new()</code> 创建（指向我们刚刚获取的内部 Pad），并使用 <code>gst_pad_set_active()</code> 激活。然后使用 <code>gst_element_add_pad()</code> 将其添加到 Bin，将 Ghost Pad 的所有权转移到 bin，因此我们不必担心释放它。</p>
<p>最后，我们从均衡器 equalizer 获得的 sink Pad 需要用 <code>gst_object_unref()</code> 释放。</p>
<p>此时，我们有了一个功能性的 sink-bin，我们可以将其用作 <code>playbin</code> 中的音频接收器。我们只需要指示 <code>playbin</code> 使用它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set playbin&#x27;s audio sink to be our sink bin */</span></span><br><span class="line">g_object_set (GST_OBJECT (pipeline), <span class="string">&quot;audio-sink&quot;</span>, bin, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>就像将 <code>playbin</code> 上的 <code>audio-sink</code> 属性设置为新创建的接收器一样简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Configure the equalizer */</span></span><br><span class="line">g_object_set (G_OBJECT (equalizer), <span class="string">&quot;band1&quot;</span>, (gdouble)<span class="number">-24.0</span>, <span class="literal">NULL</span>);</span><br><span class="line">g_object_set (G_OBJECT (equalizer), <span class="string">&quot;band2&quot;</span>, (gdouble)<span class="number">-24.0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>剩下的唯一一点就是配置均衡器。对于此示例，两个较高频段被设置为最大衰减，因此低音得到增强。稍微调整一下这些值以感受差异（请参阅 <code>equalizer-3bands</code> 元素的文档以了解允许的值范围）。</p>
<h4 id="gst-app-src-push-buffer"><a href="#gst-app-src-push-buffer" class="headerlink" title="gst_app_src_push_buffer"></a><em>gst_app_src_push_buffer</em></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GstFlowReturn</span><br><span class="line"><span class="title function_">gst_app_src_push_buffer</span> <span class="params">(GstAppSrc * appsrc,</span></span><br><span class="line"><span class="params">                         GstBuffer * buffer)</span></span><br></pre></td></tr></table></figure>

<p>将缓冲区添加到缓冲区队列中，appsrc 元素将其推送到其源焊盘。该函数取得缓冲区的所有权。<br>当 block 属性为 TRUE 时，此函数可以阻塞，直到队列中出现可用空间。</p>
<h4 id="gst-app-src-get-stream-type"><a href="#gst-app-src-get-stream-type" class="headerlink" title="gst_app_src_get_stream_type"></a><em>gst_app_src_get_stream_type</em></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GstAppStreamType</span><br><span class="line"><span class="title function_">gst_app_src_get_stream_type</span> <span class="params">(GstAppSrc * appsrc)</span></span><br></pre></td></tr></table></figure>


<p>获取流类型。使用 <a target="_blank" rel="noopener" href="https://gstreamer.freedesktop.org/documentation/applib/gstappsrc.html#gst_app_src_set_stream_type">gst_app_src_set_stream_type</a> 控制 appsrc 的流类型。</p>
<p><strong>参数：</strong></p>
<p><strong><code>appsrc</code></strong> – a <a target="_blank" rel="noopener" href="https://gstreamer.freedesktop.org/documentation/applib/gstappsrc.html#GstAppSrc">GstAppSrc</a></p>
<p>返回流类型。</p>
<h4 id="gst-app-src-get-size"><a href="#gst-app-src-get-size" class="headerlink" title="gst_app_src_get_size"></a><em>gst_app_src_get_size</em></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gint64</span><br><span class="line"><span class="title function_">gst_app_src_get_size</span> <span class="params">(GstAppSrc * appsrc)</span></span><br></pre></td></tr></table></figure>

<p>获取流的大小（以字节为单位）。值 -1 表示大小未知。</p>
<p><strong>参数：</strong></p>
<p><strong><code>appsrc</code></strong> – a <a target="_blank" rel="noopener" href="https://gstreamer.freedesktop.org/documentation/applib/gstappsrc.html#GstAppSrc">GstAppSrc</a></p>
<p> 返回 – 之前使用 gst_app_src_set_size 设置的流的大小；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -g src/server.cc -o server `pkg-config --cflags --libs gstreamer-1.0 gstreamer-video-1.0` -lstdc++ -lpthread -lstdc++ -lstdc++fs -lstdc++ -lgstapp-1.0 -lgstvideo-1.0 -lgstbase-1.0</span><br><span class="line"></span><br><span class="line">gcc -g src/extract_frame.c -o extract_frame `pkg-config --cflags --libs gstreamer-1.0`</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yuanmxc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/05/GStreamer%20%E6%95%99%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">http://example.com/2024/06/05/GStreamer%20%E6%95%99%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">陌上尘归处</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p41.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/06/02/GSteamer%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="GSteamer 学习笔记"><img class="cover" src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p12.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">GSteamer 学习笔记</div></div><div class="info-2"><div class="info-item-1">GSteamer 学习笔记前言本文是笔者阅读 GStreamer 官方文档去学习 GStreamer 时的记录，大部分内容可以在 GStreamer 官方文档中找到。 笔者学习 GStreamer 的主要目的是：使用 GStreamer 处理从 TCP Socket 接收到的 H.265 裸流（使用 live555 的 testRTSPclient 程序从 RTSP URL 中获取到），将其解码并保存为 jpeg 图片。 笔者最终放弃使用 GStreamer 的想法，使用 FFmpeg 完成了上述目的。 Elements 元素GStreamer 中最重要的对象是 GstElement 对象。元素是媒体管道的基本构建基块。使用的所有不同的高级组件都派生自 GstElement 。每个解码器、编码器、解复用器、视频或音频输出实际上都是一个...</div></div></div></a><a class="pagination-related" href="/2024/07/05/Arch%20Linux%20%E5%AE%89%E8%A3%85%20CUDA%20%E3%80%81TensorRT%20%20%E5%92%8C%20TensorRT-YOLO%20%E8%AE%B0%E5%BD%95/" title="Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录"><img class="cover" src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p31.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录</div></div><div class="info-2"><div class="info-item-1">ArchLinux 安装 CUDA 、TensorRT  和 TensorRT-YOLO 记录安装TensorRT 和 CUDA 根据 TensorRT-YOLO Github 页面使用教程中的 快速编译安装  进行，编译前首先要安装 xmake CUDA 和 TensorRT。  xmake 简单，只需要：  1yay -S xmake  安装 CUDA 和 TensorRT   安装 CUDA ：   1yay -S cuda    版本为最新版 cuda-12.5.1-1  在安装 TensorRT ：   1yay -S tensorrt    遇到错误，AUR 提供的 TensorRT 目前仍是 10.1.0.27-1 版本，而 CUDA 和 TensorRT 的版本必须是一一对应的，TensorRT 使用 CUDA 。   吐槽一下，“适配”这件事做的不是很好，摘自 Archlinux AUR 的 tensorrt 软件包下一个老哥的评论（已置顶）：  它（指 AUR 提供的 tensorrt 10.1.0.27-1）无法针对 cuda 12.5 构建，将 cuda...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/other/touxiang2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yuanmxc</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Yuanmxc"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Yuanmxc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">不乱于心，不困于情。不畏将来，不念过往。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GStreamer-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">GStreamer 示例代码学习记录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B1%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">基础教程1：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B2"><span class="toc-number">1.3.</span> <span class="toc-text">基础教程2:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B3%E5%8A%A8%E6%80%81%E7%AE%A1%E9%81%93"><span class="toc-number">1.4.</span> <span class="toc-text">基础教程3动态管道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B4"><span class="toc-number">1.5.</span> <span class="toc-text">基础教程4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B6"><span class="toc-number">1.6.</span> <span class="toc-text">基础教程6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B7-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CPad%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">1.7.</span> <span class="toc-text">基础教程7:多线程和Pad可用性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B8%EF%BC%9A%E7%AE%80%E5%8C%96%E7%AE%A1%E9%81%93"><span class="toc-number">1.8.</span> <span class="toc-text">基础教程8：简化管道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B11%EF%BC%9A%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">1.9.</span> <span class="toc-text">基础教程11：调试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B13%EF%BC%9A%E6%92%AD%E6%94%BE%E9%80%9F%E5%BA%A6"><span class="toc-number">1.9.1.</span> <span class="toc-text">基础教程13：播放速度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-14%EF%BC%9A%E6%96%B9%E4%BE%BF%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%9A"><span class="toc-number">1.10.</span> <span class="toc-text">基础教程 14：方便的元素：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#uridecodebin"><span class="toc-number">1.10.1.</span> <span class="toc-text">uridecodebin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decodebin"><span class="toc-number">1.10.2.</span> <span class="toc-text">decodebin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#videoconvert"><span class="toc-number">1.10.3.</span> <span class="toc-text">videoconvert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#videorate"><span class="toc-number">1.10.4.</span> <span class="toc-text">videorate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#videoscale"><span class="toc-number">1.10.5.</span> <span class="toc-text">videoscale</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%92%AD%E6%94%BE%E6%95%99%E7%A8%8B3%EF%BC%9A%E7%BC%A9%E7%9F%AD%E7%AE%A1%E9%81%93"><span class="toc-number">1.11.</span> <span class="toc-text">播放教程3：缩短管道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%92%AD%E6%94%BE%E6%95%99%E7%A8%8B-7%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89-playbin-%E6%8E%A5%E6%94%B6%E5%99%A8"><span class="toc-number">1.12.</span> <span class="toc-text">播放教程 7：自定义 playbin 接收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gst-app-src-push-buffer"><span class="toc-number">1.12.0.1.</span> <span class="toc-text">gst_app_src_push_buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gst-app-src-get-stream-type"><span class="toc-number">1.12.0.2.</span> <span class="toc-text">gst_app_src_get_stream_type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gst-app-src-get-size"><span class="toc-number">1.12.0.3.</span> <span class="toc-text">gst_app_src_get_size</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/10/ArchLinux%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E5%B0%8F%E7%82%B9%E6%9D%82%E8%AE%B0%20%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/" title="ArchLinux 使用记录"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p43.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ArchLinux 使用记录"/></a><div class="content"><a class="title" href="/2025/01/10/ArchLinux%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E5%B0%8F%E7%82%B9%E6%9D%82%E8%AE%B0%20%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/" title="ArchLinux 使用记录">ArchLinux 使用记录</a><time datetime="2025-01-10T07:39:14.000Z" title="发表于 2025-01-10 15:39:14">2025-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/06/%E5%B0%86%20Python%20%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/" title="将 Python 程序打包为可执行文件（Windows &amp; Linux）"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p26.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="将 Python 程序打包为可执行文件（Windows &amp; Linux）"/></a><div class="content"><a class="title" href="/2025/01/06/%E5%B0%86%20Python%20%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/" title="将 Python 程序打包为可执行文件（Windows &amp; Linux）">将 Python 程序打包为可执行文件（Windows &amp; Linux）</a><time datetime="2025-01-06T08:36:14.000Z" title="发表于 2025-01-06 16:36:14">2025-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/06/Arch%20Linux%20%E4%B8%BA%20AppImage%20%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%99%A8%E5%85%A5%E5%8F%A3/" title="将 Python 程序打包为可执行文件（Windows &amp; Linux）"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="将 Python 程序打包为可执行文件（Windows &amp; Linux）"/></a><div class="content"><a class="title" href="/2024/11/06/Arch%20Linux%20%E4%B8%BA%20AppImage%20%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%99%A8%E5%85%A5%E5%8F%A3/" title="将 Python 程序打包为可执行文件（Windows &amp; Linux）">将 Python 程序打包为可执行文件（Windows &amp; Linux）</a><time datetime="2024-11-06T07:04:01.000Z" title="发表于 2024-11-06 15:04:01">2024-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/13/Arch%20Linux%20%E5%AE%89%E8%A3%85%20openpose%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Arch Linux 安装 openpose 踩坑记录"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p29.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Arch Linux 安装 openpose 踩坑记录"/></a><div class="content"><a class="title" href="/2024/07/13/Arch%20Linux%20%E5%AE%89%E8%A3%85%20openpose%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Arch Linux 安装 openpose 踩坑记录">Arch Linux 安装 openpose 踩坑记录</a><time datetime="2024-07-13T06:18:36.000Z" title="发表于 2024-07-13 14:18:36">2024-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/05/Arch%20Linux%20%E5%AE%89%E8%A3%85%20CUDA%20%E3%80%81TensorRT%20%20%E5%92%8C%20TensorRT-YOLO%20%E8%AE%B0%E5%BD%95/" title="Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录"><img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p31.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录"/></a><div class="content"><a class="title" href="/2024/07/05/Arch%20Linux%20%E5%AE%89%E8%A3%85%20CUDA%20%E3%80%81TensorRT%20%20%E5%92%8C%20TensorRT-YOLO%20%E8%AE%B0%E5%BD%95/" title="Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录">Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录</a><time datetime="2024-07-05T02:25:58.000Z" title="发表于 2024-07-05 10:25:58">2024-07-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/BlogWebsite/Background/p41.png);"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By Yuanmxc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">不乱于心，不困于情。不畏将来，不念过往。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>