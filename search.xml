<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>将 Python 程序打包为可执行文件（Windows &amp; Linux）</title>
    <url>/2024/11/06/Arch%20Linux%20%E4%B8%BA%20AppImage%20%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%99%A8%E5%85%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="Arch-Linux-为-AppImage-文件创建应用程序启动器入口"><a href="#Arch-Linux-为-AppImage-文件创建应用程序启动器入口" class="headerlink" title="Arch Linux 为 AppImage 文件创建应用程序启动器入口"></a>Arch Linux 为 AppImage 文件创建应用程序启动器入口</h1><h2 id="赋予执行权限"><a href="#赋予执行权限" class="headerlink" title="赋予执行权限"></a>赋予执行权限</h2><p>为 AppImage 文件添加可执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /home/Yuanmxc/Using/Cherry-Studio-0.9.21-x86_64.AppImage</span><br></pre></td></tr></table></figure>

<h2 id="提取-AppImage-内部资源"><a href="#提取-AppImage-内部资源" class="headerlink" title="提取 AppImage 内部资源"></a>提取 AppImage 内部资源</h2><p>通过 <code>--appimage-extract</code> 参数解压 AppImage 以获取内嵌图标：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/Yuanmxc/Using</span><br><span class="line">./Cherry-Studio-0.9.21-x86_64.AppImage --appimage-extract</span><br></pre></td></tr></table></figure>
<p>解压后生成 <code>squashfs-root</code> 目录，其中包含应用资源文件。</p>
<h2 id="定位并处理图标"><a href="#定位并处理图标" class="headerlink" title="定位并处理图标"></a>定位并处理图标</h2><p>进入解压目录查找图标文件。应用图标通常位于以下路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> squashfs-root/usr/share/icons/hicolor</span><br></pre></td></tr></table></figure>
<p>如果未找到，可以查看其他类似路径，比如我的在下面路径找到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">squashfs-root/usr/share/icons/hicolor/0x0/apps/cherrystudio.png</span><br></pre></td></tr></table></figure>
<p>将图标复制到系统图标目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /usr/share/icons/hicolor/512x512/apps</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /home/Yuanmxc/Using/squashfs-root/usr/share/icons/hicolor/0x0/apps/cherrystudio.png /usr/share/icons/hicolor/512x512/apps/</span><br></pre></td></tr></table></figure>

<p>你可以放在任何位置，但最好是同意放图标的位置，用户目录下也有。</p>
<h2 id="创建-desktop-文件"><a href="#创建-desktop-文件" class="headerlink" title="创建 .desktop 文件"></a>创建 <code>.desktop</code> 文件</h2><p>在系统级应用目录中创建桌面配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /usr/share/applications/cherry-studio.desktop</span><br></pre></td></tr></table></figure>
<p>文件内容如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Desktop Entry]</span></span><br><span class="line"><span class="attr">Name</span>=Cherry Studio</span><br><span class="line"><span class="attr">Exec</span>=/home/Yuanmxc/Using/Cherry-Studio-<span class="number">0.9</span>.<span class="number">21</span>-x<span class="number">86_64</span>.AppImage</span><br><span class="line"><span class="attr">Icon</span>=cherrystudio</span><br><span class="line"><span class="attr">Terminal</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">Type</span>=Application</span><br><span class="line"><span class="attr">Categories</span>=Development<span class="comment">;</span></span><br><span class="line"><span class="attr">StartupWMClass</span>=cherry-studio</span><br><span class="line"><span class="attr">Comment</span>=Launch Cherry Studio</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Icon</code> 字段仅需指定文件名（不含 <code>.png</code> 后缀），系统自动匹配 <code>/usr/share/icons</code> 下的文件。</li>
<li>未移动 AppImage 至系统目录，保留原始路径以简化操作。</li>
</ul>
<p>还有其他配置字段，可以自行查找。</p>
<h2 id="更新系统资源"><a href="#更新系统资源" class="headerlink" title="更新系统资源"></a>更新系统资源</h2><p>刷新图标缓存以使新图标生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gtk-update-icon-cache /usr/share/icons/hicolor</span><br></pre></td></tr></table></figure>
<p>更新桌面条目数据库以识别新应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-desktop-database /usr/share/applications</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>Arch Linux 安装 CUDA 、TensorRT  和TensorRT-YOLO 记录</title>
    <url>/2024/07/05/Arch%20Linux%20%E5%AE%89%E8%A3%85%20CUDA%20%E3%80%81TensorRT%20%20%E5%92%8C%20TensorRT-YOLO%20%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="ArchLinux-安装-CUDA-、TensorRT-和-TensorRT-YOLO-记录"><a href="#ArchLinux-安装-CUDA-、TensorRT-和-TensorRT-YOLO-记录" class="headerlink" title="ArchLinux 安装 CUDA 、TensorRT  和 TensorRT-YOLO 记录"></a>ArchLinux 安装 CUDA 、TensorRT  和 TensorRT-YOLO 记录</h1><h2 id="安装TensorRT-和-CUDA"><a href="#安装TensorRT-和-CUDA" class="headerlink" title="安装TensorRT 和 CUDA"></a>安装TensorRT 和 CUDA</h2><ol>
<li><p>根据 <a href="https://github.com/laugh12321/TensorRT-YOLO">TensorRT-YOLO</a> Github 页面使用教程中的 <a href="https://github.com/laugh12321/TensorRT-YOLO/blob/main/docs/cn/build_and_install.md">快速编译安装 </a> 进行，编译前首先要安装 xmake CUDA 和 TensorRT。</p>
<p> xmake 简单，只需要：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S xmake</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 CUDA 和 TensorRT </p>
<ul>
<li><p>安装 CUDA ：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S cuda</span><br></pre></td></tr></table></figure>

<p>  版本为最新版 cuda-12.5.1-1</p>
</li>
<li><p>在安装 TensorRT ：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S tensorrt</span><br></pre></td></tr></table></figure>

<p>  遇到错误，AUR 提供的 TensorRT 目前仍是 10.1.0.27-1 版本，而 CUDA 和 TensorRT 的版本必须是一一对应的，TensorRT 使用 CUDA 。</p>
<p>  吐槽一下，“适配”这件事做的不是很好，摘自 Archlinux AUR 的 <a href="https://aur.archlinux.org/packages/tensorrt">tensorrt</a> 软件包下一个老哥的评论（已置顶）：</p>
<blockquote>
<p>它（指 AUR 提供的 tensorrt 10.1.0.27-1）无法针对 cuda 12.5 构建，将 cuda 降级到 12.4.1，它将起作用。长话短说：关于这一点有两个问题。首先，tensorrt 10.0.1 显然不支持 cuda 12.5，正如您在<a href="https://github.com/NVIDIA/TensorRT/tree/v10.0.1?tab=readme-ov-file#optional---if-not-using-tensorrt-container-specify-the-tensorrt-ga-release-build-path">上游文档</a>中看到的那样。其次，官方仓库中提供的当前版本的 nvidia 驱动程序不支持 cuda 12.5（cuda 12.5 是在没有支持它的驱动程序的情况下推送的），您可以在<a href="https://gitlab.archlinux.org/archlinux/packaging/packages/cuda/-/issues/7">此链接</a>的 Arch Linux cuda 软件包问题页面中阅读更多详细信息。</p>
</blockquote>
<p>  两个解决办法：</p>
<ol>
<li><p>使用 downgrade 降级 CUDA 到 12.4.1 ：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> downgrade cuda</span><br></pre></td></tr></table></figure>

<p> 但是下载速度异常缓慢，几十kb每秒（刚开始还比较快），故放弃。</p>
<p> 我也尝试过在英伟达官网进行下载 CUDA ，首先你必须注册一个账号，其次，官网上 CUDA 只支持特定的几个 Linux 发行版，其中刚好没有 ArchLinux（那 AUR 的软件包是从何而来的？）</p>
</li>
<li><p>手动安装 TensorRT 的 10.2.0 版本:  </p>
<p> 在 NVIDIA 的 GitHub <a href="https://github.com/NVIDIA/TensorRT">TensorRT</a> 下克隆存储库并进行安装。</p>
<p> 原本打算在本机上进行安装，最后 cmake 时遇到报错，问 GPT 说是 gcc 版本和 CUDA 的编译器 nvcc 版本的问题，继续查。</p>
<p> 最后发现 CUDA 12.4, 12.5 版本最大支持的 GCC 版本竟然是 13.2。查看本机的gcc版本为：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br><span class="line">gcc 版本 14.1.1 20240522 (GCC)</span><br></pre></td></tr></table></figure>

<p> 而其我并不是在英伟达官网找到的（没找到，理论上应该有），是 Google 之后在 <a href="https://stackoverflow.com/questions/6622454/cuda-incompatible-with-my-gcc-version">一篇帖子</a> 下的评论找到的，这篇帖子发布于 2011 年，但我甚至能看到今年的评论。</p>
<p> 评论的老哥给了一个CUDA 版本和其支持的最高 GCC 版本的对应表格以及更多信息，首次评论在 Sep 23, 2017 at 14:23 ，最新编辑在 <a href="https://stackoverflow.com/posts/46380601/revisions">Jun 18 at 19:16</a> ，应该是相关开发人员？</p>
<p> 因为降级 gcc 会破坏其他依赖，无法降级，本来打算按教程使用 docker 来用的，但是这位老哥下面给出了方法，简单来说就是安装旧版本的 gcc ，之后让 CUDA 的编译器 nvcc 使用旧版本的 gcc。 </p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装适配的旧版本gcc</span></span><br><span class="line"><span class="built_in">sudo</span> pacmane -S gcc13</span><br><span class="line"><span class="comment"># 在 CUDA 文件夹中添加符号链接：</span></span><br><span class="line"><span class="built_in">cd</span> /opt/cuda</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/bin/gcc-13 /usr/local/cuda/bin/gcc </span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/bin/g++-13 /usr/local/cuda/bin/g++</span><br></pre></td></tr></table></figure>

<p> 这位老哥的评论下最新的评论在 <a href="https://stackoverflow.com/questions/6622454/cuda-incompatible-with-my-gcc-version#comment137261685_46380601">CommentedJan 22 at 12:27</a> ，方法有用。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>在解决了各种版本问题后，我目前安装的环境如下：</p>
<ul>
<li><p>ArchLinux AUR 安装的 cuda-12.5.1-1。</p>
</li>
<li><p>在 NVIDIA 的 GitHub <a href="https://github.com/NVIDIA/TensorRT/releases">TensorRT Releases </a> 安装的 TensorRT OSS v10.2.0 存储库。</p>
</li>
<li><p>yay 安装 cuda-12.5.1-1 时安装 cuda-cudnn-9.2.0.82-1。</p>
</li>
<li><p>指定上面安装的 gcc13 ，让 CUDA 的编译器 nvcc 使用。</p>
</li>
</ul>
<p> 然后按照在 NVIDIA 的 GitHub  <a href="https://github.com/NVIDIA/TensorRT#build">TensorRT Build</a> 的教程进行安装。</p>
<p> 根据上面写的推荐版本 cuda-12.5.0 + cuDNN-8.9 ，使用 downgrade 降级安装 cuDNN-8.9 版本。</p>
<p> 最后至此开始正式 build。</p>
</li>
<li><p>按教程安装 <a href="https://developer.nvidia.com/downloads/compute/machine-learning/tensorrt/10.2.0/tars/TensorRT-10.2.0.19.Linux.x86_64-gnu.cuda-12.5.tar.gz">TensorRT 10.2.0.19 for CUDA 12.5, Linux x86_64</a> ，解压并设置 <code>TRT_LIBPATH</code> 到 ~&#x2F;.zshrc ，然后在 TensorRT 目录下执行下面操作：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$TRT_OSSPATH</span></span><br><span class="line"><span class="built_in">mkdir</span> -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DTRT_LIB_DIR=<span class="variable">$TRT_LIBPATH</span> -DTRT_OUT_DIR=`<span class="built_in">pwd</span>`/out</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>

<p> cmake 遇到部分警告，make 遇到错误。而且报错似乎是代码方面的错误，多方查阅也没有解决。放弃。</p>
</li>
<li><p>第二天，由于 NVIDIA 的 GitHub  <a href="https://github.com/NVIDIA/TensorRT#build">TensorRT Build</a> 的教程所给示例都是Ubuntu的，并且 英伟达官网的 CUDA 也没有提供 Archlinux 版本。怀疑是不是因为系统的原因。今天尝试降级 cuda 发现下载速度不再缓慢，于是换成上面第二个方案。</p>
</li>
<li><p>使用 yay 安装 tensorRT 安装的是 tensorrt-10.1.0.27-1 版本，查看对应的 cuda 版本为 cuda-12.4.0 + cuDNN-8.9，两个都降级到对应版本。yay 安装。</p>
<p> 有警告，单线程很慢，但是好得没报错，突然想起一个问题，在 NVIDIA 的 GitHub  <a href="https://github.com/NVIDIA/TensorRT#build">TensorRT Build</a> 的教程中让安装了 <a href="https://developer.nvidia.com/downloads/compute/machine-learning/tensorrt/10.2.0/tars/TensorRT-10.2.0.19.Linux.x86_64-gnu.cuda-12.5.tar.gz">TensorRT 10.2.0.19 for CUDA 12.5, Linux x86_64</a> ，这个东西当时我在使用 yay 安装 TrnsorRT 时没有安装，也看到 <a href="https://ivonblog.com/posts/archlinux-install-nvidia-drivers/">这篇帖子</a> 说到这点：</p>
<blockquote>
<ol>
<li>因為軟體授權限制，無法直接用yay裝，需要手動複製AUR儲存庫</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S base-devel</span><br><span class="line">git <span class="built_in">clone</span> https://aur.archlinux.org/tensorrt.git</span><br></pre></td></tr></table></figure>

<ol>
<li>然後到<a href="https://developer.nvidia.com/nvidia-tensorrt-download"> Nvidia官網</a>註冊帳號，下載<code>tar.gz</code>檔(注意版本需跟CUDA一致)，放到<code>tensorrt</code>目錄</li>
</ol>
</blockquote>
<p> 原文就是繁体，这里说的去官网注册账号下载<code>tar.gz</code>檔说的就是 <a href="https://developer.nvidia.com/downloads/compute/machine-learning/tensorrt/10.2.0/tars/TensorRT-10.2.0.19.Linux.x86_64-gnu.cuda-12.5.tar.gz">TensorRT 10.2.0.19 for CUDA 12.5, Linux x86_64</a> 这个东西，叫作 TensorRT GA ，在 TensorRT 安装时需要指定 TensorRT GA 发布构建路径。</p>
<p> 所以在我在上面安装了 TensorRT GA 并将其路径添加到 ~&#x2F;.zshrc 之后，重新使用 yay 安装就成功了（当时没有发现错误是因为没有找到 TensorRT GA 是因为什么，它没写？还是我没仔细看，绕了一大圈），后来发现 CUDA 版本也是最新版，依然可以使用 yay 安装。（也就是说不用降级也可以，高版本 CUDA 是支持低版本 TensorRT 的）。</p>
<p> 所以总结一下 CUDA 通过 yay 直接安装，TensorRT 在通过 yay 安装之前需要先安装  <a href="https://developer.nvidia.com/downloads/compute/machine-learning/tensorrt/10.2.0/tars/TensorRT-10.2.0.19.Linux.x86_64-gnu.cuda-12.5.tar.gz">TensorRT 10.2.0.19 for CUDA 12.5, Linux x86_64</a> 并设置环境变量指定路径。之后也可以通过 yay 安装。 </p>
<p> 回顾一下 Archlinux AUR 的 <a href="https://aur.archlinux.org/packages/tensorrt">tensorrt</a> 软件包下一个老哥的评论上说明的两个问题，第一个问题：</p>
<p>  CUDA 12.4 适用于 TensorRT 10.1.0.27。 CUDA 12.5 适用于 TensorRT 10.2.0.19。1我这里下载的是后者，后面<code>tensorrt_yolo</code>指定的路径也是 TensorRT 10.2.0.19 。</p>
<p> 第二个问题是英伟达没有提供驱动，这个问题已经解决了，目前最新的驱动已经支持。</p>
<p> 不管如何 CUDA 和 TensorRT 总算是装好了。</p>
</li>
</ol>
<h2 id="tensorrt-yolo"><a href="#tensorrt-yolo" class="headerlink" title="tensorrt_yolo"></a><code>tensorrt_yolo</code></h2><p><a href="https://github.com/laugh12321/TensorRT-YOLO/blob/main/docs/cn/build_and_install.md">TensorRT-YOLO&#x2F;docs&#x2F;cn&#x2F;build_and_install.md </a></p>
<h2 id="Deploy-编译"><a href="#Deploy-编译" class="headerlink" title="Deploy 编译"></a><code>Deploy</code> 编译</h2><p>按照上面给的文档进行编译安装。</p>
<p>本机环境：</p>
<ul>
<li>Linux: gcc&#x2F;g++	13.3.0（不知道上面降级和使用旧的 gcc 是否有影作用）</li>
<li>Xmake	v2.9.3+20240624</li>
<li>CUDA 	12.5.1-1</li>
<li>TensorRT	10.1.0.27-1</li>
</ul>
<p>为了满足部署需求，您可以使用 Xmake 进行 <code>Deploy</code> 编译。此过程支持动态库和静态库的编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/laugh12321/TensorRT-YOLO</span><br><span class="line"><span class="built_in">cd</span> TensorRT-YOLO</span><br><span class="line">xmake f -k shared --tensorrt=<span class="string">&quot;C:/Program Files/NVIDIA GPU Computing Toolkit/TensorRT/v8.6.1.6&quot;</span></span><br><span class="line"><span class="comment"># xmake f -k static --tensorrt=&quot;C:/Program Files/NVIDIA GPU Computing Toolkit/TensorRT/v8.6.1.6&quot;</span></span><br><span class="line">xmake -P . -r</span><br></pre></td></tr></table></figure>

<p><code>--tensorrt=&quot;C:/Program Files/NVIDIA GPU Computing Toolkit/TensorRT/v8.6.1.6&quot;</code>的路径替换为自己的路径，这个路径经过我的探索，最后发现实际在 <a href="https://developer.nvidia.com/downloads/compute/machine-learning/tensorrt/10.2.0/tars/TensorRT-10.2.0.19.Linux.x86_64-gnu.cuda-12.5.tar.gz">TensorRT 10.2.0.19 for CUDA 12.5, Linux x86_64</a> 下，在我这里是：<code>your_path/TensorRT-10.2.0.19/targets/x86_64-linux-gnu/</code> </p>
<h2 id="编译安装-tensorrt-yolo"><a href="#编译安装-tensorrt-yolo" class="headerlink" title="编译安装 tensorrt_yolo"></a>编译安装 <code>tensorrt_yolo</code></h2><p>跳过 PyPI 安装 <code>tensorrt_yolo</code> 模块部分。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install --upgrade build</span><br><span class="line">python -m build --wheel</span><br><span class="line">pip install dist/tensorrt_yolo/tensorrt_yolo-4.*-py3-none-any.whl</span><br></pre></td></tr></table></figure>

<p>上面是文档给的步骤，在 TensorRT-YOLO下 执行，第三个路径在我这里不争取。我这里对应的文件是是：<code>TensorRT-YOLO/dist/tensorrt_yolo-4.0.0-py3-none-any.whl</code> ，因此路径写<code> dist/tensorrt_yolo-4.0.0-py3-none-any.whl</code>。</p>
<h2 id="跑模型推理示例"><a href="#跑模型推理示例" class="headerlink" title="跑模型推理示例"></a>跑模型推理示例</h2><p>按照 <a href="https://github.com/laugh12321/TensorRT-YOLO/blob/main/demo/detect/README.md">模型推理示例</a> 进行。</p>
<h3 id="模型导出"><a href="#模型导出" class="headerlink" title="模型导出"></a>模型导出</h3><p>首先，从 <a href="https://github.com/ultralytics/assets/releases/download/v8.2.0/yolov8s.pt">YOLOv8s</a> 下载 YOLOv8s 模型并保存到 <code>models</code> 文件夹中。</p>
<p>注：上面是原文，这里的 <code>models</code> 文件夹经过我实际测试，实际上是<code>/TensorRT-YOLO/demo/detect/</code>下的 models 文件夹。同时工作目录现在默认也是<code>/TensorRT-YOLO/demo/detect/</code>。</p>
<p>然后，使用以下指令将模型导出为带有 <a href="https://github.com/NVIDIA/TensorRT/tree/main/plugin/efficientNMSPlugin">EfficientNMS</a> 插件的 ONNX 格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trtyolo <span class="built_in">export</span> -w yolov8s.pt -v yolov8 -o models</span><br></pre></td></tr></table></figure>

<p>执行以上命令后，将在 <code>models</code> 文件夹下生成名为 <code>yolov8s.onnx</code> 的文件。然后，使用 <code>trtexec</code> 工具将 ONNX 文件转换为 TensorRT engine：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trtexec --onnx=models/yolov8s.onnx --saveEngine=models/yolov8s.engine --fp16</span><br></pre></td></tr></table></figure>

<p>到这里都没哟遇到什么错误，第二个命令运行时我这里看起来像卡住了一样，不过最终是跑通了的。</p>
<h3 id="模型推理"><a href="#模型推理" class="headerlink" title="模型推理"></a>模型推理</h3><p>这里只讲 C++ 部分。</p>
<p>使用 C++ 进行推理前，请确保您已按照 <a href="https://github.com/laugh12321/TensorRT-YOLO/blob/main/docs/cn/build_and_install.md#deploy-%E7%BC%96%E8%AF%91">Deploy 编译指南</a> 对 Deploy 进行了编译。</p>
<p>接着，使用 xmake 将 <code>detect.cpp</code> 编译为可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake f -P . --tensorrt=<span class="string">&quot;/path/to/your/TensorRT&quot;</span> --deploy=/path/to/your/TensorRT-YOLO</span><br><span class="line"></span><br><span class="line">xmake -P . -r</span><br></pre></td></tr></table></figure>

<p>注：上面是原文，这里的 <code>&quot;/path/to/your/TensorRT&quot;</code> 就是前面安装的   <a href="https://developer.nvidia.com/downloads/compute/machine-learning/tensorrt/10.2.0/tars/TensorRT-10.2.0.19.Linux.x86_64-gnu.cuda-12.5.tar.gz">TensorRT 10.2.0.19 for CUDA 12.5, Linux x86_64</a> 下的一个路径，<code>your_path/TensorRT-10.2.0.19/targets/x86_64-linux-gnu/</code>。后面的 deploy 路径就是你的 TensorRT-YOLO 路径。</p>
<p>在执行上述命令后，将在根目录的 <code>build</code> 目录下生成名为 <code>detect</code> 的可执行文件。最后，您可以直接运行可执行文件或使用 <code>xmake run</code> 命令进行推理。使用 <code>--help</code> 查看详细指令选项：</p>
<p>注；上面是原文，我这里生成的 <code>detect</code> 的可执行文件位于<code>/TensorRT-YOLO/demo/detect/build/linux/x86_64/release/</code>下，同时还有一个<code>libdeploy.so</code>文件也在这个目录下。</p>
<blockquote>
<p>要加速推理过程，请使用 <code>--cudaGraph</code> 指令，但此功能仅支持静态模型，不支持动态模型。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake run -P . detect -e models/yolov8s.engine -i images -o output -l labels.txt --cudaGraph</span><br></pre></td></tr></table></figure>

<p>注：这里命令中的路径一定要正确，工作目录在 <code>/TensorRT-YOLO/demo/detect/</code> 下时，为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build/linux/x86_64/release/detect -e models/yolov8s.engine -i images -o output -l labels.txt --cudaGraph</span><br></pre></td></tr></table></figure>

<p>使用 xmake run 的命令没去试，直接运行 detect 就行了。输出图像在 output 文件夹下，生成文本描述<code>labels.txt</code>。</p>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>Arch Linux 安装 openpose 踩坑记录</title>
    <url>/2024/07/13/Arch%20Linux%20%E5%AE%89%E8%A3%85%20openpose%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Arch-Linux-安装-openpose-踩坑记录"><a href="#Arch-Linux-安装-openpose-踩坑记录" class="headerlink" title="Arch Linux 安装 openpose 踩坑记录"></a>Arch Linux 安装 openpose 踩坑记录</h1><p>尝试在 Arch Linux 上安装 <a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose">CMU-Perceptual-Computing-Lab&#x2F;openpose</a></p>
<ol>
<li>使用 <code>yay -S openpose</code>安装遇到错误：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407220937920.png" alt="image-20240722093728360"></p>
<p>在 AUR 的 <a href="https://aur.archlinux.org/packages/openpose">openpose软件包</a> 评论下找到可能的解决办法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407220941911.png" alt="image-20240722094126178"></p>
<p>没有找到 yay 安装时的具体错误位置，错误似乎相似，开始尝试：</p>
<p>没有找的这个文件，并且在 AUR 中的多个 caffe 都安装失败，也没有找到 abseillts 这个软件包。</p>
<ol start="2">
<li>尝试从源代码构建</li>
</ol>
<p>根据教程走，遇到问题</p>
<p><img src="/home/Yuanmxc/Pictures/md_pictures/image-20240722105914105.png" alt="image-20240722105914105"></p>
<p>缺少 atlas-lapack 包，使用 yay 安装，遇到问题</p>
<p><img src="/home/Yuanmxc/Pictures/md_pictures/image-20240722110031689.png" alt="image-20240722110031689"></p>
<p>在 AUR 的 atlas-lapack 软件包评论下找到解决方案：</p>
<p><img src="/home/Yuanmxc/Pictures/md_pictures/image-20240722110139489.png" alt="image-20240722110139489"></p>
<p>参照解决办法注释警告行：</p>
<p><img src="/home/Yuanmxc/Pictures/md_pictures/image-20240722110216233.png" alt="image-20240722110216233"></p>
<p>重新安装，报新的错误（部分节选）：</p>
<p><img src="/home/Yuanmxc/Pictures/md_pictures/image-20240722110343284.png" alt="image-20240722110343284"></p>
<p><img src="/home/Yuanmxc/Pictures/md_pictures/image-20240722110357882.png" alt="image-20240722110357882"></p>
<p>根据最后的大段提示，其中部分提到</p>
<blockquote>
<p>CPU Throttling apparently enabled!<br>It appears you have cpu throttling enabled, which makes timings<br>unreliable and an ATLAS install nonsensical.</p>
<p>If your machine has OS throttling enabled, it is critical that you disable<br>it (with something like cpufreq-set). </p>
<p>如果您的机器启用了操作系统节流，则必须禁用它（使用类似 cpufreq-set 的命令）。有关详细信息，请参阅 INSTALL.txt。</p>
<p>翻译：</p>
<p>CPU 节流显然已启用！<br>看来您已启用 CPU 节流，这会使计时不可靠，ATLAS 安装毫无意义。</p>
<p>如果您的机器启用了操作系统节流，则必须禁用它（使用类似 cpufreq-set 的命令）。有关详细信息，请参阅 INSTALL.txt。</p>
</blockquote>
<p>应该是指定评论提到的问题（我在解决上一个问题之前已经按照上面的做法做了，但是仍然报这个错误。再做一遍）：</p>
<p>编辑：<code>/etc/default/grub</code>中的内容，修改以下行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;intel_pstate=disable&quot;</span></span><br></pre></td></tr></table></figure>

<p>评论是这么写的，但是我仅仅是把<code>intel_pstate=disable</code>添加到了末尾。</p>
<p>更新 grub ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>

<p>启用 acpi-cpufreq 模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su root <span class="comment"># 切换到 root 用户</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;acpi-cpufreq&quot;</span> &gt; /etc/modules-load.d/acpi-cpufreq.conf</span><br><span class="line">restart</span><br><span class="line"><span class="built_in">exit</span> <span class="comment"># 退出 root 用户</span></span><br></pre></td></tr></table></figure>

<p>找到问题所在了，原评论中写：</p>
<blockquote>
<p>And then enable acpi-cpufreq module: su root echo “acpi-cpufreq” &gt; &#x2F;etc&#x2F;modules-load.d&#x2F;acpi-cpufreq.conf restart.</p>
</blockquote>
<p>他把所有命令都写在了一行，我在终端执行的命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;acpi-cpufreq&quot;</span> &gt; /etc/modules-load.d/acpi-cpufreq.conf restart</span><br></pre></td></tr></table></figure>

<p>我查看 <code>/etc/modules-load.d/acpi-cpufreq.conf</code> 发现其中内容是 <code>acpi-cpufreq restart</code> ，所以评论者的意思应该是把<code>acpi-cpufreq</code>写入，然后重启系统的意思。</p>
<p>现在cpupower可以正确设置频率了。禁用 throtling:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S cpupower </span><br><span class="line"><span class="comment"># 这里原评论</span></span><br><span class="line"><span class="built_in">sudo</span> cpupower frequency-set -g Performance </span><br><span class="line"><span class="comment"># 下面是输出：</span></span><br><span class="line">Setting cpu: 0</span><br><span class="line">Setting cpu: 1</span><br><span class="line">Setting cpu: 2</span><br><span class="line">Setting cpu: 3</span><br><span class="line">Setting cpu: 4</span><br><span class="line">Setting cpu: 5</span><br><span class="line">Setting cpu: 6</span><br><span class="line">Setting cpu: 7</span><br><span class="line">Setting cpu: 8</span><br><span class="line">Setting cpu: 9</span><br><span class="line">Setting cpu: 10</span><br><span class="line">Setting cpu: 11</span><br><span class="line">Setting cpu: 12</span><br><span class="line">Setting cpu: 13</span><br><span class="line">Setting cpu: 14</span><br><span class="line">Setting cpu: 15</span><br></pre></td></tr></table></figure>

<p>这里应该就是应用于所有核心了。完成</p>
<p>但问题还是没有解决，给的教程是基于 intel cpu 的 ，前面编辑<code>/etc/default/grub</code>禁用的是 <code>intel_pstate</code> ，而我使用的是 AMD。</p>
<p>多方查找无果，放弃。</p>
<p>总结一下问题：</p>
<p>yay 安装 openpose 出错，需要两个包，其中一个是 caffe ，尝试使用 yay 安装 caffe </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S caffe-cuda <span class="comment"># 使用GPU加速版本</span></span><br></pre></td></tr></table></figure>

<p>报错：和 glog 有关，查了一下可能是版本问题，使用 downgrade 降级 glog：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> downgrade google-glog</span><br></pre></td></tr></table></figure>

<p>从 0.7.0 降级到 0.6.0 ，重新安装，原本错误不再报。新错误找不到头文件 <code>&lt;opencv2/core/core.hpp&gt;</code>，查了一下，头文件实际位于：<code>/usr/include/opencv4/opencv2/core/core.hpp</code>，把<code>/usr/include/opencv4/</code>添加到 g++ 编译器的头文件搜索路径中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc <span class="comment"># 使用 bash 就是~/.bashrc</span></span><br><span class="line"><span class="comment"># 添加下面一行，保存并退出</span></span><br><span class="line"><span class="built_in">export</span> CPLUS_INCLUDE_PATH=/usr/include/opencv4:<span class="variable">$CPLUS_INCLUDE_PATH</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc <span class="comment"># 使修改立即生效</span></span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>Arch Linux 安装和使用 MySQL（MariaDB）</title>
    <url>/2023/08/28/Arch%20Linux%20%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%20MySQL%EF%BC%88MariaDB%EF%BC%89/</url>
    <content><![CDATA[<p>好的！以下是扩展后的博客内容，新增了安全加固、常用命令、备份恢复、远程访问配置等内容，保持了原有的技术文档风格：</p>
<hr>
<h1 id="Arch-Linux-安装和使用-MySQL（MariaDB）"><a href="#Arch-Linux-安装和使用-MySQL（MariaDB）" class="headerlink" title="Arch Linux 安装和使用 MySQL（MariaDB）"></a>Arch Linux 安装和使用 MySQL（MariaDB）</h1><h2 id="安装-MariaDB-和客户端工具"><a href="#安装-MariaDB-和客户端工具" class="headerlink" title="安装 MariaDB 和客户端工具"></a>安装 MariaDB 和客户端工具</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S mariadb mariadb-clients</span><br></pre></td></tr></table></figure>

<h2 id="初始化数据目录"><a href="#初始化数据目录" class="headerlink" title="初始化数据目录"></a>初始化数据目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mariadb-install-db --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><br><span class="line"><span class="comment"># 输出提示包含初始化完成信息</span></span><br></pre></td></tr></table></figure>

<h2 id="启动与开机自启"><a href="#启动与开机自启" class="headerlink" title="启动与开机自启"></a>启动与开机自启</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start mysqld          <span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> mysqld         <span class="comment"># 设置开机自启动（可以不设置）</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status mysqld         <span class="comment"># 查看服务状态（注意服务名是mysqld）</span></span><br></pre></td></tr></table></figure>

<h2 id="安全加固"><a href="#安全加固" class="headerlink" title="安全加固"></a>安全加固</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mysql_secure_installation</span><br><span class="line"><span class="comment"># 按提示操作：删除匿名用户/禁止远程root登录/删除测试数据库等</span></span><br></pre></td></tr></table></figure>

<h2 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mariadb-admin -u root password <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mariadb -uroot -p</span><br><span class="line"><span class="comment"># 输入密码后进入交互界面</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="常用操作命令"><a href="#常用操作命令" class="headerlink" title="常用操作命令"></a>常用操作命令</h2><h3 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;                     <span class="comment">-- 列出所有数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE mydb;               <span class="comment">-- 创建数据库</span></span><br><span class="line">USE mydb;                           <span class="comment">-- 切换数据库</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE mydb;                 <span class="comment">-- 删除数据库</span></span><br></pre></td></tr></table></figure>

<h3 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a>用户与权限</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;user1&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;pass123&#x27;</span>; <span class="comment">-- 创建本地用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;user1&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;   <span class="comment">-- 授权所有权限</span></span><br><span class="line">FLUSH PRIVILEGES;                   <span class="comment">-- 刷新权限生效</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>,host <span class="keyword">FROM</span> mysql.user;   <span class="comment">-- 查看用户列表</span></span><br></pre></td></tr></table></figure>

<h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;                        <span class="comment">-- 显示当前数据库所有表</span></span><br><span class="line"><span class="keyword">DESC</span> mytable;                       <span class="comment">-- 查看表结构</span></span><br><span class="line">SOURCE <span class="operator">/</span>path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>backup.sql;         <span class="comment">-- 导入SQL文件</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数据备份与恢复"><a href="#数据备份与恢复" class="headerlink" title="数据备份与恢复"></a>数据备份与恢复</h2><h3 id="备份整个数据库"><a href="#备份整个数据库" class="headerlink" title="备份整个数据库"></a>备份整个数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mysqldump -u root -p --all-databases &gt; full_backup.sql</span><br></pre></td></tr></table></figure>

<h3 id="恢复数据库"><a href="#恢复数据库" class="headerlink" title="恢复数据库"></a>恢复数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mariadb -u root -p &lt; full_backup.sql</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="配置远程访问（谨慎操作）"><a href="#配置远程访问（谨慎操作）" class="headerlink" title="配置远程访问（谨慎操作）"></a>配置远程访问（谨慎操作）</h2><ol>
<li><p>修改配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/my.cnf.d/server.cnf</span><br></pre></td></tr></table></figure>
<p>在 <code>[mysqld]</code> 段添加：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">bind-address</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建远程用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;remote&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;StrongPass!&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;remote&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开放防火墙：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 3306/tcp</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="故障排查技巧"><a href="#故障排查技巧" class="headerlink" title="故障排查技巧"></a>故障排查技巧</h2><ol>
<li><p>查看错误日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> journalctl -u mysqld -xe</span><br></pre></td></tr></table></figure>
</li>
<li><p>重置root密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop mysqld</span><br><span class="line"><span class="built_in">sudo</span> mysqld_safe --skip-grant-tables &amp;</span><br><span class="line">mariadb -u root</span><br><span class="line"><span class="comment"># 执行 UPDATE mysql.user SET password=PASSWORD(&#x27;newpass&#x27;) WHERE user=&#x27;root&#x27;;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h2><ol>
<li><p>安装内存优化工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S mysqltuner</span><br><span class="line">mysqltuner --user root --pass</span><br></pre></td></tr></table></figure>
</li>
<li><p>调整配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/my.cnf.d/custom.cnf</span><br></pre></td></tr></table></figure>
<p>添加优化参数：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_size</span> = <span class="number">1</span>G</span><br><span class="line"><span class="attr">query_cache_type</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">thread_cache_size</span> = <span class="number">8</span> </span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>C++ Primer 笔记</title>
    <url>/2022/08/16/C++%20Primer%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C-Primer-笔记"><a href="#C-Primer-笔记" class="headerlink" title="C++ Primer 笔记"></a>C++ Primer 笔记</h1><p>注意：本文并不是教你学 C++，这只是笔者阅读 《C++ primer》这本书的过程中记录的相关知识，适用于已经对 C++有所了解的读者进行复习和查询，读者至少对 C 和 C++有所了解。</p>
<h2 id="逐页阅读小记"><a href="#逐页阅读小记" class="headerlink" title="逐页阅读小记"></a>逐页阅读小记</h2><h3 id="第-2-章-变量和基本类型"><a href="#第-2-章-变量和基本类型" class="headerlink" title="第 2 章 变量和基本类型"></a>第 2 章 变量和基本类型</h3><ol>
<li><p>有符号和无符号一起用，有符号转无符号。</p>
</li>
<li><p>double（一般 16 有效位）一般和 float（一般 7 有效位）运算代价相同，用 double 即可。</p>
</li>
<li><p>char16_t 和 char32_t 为 Unicode 字符，包含所有自然语言字符。</p>
</li>
<li><p>泛化的转义序列：<code>\x</code> 后跟 1 或多个十六进制数字或者 <code>\</code> 后跟多个八进制数字：<code>\12</code>（换行符）<code> \x4d</code>（字符 M）</p>
</li>
<li><p>初始化不是赋值，定义变量时若未指定初始值，变量被 <strong>默认初始化</strong>，“默认值”由变量类型和定义位置决定。定义在任何函数体之外的内置类型变量会被默认初始化为 0，定义在函数体内部的内置类型变量不被初始化，它的值是未定义的。每个类各自决定初始化对象的方式。</p>
</li>
<li><p>声明使得名字为程序所知，定义负责创建于名字关联的实体。变量能且只能被定义一次，但是可以被多次声明。任何包含了显式初始化的声明即成为定义。多个文件使用同一变量，只能有一个定义，其他文件必须声明才能使用，决不能定义该变量。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i；  <span class="comment">// 声明 i 而非定义 i</span></span><br><span class="line"><span class="type">int</span> j；         <span class="comment">// 声明并定义 j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.1415926</span>； <span class="comment">// 定义，extern 作用被抵消</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用只是一个已经存在的对象的另一个名字，它和它的初始值（一个对象）一直绑定在一起，必须被初始化。对引用的操作就是对于它绑定的对象的操作（可以视为替换）。引用本身不是对象，无法定义引用的引用和指针。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival;</span><br><span class="line">refVal = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>::</code> 作用域运算符，使用 <code>::reuserd</code> 的方式可以访问被局部变量覆盖的全局变量，全局作用域本身没有名字，所以 <code>::</code> 左侧为空时会向全局作用域发起请求。</p>
</li>
<li><p>把 int 变量直接赋给指针是错误的操作，即使他的值为 0。</p>
</li>
<li><p>对指针的引用：</p>
</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;r = p;</span><br><span class="line">r = &amp;i;  <span class="comment">// 令 p 指向 i</span></span><br><span class="line">*r = <span class="number">0</span>;  <span class="comment">// 将 p 指向的变量 i 的值改为 0</span></span><br></pre></td></tr></table></figure>

<ol start="11">
<li><ul>
<li><p>当以编译时初始化的方式定义一个 const 对象时，例如：<code>const int bufSize = 512;</code>，编译器会将在编译过程中用到该变量的地方都替换成对应的值。</p>
</li>
<li><p>默认状态下，const 对象被设定为仅在文件内有效。当多个文件中出现同名 const 变量时，等同于在不同文件中分别定义了独立的变量</p>
</li>
<li><p>当希望 const 变量初始值不是常量表达式，但需要在文件间共享，即和其他对象一样，只在一个地方定义 const 变量，而在其他多个文件中声明并使用它，则不管是声明还是定义都添加 extern 关键字，这样只需要定义一次就可以了。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file_1.cc 定义并初始化了一个常量，该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">// file_1.h 头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;  <span class="comment">// 与 file_1.cc 中定义的 bufSize 是同一个</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>对 const 对象的引用称之为对常量的引用（<strong>常量引用</strong>）。不能让一个非常量引用指向一个常量对象。</p>
</li>
<li><p>一般来说引用的类型应该与其所引用的对象的类型一致，但有下面两个例外：</p>
<ul>
<li><p>对 const 的引用可能引用一个并非 const 的对象。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r1 = i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i; <span class="comment">// r2 绑定对象 i 但是不允许通过 r2 修改 i 的值。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化常量引用时允许使用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可，尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是一个表达式：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> i = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i;      <span class="comment">// 正确，double 可以转换成 int，常量引用可以绑定非常量对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;     <span class="comment">// 正确：r2 是一个常量引用，可以绑定字面值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>; <span class="comment">// 正确：r3 是一个常量引用，可以绑定表达式</span></span><br><span class="line"><span class="type">int</span> &amp;r4 = r1 *<span class="number">2</span>         <span class="comment">// 错误：r4 是一个普通的非常量引用</span></span><br></pre></td></tr></table></figure>

<p>  以上面第 1、2 行代码为例，当一个常量引用被绑定到另一种类型上时，编译器把 i 转化一个整形常量 3，这个 3 是一个临时量对象，是编译器需要的一个用来暂存表达式求值结果时临时创建的一个未命名的对象。</p>
</li>
</ul>
</li>
<li><p>一般来说指针的类型应该与其所指对象的类型一致，但有下面两个例外：</p>
<ul>
<li>允许一个指向常量的指针指向另一个非常量的对象。</li>
<li>常量指针可以指向非常量对象。</li>
</ul>
</li>
<li><p><strong>顶层 const</strong> 表示指针本身是一个常量，<strong>底层 const</strong> 表示指针所值的对象是一个常量。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换，一般来说，非常量可以转换成常量，反之则不行。</p>
</li>
<li><p>将变量声明为 constexptr 类型，让编译器来验证变量的值是否是一个常量表达式（值不会改变且在编译过程就能得到计算结果的表达式）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> =<span class="type">int</span> mf = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义类型别名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;    <span class="comment">// wages 是 double 的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wasges base, *p; <span class="comment">// base 是 double 的同义词，p 是 double*的同义词</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item;   <span class="comment">// SI 是 Sales_item 的同义词</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>简单的把类型别名替换成它原本样子可能是错误的，后两句如果进行简单的文本替换，基本数据类型变为 const char .</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *cstr = <span class="number">0</span>; <span class="comment">// 声明的是一个指向 const char 的指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;  <span class="comment">// pstring 的类型是指向 char 的指针</span></span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// cstr 是指向 char 的常量指针</span></span><br><span class="line"><span class="type">const</span> pstring *ps;      <span class="comment">// ps 是一个指针，他指向的对象是一个指向 char 的常量指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>auto 一般会忽略掉 <strong>顶层 const</strong> ，同时 <strong>底层 const</strong> 会被保留。想保留，需要用 const atuo 。设置一个类型为 auto 的引用时，初始值中的顶层常量属性仍然被保留。</p>
</li>
<li><p>decltype ( ) 返回（）中表达式的类型。如果 decltype 使用的表达式是一个变量，则 decltype 返回该变量的类型（包括顶层 const 和引用在内）。如果表达式的内容是解引用操作，则 decltype 将得到引用类型。decltype 使用的表达式是变量，该变量是否有括号会影响结果，如果无括号，得到的类型是该变量的类型，如果有括号，得到的是该变量对应的引用类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span> (<span class="built_in">f</span>()) sum = x; <span class="comment">// sum 的类型就是函数 f 的返回类型，编译器并不实际调用 f()</span></span><br><span class="line"><span class="comment">// decltype 的结果可以是引用类型</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>） b; <span class="comment">// 正确：加法的结果是 int, 因此 b 是一个(未初始化的)int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;     <span class="comment">// 错误：*p 的类型是 int，但他是解引用操作，所以 c 的类型是 int&amp;, 必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d;    <span class="comment">// 错误：使用(i)得到的是 int&amp; 类型，必须初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>头文件保护符 <code>#ifndef</code> 、<code>#ifdef</code>、<code>#endif</code> 应该包含在头文件中，即使头文件（目前还）没有被包含在任何其他头文件中。头文件不应该使用 using 声明。</p>
</li>
<li><p>string 字符串使用字符串字面值初始化时，不包含字符串字面值最后隐藏的空字符，字符串字面值实际上包含写出来的字符和隐藏的空字符。</p>
</li>
<li><p>cin 在读取 string 时，string 对象会自动忽略开头的空白（空格符、换行符、制表符等），并从第一个真正的字符开始读起，直到遇见下一次处空白为止。</p>
</li>
<li><p><code>getline(cin, line)</code> 读取一整行，参数是一个输入流和一个 string 对象，函数从输入流中读入内容，直到遇到换行符为止（换行符也被读进来了），然后把所读的对象存入到 string 对象中（但是不存读入的换行符）。如果一开始就输入换行符，那么得到空 string。触发 getline 函数返回的换行符实际上被丢掉了。</p>
</li>
</ol>
<h3 id="第-3-章-字符串、向量和数组"><a href="#第-3-章-字符串、向量和数组" class="headerlink" title="第 3 章 字符串、向量和数组"></a>第 3 章 字符串、向量和数组</h3><ol>
<li><p>sting 操作中的 size() 等函数，返回的数字类型配套的，<code>size()</code> 返回 <code>string:: size_type</code> 类型，一个无符号整型，使用 <code>auto</code> 或者 <code>decltype()</code> 推断变量类型来存比较好。注意无符号整型和有符号整型混用的问题。</p>
</li>
<li><p>string 比较规则：返回两个 string 对象第一个不同字符的比较结果，若全相同，则长的大。</p>
</li>
<li><p>当把 string 对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符的两侧的运算对象至少有一个是 string，字符串字面值不是 string 对象。</p>
</li>
<li><p>string 的下标运算符接收的参数是 string:: size_type 类型的值，返回值是该位置上字符的引用。在范围 for 语句中也需要使用引用来修改 string 中的字符，使用 char 的话没有改变原 string 对象。</p>
</li>
<li><p><strong>string</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">string s1;                    <span class="comment">// 默认初始化，空字符串</span></span><br><span class="line">string s2 = <span class="string">&quot;&quot;</span>;               <span class="comment">// 拷贝初始化，空字符串</span></span><br><span class="line">string s3 = <span class="string">&quot;hello&quot;</span>;          <span class="comment">// 拷贝初始化</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;           <span class="comment">// 拷贝初始化，使用构造函数定义并初始化字符串</span></span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)</span></span>;            <span class="comment">// 直接初始化，是十个 c 的字符串</span></span><br><span class="line">string s6 = <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)    <span class="comment">// 拷贝初始化，创建了一个临时对象然后拷贝给 s6</span></span><br><span class="line"><span class="comment">// 成员函数</span></span><br><span class="line">s[n]          <span class="comment">// 返回 n 位置上的字符的引用</span></span><br><span class="line">s.<span class="built_in">empty</span>()     <span class="comment">// s 是否为空，空为真，不空为假</span></span><br><span class="line">s.<span class="built_in">length</span>()    <span class="comment">// 或者 s.size()，返回 s 中字符个数</span></span><br><span class="line">s.<span class="built_in">at</span>(n);      <span class="comment">// 返回下标为 n 的字符</span></span><br><span class="line">s.<span class="built_in">find</span>(<span class="string">&quot;ld&quot;</span>); <span class="comment">// 返回 &quot;ld&quot; 在字符串中的位置 n</span></span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">6</span>, <span class="number">5</span>, <span class="string">&quot;there&quot;</span>);     <span class="comment">// 把 &quot;world&quot; 替换成 &quot;there&quot;</span></span><br><span class="line">s.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 返回 i 字符串的前 5 个字符组成的字符串</span></span><br><span class="line">s.<span class="built_in">substr</span>(<span class="number">6</span>);    <span class="comment">// 返回从字符串的第 7 个字符到末尾的字符组成的字符串</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">6</span>, <span class="string">&quot;there&quot;</span>);         <span class="comment">// 在下标为 6 的位置插入 there“，后面字符顺延</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">6</span>, <span class="number">1</span>, <span class="string">&#x27;-&#x27;</span>);          <span class="comment">// 在第 6 个位置插入 &#x27;-&#x27;，后面字符顺延</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用花括号初始化 vector 对象时，会优先使用列表初始化，提供的值必须与元素类型相同，如果不同，无法执行列表初始化，编译器会尝试使用默认初始化 vector 对象。</p>
</li>
<li><p>一般创建一个空的 vector ，再向里面添加元素更好，直接初始化可能性能更差，同时，如果改变了 vector 容量，不应使用范围 for 循环，范围 for 语句内不应该改变其所遍历序列的大小。不能使用下标形式为 vector 添加元素，只能对已存在的元素执行下标操作。</p>
</li>
<li><p>**类模板 vector **：</p>
<p> vector 定义在头文件中，需要包含，并位于 std 命名空间中。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">double</span>&gt; v;      <span class="comment">// 创建空容器</span></span><br><span class="line">vector&lt;string&gt; v1&#123;<span class="number">10</span>&#125;; <span class="comment">// 10 不是 string，使用默认初始化，初始化有 10 个 string 的 vectoer</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">v</span><span class="params">(<span class="number">20</span>， <span class="number">1.0</span>)</span></span>; <span class="comment">// 直接初始化有 20 个 double 的 vectoe，初始值均为 1.0, 没有第二个参数初始值默认均为 0，使用花括号也可</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; values2&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;; <span class="comment">// 指定元素个数和初始值</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">values3</span><span class="params">(values2)</span></span>;  <span class="comment">// 创建和 alces 相同的容器</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">values4</span><span class="params">(begin(value2,begin(v。alue2)<span class="number">+3</span>))</span> <span class="comment">// 使用指针或者迭代器来指定初始值范</span></span></span><br></pre></td></tr></table></figure>

<p> vector 容器包含的成员函数：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">begin</span>()	    <span class="comment">// 返回指向容器中第一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">end</span>()	    <span class="comment">// 返回指向容器最后一个元素所在位置后一个位置的迭代器。</span></span><br><span class="line"><span class="built_in">front</span>()	    <span class="comment">// 返回第一个元素的引用。</span></span><br><span class="line"><span class="built_in">back</span>()	    <span class="comment">// 返回最后一个元素的引用。</span></span><br><span class="line"><span class="built_in">data</span>()	    <span class="comment">// 返回指向容器中第一个元素的指针。</span></span><br><span class="line"><span class="built_in">assign</span>()    <span class="comment">// 用新元素替换原有内容。</span></span><br><span class="line"><span class="built_in">push_back</span>()	<span class="comment">// 在序列的尾部添加一个元素。</span></span><br><span class="line"><span class="built_in">pop_back</span>()	<span class="comment">// 移出序列尾部的元素。</span></span><br><span class="line"><span class="built_in">insert</span>()	<span class="comment">// 在指定的位置插入一个或多个元素。</span></span><br><span class="line"><span class="built_in">erase</span>()	    <span class="comment">// 移出一个元素或一段元素。</span></span><br><span class="line"><span class="built_in">clear</span>()	    <span class="comment">// 移出所有的元素，容器大小变为 0。</span></span><br><span class="line"><span class="built_in">rbegin</span>()  <span class="comment">// 返回指向最后一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">rend</span>()	  <span class="comment">// 返回指向第一个元素所在位置前一个位置的迭代器。</span></span><br><span class="line"><span class="built_in">cbegin</span>()  <span class="comment">// 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</span></span><br><span class="line"><span class="built_in">cend</span>()	  <span class="comment">// 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</span></span><br><span class="line"><span class="built_in">crbegin</span>() <span class="comment">// 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</span></span><br><span class="line"><span class="built_in">crend</span>()	  <span class="comment">// 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</span></span><br><span class="line"><span class="built_in">size</span>()	  <span class="comment">// 返回实际元素个数 类型是 vector &lt;T&gt;:: size_type，T 为 vector 存储的元素类型。</span></span><br><span class="line"><span class="built_in">max_size</span>()<span class="comment">// 返回元素个数的最大值。这通常是一个很大的值，一般是 2^32-1，所以我们很少会用到这个函数。</span></span><br><span class="line"><span class="built_in">resize</span>()  <span class="comment">// 改变实际元素的个数。</span></span><br><span class="line"><span class="built_in">capacity</span>()<span class="comment">// 返回当前容量。</span></span><br><span class="line"><span class="built_in">empty</span>()	  <span class="comment">// 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</span></span><br><span class="line"><span class="built_in">reserve</span>() <span class="comment">// 增加容器的容量。</span></span><br><span class="line">shrink _to_fit()  <span class="comment">// 将内存减少到等于当前元素实际所使用的大小。</span></span><br><span class="line"><span class="keyword">operator</span>[ ]	      <span class="comment">// 重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。</span></span><br><span class="line"><span class="built_in">at</span>()	        <span class="comment">// 使用经过边界检查的索引访问元素。</span></span><br><span class="line"><span class="built_in">swap</span>()	        <span class="comment">// 交换两个容器的所有元素。</span></span><br><span class="line"><span class="built_in">emplace</span>()	    <span class="comment">// 在指定的位置直接生成一个元素。</span></span><br><span class="line"><span class="built_in">emplace_back</span>()	<span class="comment">// 在序列尾部生成一个元素。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果容器为空，begin 和 end 都返回尾后迭代器。</p>
</li>
<li><p>标准容器迭代器的部分运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*it            <span class="comment">// 返回迭代器 it 所指元素的引用</span></span><br><span class="line">(*it).<span class="built_in">empty</span>()  <span class="comment">// it 指示一个 strng 类型并判断 string 是否为空，必须加()，否则先进行点运算</span></span><br><span class="line">it-&gt;<span class="built_in">empty</span>()    <span class="comment">// 解引用 it 并获取该元素的名为 mem 的成员，等价于(*it).empty()</span></span><br><span class="line">++it           <span class="comment">// 令 it 指示容器中的下一个元素</span></span><br><span class="line">--it           <span class="comment">// 令 it 指示容器中的上一个元素</span></span><br><span class="line">it1 == it2     <span class="comment">// 判断两个选代器是否相等，如果两个选代器指示的是同一个元素或者它们是同一个容器的尾后选代器，则相等；反之，不相等</span></span><br><span class="line">+、-、+=、-=、&lt;、&gt;、&lt;=、&gt;=</span><br></pre></td></tr></table></figure>
</li>
<li><p>某些对 vector 的操作（任何可能改变 vertor 对象容量的操作）会使迭代器失效，比如 push_back，不能在范围 for 循环中向 vector 对象添加元素。</p>
</li>
<li><p>遍历一个 vector ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// 范围 for 循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec)&#123;</span><br><span class="line">    cout &lt;&lt; element &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 索引遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">    cout &lt;&lt; vec[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用迭代器的二分搜索：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// text 必须是有序的</span></span><br><span class="line"><span class="comment">// beg 和 end 表示我们搜索的范围</span></span><br><span class="line"><span class="keyword">auto</span> beg = text.<span class="built_in">begin</span>(), end=text.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = text.<span class="built_in">begin</span>() + (end-beg)/<span class="number">2</span>; <span class="comment">// 初始状态下的中间点</span></span><br><span class="line"><span class="comment">// 当还有元素尚未检查并且我们还没有找到 sought 时执行循环</span></span><br><span class="line"><span class="keyword">while</span>(mid != end &amp;&amp; *mid != sought)</span><br><span class="line">     <span class="keyword">if</span> (sought &lt; *mid)        <span class="comment">// 如果要找的元素在前半部分</span></span><br><span class="line">         end = mid;            <span class="comment">// 新 end 为旧 mid，beg 不变</span></span><br><span class="line">      <span class="keyword">else</span>                     <span class="comment">// 否则，我们要找的元素在后半部分</span></span><br><span class="line">         beg = mid + <span class="number">1</span>         <span class="comment">// 新 beg 为旧 mid+1，end 不变</span></span><br><span class="line">     mid = beg + (end-beg)/<span class="number">2</span>；  <span class="comment">// 同样方法计算新的中间点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组的维度（元素个数）必须是常量表达式。默认情况下数据元素北默认初始化。字符数组使用字符串字面值初始化时，后面隐藏的 ‘\0’会被包含进去，空间不够时报错。数组不允许拷贝和赋值。</p>
</li>
<li><p>数组本身是对象，存放对象，不存在引用的数组，但存在数组的引用。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> cnt = <span class="number">42</span>;         <span class="comment">//不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> sz = <span class="number">42</span>;<span class="comment">//常量表达式</span></span><br><span class="line"><span class="type">int</span> *parr[sz];             <span class="comment">//含有 42 个整型指针的数组</span></span><br><span class="line">string bad[cnt];;          <span class="comment">//错误：cnt 不是常量表达式</span></span><br><span class="line">string strs[<span class="built_in">get_size</span>()];   <span class="comment">//当 get_size 是 constexpr 时正确；否则错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当数组作为一个 auto 变量的初始值时，推断得到的类型是指针而非数组；使用 decltype 关键字时返回的类型是数组。</p>
</li>
<li><p>标准库函数 begin() 和 end() 获取数组的首元素指针和尾元素下一指针。两个指针相减的结果类型是 ptrdiff_t 的标准库类型，是带符号类型。如果两个指针分别指向不相关的对象，不能比较他们，未定义行为。</p>
</li>
<li><p>使用数组下标等同于使用指针，同时内置的下标运算（数组下标）可以处理负值，但标准库类型 string 和 vector 的下标运算必须是无符号类型。</p>
</li>
<li><p>尽量少使用 C 风格字符串，内存管理麻烦，多用 string，string 的成员函数 c_str() 可以把 string 转化成 char*。</p>
</li>
<li><p>数组无法拷贝和赋值，不能用 vector 初始化数组，但可以用数组初始化 vector ，只需之名拷贝区域的首元素地址和尾后地址：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> int_arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;；</span><br><span class="line"><span class="comment">// ivec 有 6 个元素，分别是 intarr 中对应元素的副本</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; <span class="built_in">ivec</span>(<span class="built_in">begin</span>(int_arr）,<span class="built_in">end</span>(int_arr))；</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</p>
</li>
</ol>
<h3 id="第-4-章-表达式"><a href="#第-4-章-表达式" class="headerlink" title="第 4 章 表达式"></a>第 4 章 表达式</h3><ol>
<li>有 4 种运算符明确规定了运算对象的求值顺序。逻辑与（&amp;&amp;）运算符和逻辑或（||）运算符规定先求左侧运算对象的值，只有当左侧运算对象的值为真&#x2F;假时才继续求右侧运算对象的值。条件（ ?: ）运算符和逗号（ , ）运算符。其他运算符，如+ 、&gt;&gt; 等未规定左右运算对象的求值顺序，先求左右表达式中的哪一个都有可能。如果表达式影响同一对象，求值先后顺序对结果有影响，那么它是一个错误的表达式，将产生未定义行为。</li>
<li>布尔值不应该参与运算，大多数运算符会把布尔值提升为 int 类型，true 为 1，求负后为 -1 ，再转回布尔值时仍为 1 ，还是 true。</li>
<li>求商向 0 取整（直接切除小数部分）。取余时，除了 -m 导致溢出的情况，m % ( -n )等于 m % n，( -m ) % n 等于 -( m % n )，即左右都为负，结果是两个正数取余后结果取反，一正一负，结果等于两个正数取余。</li>
<li>位运算符的运算对象是“小整数”，它的值会被自动提升成较大的整数类型”，如何处理负数对象的“符号位”依赖于机器，而且此时的左移操作可能会改变符号位的值，因此是一种未定义的行为。左移在右侧插入 0。右移时，无符号类型左侧插入 0，带符号类型插入符号位的副本或者值为 0 的二进制位，如何选择视具体情况而定。</li>
<li>sizeof 运算符对解引用指针进行运算不会验证指针是否有效，对指针进行运算返回指针本身所占空间大小，对数组返回整个数组所占空间大小。对 sring 或者 vector 运算返回该类型固定部分的大小。sizeof 返回值是一个常量表达式。</li>
<li>逗号（ , ）运算符按照从左向右的顺序求值，运算结果是右侧表达式的值。</li>
<li>无符号和有符号数一起运算时，无符号类型所占位数大于等于有符号类型，则有符号类型转为无符号类型；如果无符号类型所占位数小于有符号类型，比如 long 和 unsigned int （ long 大于 int 时），则 unsigned int 转为 long </li>
<li>命名的强制类型转换具有如下形式：<code>cast-name(expression）</code>，static_cast 是一种只要类型不包含底层 const 都可用。const_cast 只能改变运算对象的底层 const， 不能进行类型转换。</li>
<li>switch case 语句中，后面的 case 标签可以使用前面的 case 标签定义过的变量，但是该变量的初始化无效（如果前 case 标签被跳过的话），包括类似 string 的默认初始化。即：不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。</li>
</ol>
<h2 id="相似部分整合"><a href="#相似部分整合" class="headerlink" title="相似部分整合"></a>相似部分整合</h2><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cctype 头文件中的函数</span></span><br><span class="line"><span class="built_in">isalnur</span>(c)  <span class="comment">// 当c是字母或数字时为真</span></span><br><span class="line"><span class="built_in">isalpha</span>(c)  <span class="comment">// 当c是字母时为真</span></span><br><span class="line"><span class="built_in">iscntrl</span>(n)  <span class="comment">// 当c是控制字符时为真</span></span><br><span class="line"><span class="built_in">isdigit</span>(c)  <span class="comment">// 当c是数字时为真</span></span><br><span class="line"><span class="built_in">isgraph</span>(c)  <span class="comment">// 当c不是空格但可打印时为真</span></span><br><span class="line"><span class="built_in">islower</span>(c)  <span class="comment">// 当c是小写字母时为真</span></span><br><span class="line"><span class="built_in">isprint</span>(c)  <span class="comment">// 当c是可打印字符时为真(即c是空格或c具有可视形式)</span></span><br><span class="line"><span class="built_in">ispunct</span>(c)  <span class="comment">// 当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种)</span></span><br><span class="line"><span class="built_in">isspace</span>(c)  <span class="comment">// 当c是空白时为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种)</span></span><br><span class="line"><span class="built_in">isupper</span>(c)  <span class="comment">// 当c是大写字母时为真</span></span><br><span class="line"><span class="built_in">isxdigit</span>(c) <span class="comment">// 当c是十六进制数字时为其</span></span><br><span class="line"><span class="built_in">tolower</span>(c)  <span class="comment">// 如果c是大写字母,输出对应的小写字母:否则原样输出c</span></span><br><span class="line"><span class="built_in">toupper</span>(c)  <span class="comment">// 如果c是小写字母,输出对应的大写字母:否则原样输出c</span></span><br></pre></td></tr></table></figure>

<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;istream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span>   <span class="comment">// 使用va_list可变参数列表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;system_error&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>    <span class="comment">// 使用vector容器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>   <span class="comment">// 预处理变量NULL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span>    <span class="comment">// 使用nullptr，isalnum()，isalpha()等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span>   <span class="comment">// 使用size_t,ptrdiff_t</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>  <span class="comment">// 使用begin(),end()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span> <span class="comment">// 异常类，如runtime_error,p176</span></span></span><br></pre></td></tr></table></figure>

<h3 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span>  <span class="comment">// assert, 预处理宏</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;     <span class="comment">// using 声明，当我们使用 cin 时，意味着使用的 std:: cin</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">// 头文件内容会拷贝到所有引用他的文件里，一般不应包含 using 声明（易造成名字冲突）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果定义了预处理变量 MIN, 就继续到#endif，#indef 和#indef 叫预处理百年</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKSTR(x) #x       <span class="comment">// &quot;x&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有定义预处理变量 MIN, 就继续到#endif，一般头文件的预处理变量定义都需要这样写</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MIN   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) (a &lt; b ? a : b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> concat(a, B) a##b <span class="comment">// xy</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG <span class="comment">// 定了他 assert 什么都不做，没定义则指执行运行时检查</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> i = <span class="number">123</span>; <span class="comment">// a 文件里定义并初始化 i，加 extern 使其能被其他文件使用</span></span><br></pre></td></tr></table></figure>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol>
<li><p>stack 容器</p>
<p> 头文件，c 在 std 命名空间。stack 容器适配器的模板有两个参数。第一个参数是存储对象的类型，第二个参数是底层容器的类型。stack 的底层容器默认是 deque 容器，因此模板类型其实是 stack。通过指定第二个模板类型参数，可以使用任意类型的底层容器，只要它们支持 back()、push_back()、pop_back()、empty()、size() 这些操作。下面展示了如何定义一个使用 list 的堆栈：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;string&gt; words1;   <span class="comment">// 省略第一个参数，用默认的底层容器 deque &lt;T&gt; 实现</span></span><br><span class="line">stack&lt;string, list&lt;string&gt;&gt; words2  <span class="comment">// 底层容器使用 list &lt;T&gt;</span></span><br></pre></td></tr></table></figure>

<p> 创建堆栈时，不能用对象来初始化，但是可以用另一个容器来初始化，只要堆栈的底层容器类型和这个容器的类型相同，且必须使用圆括号。例如：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">double</span>&gt; values &#123;<span class="number">1.414</span>, <span class="number">3.14159265</span>, <span class="number">2.71828</span>&#125;;</span><br><span class="line">stack&lt;<span class="type">double</span>, list&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">my_stack</span> (values);</span><br></pre></td></tr></table></figure>

<p> 第二条语句生成了一个包含 value 元素副本的 my_stack。这里不能在 stack 构造函数中使用初始化列表，必须使用圆括号。如果没有在第二个 stack 模板类型参数中将底层容器指定为 list，那么底层容器可能是 deque，这样就不能用 list 的内容来初始化 stack；只能接受 deque。</p>
<p> stack 模板定义了拷贝构造函数，因而可以复制现有的 stack 容器：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack copy_stack &#123;my_stack&#125;</span><br></pre></td></tr></table></figure>

<p>堆栈操作：(T 为栈中元素类型)</p>
<ul>
<li><p>push(const T&amp; obj) 可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。</p>
<ul>
<li>pop() 弹出栈顶元素但没有返回它。</li>
</ul>
</li>
<li><p>top() 返回一个栈顶元素的引用但没有弹出，类型为 T&amp;。如果栈为空，返回值未定义。</p>
<ul>
<li><p>size() 返回栈中元素的个数。</p>
</li>
<li><p>empty() 在栈中没有元素的情况下返回 true。</p>
</li>
<li><p>emplace() 用传入的参数调用构造函数，在栈顶生成对象。</p>
</li>
<li><p>swap(stack &amp; other_stack)将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同。对于 stack 对象有一个特例化的全局函数 swap() 可以使用。</p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>类模板</p>
<p> vector 定义在头文件中，需要包含，并位于 std 命名空间中。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">double</span>&gt; values;   <span class="comment">// 创建空容器</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">values1</span><span class="params">(<span class="number">20</span>， <span class="number">1.0</span>)</span></span>; <span class="comment">// 开始就有 20 个 int, 初始值均为 1.0, 没有第二个参数初始值默认均为 0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; values2&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;; <span class="comment">// 指定元素个数和初始值</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">values3</span><span class="params">(values2)</span></span>;  <span class="comment">// 创建和 alces 相同的容器</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">values4</span><span class="params">(begin(value2,begin(v。alue2)<span class="number">+3</span>))</span> <span class="comment">// 使用指针或者迭代器来指定初始值范围</span></span></span><br></pre></td></tr></table></figure>

<p> vector 容器包含的成员函数：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">begin</span>()	    <span class="comment">// 返回指向容器中第一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">end</span>()	    <span class="comment">// 返回指向容器最后一个元素所在位置后一个位置的迭代器。</span></span><br><span class="line"><span class="built_in">front</span>()	    <span class="comment">// 返回第一个元素的引用。</span></span><br><span class="line"><span class="built_in">back</span>()	    <span class="comment">// 返回最后一个元素的引用。</span></span><br><span class="line"><span class="built_in">data</span>()	    <span class="comment">// 返回指向容器中第一个元素的指针。</span></span><br><span class="line"><span class="built_in">assign</span>()    <span class="comment">// 用新元素替换原有内容。</span></span><br><span class="line"><span class="built_in">push_back</span>()	<span class="comment">// 在序列的尾部添加一个元素。</span></span><br><span class="line"><span class="built_in">pop_back</span>()	<span class="comment">// 移出序列尾部的元素。</span></span><br><span class="line"><span class="built_in">insert</span>()	<span class="comment">// 在指定的位置插入一个或多个元素。</span></span><br><span class="line"><span class="built_in">erase</span>()	    <span class="comment">// 移出一个元素或一段元素。</span></span><br><span class="line"><span class="built_in">clear</span>()	    <span class="comment">// 移出所有的元素，容器大小变为 0。</span></span><br><span class="line"><span class="built_in">rbegin</span>()  <span class="comment">// 返回指向最后一个元素的迭代器。</span></span><br><span class="line"><span class="built_in">rend</span>()	  <span class="comment">// 返回指向第一个元素所在位置前一个位置的迭代器。</span></span><br><span class="line"><span class="built_in">cbegin</span>()  <span class="comment">// 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</span></span><br><span class="line"><span class="built_in">cend</span>()	  <span class="comment">// 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</span></span><br><span class="line"><span class="built_in">crbegin</span>() <span class="comment">// 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</span></span><br><span class="line"><span class="built_in">crend</span>()	  <span class="comment">// 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</span></span><br><span class="line"><span class="built_in">size</span>()	  <span class="comment">// 返回实际元素个数。</span></span><br><span class="line"><span class="built_in">max_size</span>()<span class="comment">// 返回元素个数的最大值。这通常是一个很大的值，一般是 2^32-1，所以我们很少会用到这个函数。</span></span><br><span class="line"><span class="built_in">resize</span>()  <span class="comment">// 改变实际元素的个数。</span></span><br><span class="line"><span class="built_in">capacity</span>()<span class="comment">// 返回当前容量。</span></span><br><span class="line"><span class="built_in">empty</span>()	  <span class="comment">// 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</span></span><br><span class="line"><span class="built_in">reserve</span>() <span class="comment">// 增加容器的容量。</span></span><br><span class="line">shrink _to_fit()  <span class="comment">// 将内存减少到等于当前元素实际所使用的大小。</span></span><br><span class="line"><span class="keyword">operator</span>[ ]	      <span class="comment">// 重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素。</span></span><br><span class="line"><span class="built_in">at</span>()	        <span class="comment">// 使用经过边界检查的索引访问元素。</span></span><br><span class="line"><span class="built_in">swap</span>()	        <span class="comment">// 交换两个容器的所有元素。</span></span><br><span class="line"><span class="built_in">emplace</span>()	    <span class="comment">// 在指定的位置直接生成一个元素。</span></span><br><span class="line"><span class="built_in">emplace_back</span>()	<span class="comment">// 在序列尾部生成一个元素。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>哈希表</p>
<p> 头文件 <code>&lt;unordered_map&gt;</code>，在 std 名命名空间中。它将数据存储为键值对，其中键是唯一的。 声明和初始化：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; map1</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 杂记</title>
    <url>/2024/02/04/C++%20%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C-杂记"><a href="#C-杂记" class="headerlink" title="C++ 杂记"></a>C++ 杂记</h1><h2 id="代码记录"><a href="#代码记录" class="headerlink" title="代码记录"></a>代码记录</h2><h3 id="随机-ID-生成函数"><a href="#随机-ID-生成函数" class="headerlink" title="随机 ID 生成函数"></a>随机 ID 生成函数</h3><p>根据高分辨率的时钟为种子，生成指定长度的随机 ID 的函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成指定长度的随机 ID</span></span><br><span class="line"><span class="function">std::string <span class="title">randomId</span><span class="params">(<span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> std::chrono::high_resolution_clock;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">thread_local</span> std::mt19937 <span class="title">rng</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(high_resolution_clock::now().time_since_epoch().count()))</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> std::string <span class="title">characters</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">id</span><span class="params">(length, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">  <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">uniform</span><span class="params">(<span class="number">0</span>, <span class="type">int</span>(characters.size() - <span class="number">1</span>))</span></span>;</span><br><span class="line">  std::<span class="built_in">generate</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), [&amp;]() &#123; <span class="keyword">return</span> characters.<span class="built_in">at</span>(<span class="built_in">uniform</span>(rng)); &#125;);</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::chrono::high_resolution_clock; <span class="comment">// 这行代码引入了 `std::chrono::high_resolution_clock`，这是一个用于测量时间的标准库类。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">thread_local</span> std::mt19937 <span class="title">rng</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(high_resolution_clock::now().time_since_epoch().count()))</span></span>;</span><br></pre></td></tr></table></figure>

<p>这行代码定义了一个静态局部变量 <code>rng</code>，它是一个 <code>std::mt19937</code> 类型的伪随机数生成器。通过使用当前时间的高分辨率时钟的计数作为种子，我们创建了一个每次函数调用时都会生成不同随机数序列的生成器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> std::string <span class="title">characters</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这行代码定义了一个静态常量字符串 <code>characters</code>，它包含了用于生成随机 ID 的字符集。它包括数字、大写字母和小写字母。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">id</span><span class="params">(length, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这行代码创建了一个名为 <code>id</code> 的 <code>std::string</code> 对象，长度为 <code>length</code>，并将其初始化为由字符 <code>&#39;0&#39;</code> 组成的字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">uniform</span><span class="params">(<span class="number">0</span>, <span class="type">int</span>(characters.size() - <span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>这行代码定义了一个均匀分布的整数生成器 <code>uniform</code>，它生成范围在 <code>0</code> 到 <code>characters.size() - 1</code> 之间的整数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">generate</span>(id.<span class="built_in">begin</span>(), id.<span class="built_in">end</span>(), [&amp;]() &#123; <span class="keyword">return</span> characters.<span class="built_in">at</span>(<span class="built_in">uniform</span>(rng)); &#125;);</span><br></pre></td></tr></table></figure>

<p>这行代码使用 <code>std::generate</code> 算法，将随机选择的字符填充到 <code>id</code> 字符串中。<code>generate</code> 函数接受一个范围（由 <code>id.begin()</code> 和 <code>id.end()</code> 表示），并使用 lambda 表达式作为生成器函数。lambda 表达式使用 <code>characters</code> 字符串和 <code>uniform(rng)</code> 生成的随机索引来填充字符。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li><p><code>std::holds_alternative&lt;std::string&gt;(data)</code> 是一个类型检查的表达式，用于检查给定的变量 <code>data</code> 是否包含 <code>std::string</code> 类型的值。</p>
<p> <code>std::holds_alternative</code> 是 C++ 标准库中的一个函数模板，它的作用是判断给定的变量是否包含指定的类型。</p>
</li>
<li><p><code>std::promise&lt;void&gt;</code> 是 C++标准库中的一个模板类，用于提供一种机制，允许一个线程在某个时间点产生一个值（或异常），并使其他线程能够等待并获取该值（或异常）。</p>
<p> <code>wsPromise</code> 是 <code>std::promise&lt;void&gt;</code> 类型的实例。这意味着它是一个用于产生 <code>void</code> 类型值的 <code>promise</code> 对象。</p>
<p> <code>std::promise</code> 类提供了两个主要操作：<code>set_value()</code> 和 <code>set_exception()</code>。通过调用 <code>set_value()</code>，可以在 <code>promise</code> 对象上设置一个值（在这种情况下，是 <code>void</code> 类型的值），然后通过调用 <code>get_future()</code> 获得一个与该 <code>promise</code> 相关联的 <code>std::future</code> 对象，其他线程可以通过该 <code>future</code> 对象等待并获取该值。</p>
<p> 以下是一个简单的示例，展示了如何使用 <code>std::promise&lt;void&gt;</code> 和相关的类来实现线程间的同步：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(std::promise&lt;<span class="type">void</span>&gt;&amp; promise)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 模拟一些耗时的工作</span></span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工作完成后，设置 promise 的值</span></span><br><span class="line">  promise.<span class="built_in">set_value</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::promise&lt;<span class="type">void</span>&gt; wsPromise;</span><br><span class="line">  std::future&lt;<span class="type">void</span>&gt; wsFuture = wsPromise.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个工作线程，并传递 promise 作为参数</span></span><br><span class="line">  <span class="function">std::thread <span class="title">workerThread</span><span class="params">(worker, std::ref(wsPromise))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待工作线程完成</span></span><br><span class="line">  wsFuture.<span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Worker thread finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  workerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在上述示例中，<code>worker()</code> 函数是一个工作线程执行的函数。它接受一个 <code>std::promise&lt;void&gt;</code> 对象作为参数，并通过调用 <code>set_value()</code> 来设置该 <code>promise</code> 对象的值。主线程使用 <code>get_future()</code> 获取与 <code>promise</code> 对象相关联的 <code>std::future</code> 对象，并使用 <code>wait()</code> 函数等待工作线程完成。一旦工作线程完成并设置了 <code>promise</code> 的值，主线程将继续执行。</p>
<p> 需要注意的是，<code>std::promise</code> 和 <code>std::future</code> 提供了一种线程间通信的机制，其中一个线程通过 <code>promise</code> 设置值，而另一个线程通过 <code>future</code> 等待并获取该值。</p>
</li>
<li><p><code>std::promise</code> 类中的 <code>set_exception()</code> 函数用于在 <code>promise</code> 对象上设置一个异常，以通知与之关联的 <code>std::future</code> 对象所在的线程。</p>
<p> 当某个线程调用 <code>set_exception()</code> 函数并提供一个异常作为参数时，与该 <code>promise</code> 对象关联的 <code>std::future</code> 对象上的等待操作将会收到该异常（通过 <code>std::future</code> 对象的 <code>get()</code> 函数或 <code>wait()</code> 函数调用时抛出）。</p>
<p> 以下是一个示例，展示了如何使用 <code>std::promise</code> 的 <code>set_exception()</code> 函数来传递异常：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; promise)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛出一个异常</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Something went wrong.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 promise 的值（这行代码不会执行）</span></span><br><span class="line">    promise.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br><span class="line">  &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 捕获异常，并通过 promise 设置异常</span></span><br><span class="line">    promise.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::promise&lt;<span class="type">int</span>&gt; wsPromise;</span><br><span class="line">  std::future&lt;<span class="type">int</span>&gt; wsFuture = wsPromise.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个工作线程，并传递 promise 作为参数</span></span><br><span class="line">  <span class="function">std::thread <span class="title">workerThread</span><span class="params">(worker, std::ref(wsPromise))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 等待工作线程完成</span></span><br><span class="line">    <span class="type">int</span> result = wsFuture.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread finished with result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; ex) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread threw an exception: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  workerThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在上述示例中，<code>worker()</code> 函数模拟一个工作线程执行的工作。在这个例子中，工作线程抛出了一个 <code>std::runtime_error</code> 异常，然后通过 <code>set_exception()</code> 函数将异常传递给与 <code>promise</code> 对象关联的 <code>std::future</code> 对象。主线程使用 <code>get()</code> 函数获取 <code>std::future</code> 对象上的值时，如果工作线程抛出了异常，<code>get()</code> 函数将重新抛出该异常，然后可以在主线程中捕获并处理该异常。</p>
<p> 总而言之，<code>set_exception()</code> 函数允许在 <code>promise</code> 对象上设置异常，以便将异常传递给与之关联的 <code>std::future</code> 对象所在的线程，从而实现线程间的异常传递和处理。</p>
</li>
<li><p><code>std::cin.ignore()</code> 是 C++标准库中 <code>std::cin</code> 流的成员函数之一。它的作用是忽略输入流中的字符。</p>
<p> <code>std::cin.ignore()</code> 函数通常与 <code>std::cin</code> 结合使用，用于清除输入缓冲区中的字符，以便接下来的输入操作不会受到之前输入的影响。</p>
<p> 该函数可以在两种形式下使用：</p>
<ol>
<li><code>std::cin.ignore()</code>：调用函数时不传递参数。它会忽略输入流中的下一个字符，无论是换行符、空格符还是其他字符。</li>
<li><code>std::cin.ignore(n, delim)</code>：调用函数时传递两个参数。其中，<code>n</code> 是要忽略的字符数，<code>delim</code> 是可选的定界符（默认为换行符）。<ul>
<li>如果提供了 <code>n</code>，则会忽略输入流中的前 <code>n</code> 个字符。</li>
<li>如果同时提供了 <code>n</code> 和 <code>delim</code>，则会忽略输入流中的字符，直到遇到定界符 <code>delim</code> 为止。</li>
</ul>
</li>
</ol>
<p> 这些函数在某些情况下很有用，例如当需要清除输入缓冲区中的残留字符时，或者在读取不同类型的数据之前需要忽略一些字符。</p>
</li>
<li><p>部分 C 语言库，在 c++文件中使用需要用 <code>extern &quot;C&quot;&#123;&#125;</code> 的形式包裹起来，否则编译链接时会找不到库中函数的实现，例如 FFmpeg 库中的库：</p>
</li>
</ol>
<pre><code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavcodec/packet.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 条件变量</title>
    <url>/2023/12/13/C++%20%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="C-条件变量"><a href="#C-条件变量" class="headerlink" title="C++ 条件变量"></a>C++ 条件变量</h1><h2 id="互斥锁和条件变量"><a href="#互斥锁和条件变量" class="headerlink" title="互斥锁和条件变量"></a>互斥锁和条件变量</h2><p>在多线程编程中，同步机制是保证程序正确性的关键。互斥锁（mutex）作为最基础的同步原语，能够有效保护临界区资源。但当遇到线程间协作的场景时，仅靠互斥锁就显得力不从心。</p>
<p><strong>典型场景对比</strong>：</p>
<ol>
<li><strong>互斥锁适用场景</strong>：多线程修改共享资源（如线程安全的哈希表）</li>
<li><strong>条件变量适用场景</strong>：线程依赖其他线程产生的数据（如生产者-消费者模型）</li>
</ol>
<p>传统轮询方案（伪代码）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">lock</span>(mutex);</span><br><span class="line">    <span class="keyword">if</span>(condition) &#123;</span><br><span class="line">        <span class="comment">// 处理业务</span></span><br><span class="line">        <span class="built_in">unlock</span>(mutex);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unlock</span>(mutex);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">100</span>); <span class="comment">// 低效等待</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件变量方案对比优势：</p>
<ul>
<li>零等待开销：线程在条件不满足时主动休眠</li>
<li>精准唤醒：通过通知机制避免无效轮询</li>
<li>原子性操作：保证条件判断与等待的原子性</li>
</ul>
<h2 id="条件变量核心机制"><a href="#条件变量核心机制" class="headerlink" title="条件变量核心机制"></a>条件变量核心机制</h2><h3 id="五元协同模型"><a href="#五元协同模型" class="headerlink" title="五元协同模型"></a>五元协同模型</h3><p>条件变量的高效运作依赖五个核心要素：</p>
<ol>
<li><strong>共享条件</strong>（condition）：决定线程是否继续执行的状态判断</li>
<li><strong>互斥锁</strong>（mutex）：保护共享条件的访问</li>
<li><strong>条件变量</strong>（cv）：实现等待&#x2F;通知的通信机制</li>
<li><strong>等待线程</strong>：条件不满足时进入休眠</li>
<li><strong>通知线程</strong>：修改条件后触发唤醒</li>
</ol>
<h3 id="标准接口详解"><a href="#标准接口详解" class="headerlink" title="标准接口详解"></a>标准接口详解</h3><p>C++11提供两种条件变量实现：</p>
<ul>
<li><code>std::condition_variable</code>：高性能标准实现</li>
<li><code>std::condition_variable_any</code>：支持任意锁类型</li>
</ul>
<h4 id="等待函数对比"><a href="#等待函数对比" class="headerlink" title="等待函数对比"></a>等待函数对比</h4><table>
<thead>
<tr>
<th>函数</th>
<th>特性</th>
<th>超时控制</th>
</tr>
</thead>
<tbody><tr>
<td>wait</td>
<td>基础等待</td>
<td>无</td>
</tr>
<tr>
<td>wait_for</td>
<td>相对时间等待</td>
<td>chrono::duration</td>
</tr>
<tr>
<td>wait_until</td>
<td>绝对时间等待</td>
<td>chrono::time_point</td>
</tr>
</tbody></table>
<h4 id="唤醒函数对比"><a href="#唤醒函数对比" class="headerlink" title="唤醒函数对比"></a>唤醒函数对比</h4><table>
<thead>
<tr>
<th>函数</th>
<th>唤醒范围</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>notify_one</td>
<td>单个线程</td>
<td>单消费者模型</td>
</tr>
<tr>
<td>notify_all</td>
<td>所有线程</td>
<td>多消费者&#x2F;广播场景</td>
</tr>
</tbody></table>
<h2 id="条件变量使用示例"><a href="#条件变量使用示例" class="headerlink" title="条件变量使用示例"></a>条件变量使用示例</h2><h3 id="通用代码模板"><a href="#通用代码模板" class="headerlink" title="通用代码模板"></a>通用代码模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享变量声明</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> condition = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lk, []&#123; <span class="keyword">return</span> condition; &#125;); <span class="comment">// 带谓词的等待</span></span><br><span class="line">    <span class="comment">// 业务处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知线程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    condition = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">cv.<span class="built_in">notify_one</span>();</span><br></pre></td></tr></table></figure>

<h3 id="生产-消费模型实现"><a href="#生产-消费模型实现" class="headerlink" title="生产-消费模型实现"></a>生产-消费模型实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; data_queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; ;++i) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            data_queue.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lk, []&#123; <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">      </span><br><span class="line">        <span class="type">int</span> data = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        lk.<span class="built_in">unlock</span>(); <span class="comment">// 提前释放锁</span></span><br><span class="line">      </span><br><span class="line">        <span class="built_in">process</span>(data); <span class="comment">// 耗时操作放在锁外</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="4-1-互斥锁的必要性"><a href="#4-1-互斥锁的必要性" class="headerlink" title="4.1 互斥锁的必要性"></a>4.1 互斥锁的必要性</h3><p>条件变量必须与互斥锁配合使用的根本原因在于保证操作的原子性：</p>
<ol>
<li><strong>Lost Wakeup防护</strong>：避免判断条件与进入等待之间的间隙导致通知丢失</li>
<li><strong>数据一致性</strong>：确保共享条件的修改可见性</li>
<li><strong>唤醒原子性</strong>：保证唤醒操作与条件修改的原子关系</li>
</ol>
<p>操作时序图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Wait Thread]       [Mutex]     [Condition]     [Notify Thread]</span><br><span class="line">     |                |              |                 |</span><br><span class="line">     |-- Lock -------&gt;|              |                 |</span><br><span class="line">     |-- Check Cond --|              |                 |</span><br><span class="line">     |&lt;&lt;Cond False&gt;&gt;  |              |                 |</span><br><span class="line">     |-- Wait --------|-------------&gt;|                 |</span><br><span class="line">     |                | Release      |                 |</span><br><span class="line">     |                |&lt;-------------|                 |</span><br><span class="line">     |                |              |-- Lock ---------|</span><br><span class="line">     |                |              |-- Modify Cond --|</span><br><span class="line">     |                |              |-- Notify -------|</span><br><span class="line">     |&lt;-- Wake Up ----|--------------|                 |</span><br><span class="line">     |-- Re-Lock ----&gt;|              |                 |</span><br><span class="line">     |-- Check Cond --|              |                 |</span><br><span class="line">     |&lt;&lt;Cond True&gt;&gt;&gt;  |              |                 |</span><br></pre></td></tr></table></figure>

<h3 id="虚假唤醒应对策略"><a href="#虚假唤醒应对策略" class="headerlink" title="虚假唤醒应对策略"></a>虚假唤醒应对策略</h3><p>虚假唤醒的根源来自：</p>
<ul>
<li>系统信号中断</li>
<li>线程调度竞争</li>
<li>硬件特性影响</li>
</ul>
<p>防御性编程方案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础写法</span></span><br><span class="line"><span class="keyword">while</span>(!condition) &#123;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带谓词的高级写法（推荐）</span></span><br><span class="line">cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> condition; &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="性能优化实践"><a href="#性能优化实践" class="headerlink" title="性能优化实践"></a>性能优化实践</h3><ol>
<li><strong>锁粒度控制</strong>：在<code>wait</code>返回后及时缩小锁作用域</li>
<li><strong>通知优化</strong>：在非临界区执行<code>notify</code>调用</li>
<li><strong>批量处理</strong>：合并多次操作为单次通知</li>
<li><strong>自旋等待</strong>：对预期短期等待的场景采用混合策略</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 批量处理优化示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">batch_update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="comment">// 批量更新共享数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item : data) item.<span class="built_in">update</span>();</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="comment">// 自动释放锁</span></span><br><span class="line">    cv.<span class="built_in">notify_all</span>(); <span class="comment">// 单次通知所有消费者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进阶应用场景"><a href="#进阶应用场景" class="headerlink" title="进阶应用场景"></a>进阶应用场景</h2><h3 id="读写锁模拟"><a href="#读写锁模拟" class="headerlink" title="读写锁模拟"></a>读写锁模拟</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::condition_variable cv;</span><br><span class="line">    <span class="type">int</span> readers = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> writing = <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lk, [&amp;]&#123; <span class="keyword">return</span> !writing; &#125;);</span><br><span class="line">        ++readers;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lk, [&amp;]&#123; <span class="keyword">return</span> !writing &amp;&amp; readers == <span class="number">0</span>; &#125;);</span><br><span class="line">        writing = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 解锁实现略...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="屏障同步实现"><a href="#屏障同步实现" class="headerlink" title="屏障同步实现"></a>屏障同步实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadBarrier</span> &#123;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::condition_variable cv;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> generation = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadBarrier</span><span class="params">(<span class="type">int</span> n)</span> : count(n) &#123;</span>&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="type">int</span> gen = generation;</span><br><span class="line">        <span class="keyword">if</span>(--count == <span class="number">0</span>) &#123;</span><br><span class="line">            ++generation;</span><br><span class="line">            count = initial;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lk, [&amp;]&#123; <span class="keyword">return</span> gen != generation; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考 ：<br><a href="https://en.cppreference.com/w/cpp/thread/condition_variable">std::condition_variable - cppreference.com</a><br><a href="https://www.cplusplus.com/reference/condition_variable/condition_variable/">condition_variable - C++ Reference - Cplusplus.com</a><br><a href="https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups">Why does pthread_cond_wait have spurious wakeups?</a><br><a href="https://stackoverflow.com/questions/4544234/calling-pthread-cond-signal-without-locking-mutex">Calling pthread_cond_signal without locking mutex</a></p>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>CMake 记录</title>
    <url>/2023/04/21/CMake%20%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="CMake-记录"><a href="#CMake-记录" class="headerlink" title="CMake 记录"></a>CMake 记录</h1><h2 id="make-和-makefile"><a href="#make-和-makefile" class="headerlink" title="make 和 makefile"></a>make 和 makefile</h2><p>gcc编译c程序文件，链接静态库和动态库，FFmpeg：<a href="https://ffmpeg.xianwaizhiyin.net/base-compile/linux-c-single.html">https://ffmpeg.xianwaizhiyin.net/base-compile/linux-c-single.html</a></p>
<p>Make和Makefile快速入门：<a href="https://blog.csdn.net/Naisu_kun/article/details/116918571">https://blog.csdn.net/Naisu_kun/article/details/116918571</a></p>
<p><code>cmake</code> 是 <code>makefile</code> 的上层工具，它们的目的正是为了产生可移植的 makefile，并简化自己动手写 makefile 时的巨大工作量。</p>
<p>常用命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmake 最低版本需求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.13</span>)</span><br><span class="line"><span class="comment"># 工程名称</span></span><br><span class="line"><span class="keyword">project</span>(cmake_study)</span><br><span class="line"><span class="comment"># 设置c++标准，这里是c++11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment"># 编译源码生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(cmake_study src/main.cc)</span><br></pre></td></tr></table></figure>

<h2 id="SET-set-：定义变量"><a href="#SET-set-：定义变量" class="headerlink" title="SET(set)：定义变量"></a><code>SET(set)</code>：定义变量</h2><p><strong>语法</strong>：<code>SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) </code></p>
<p><strong>指令功能</strong>：用来显式的定义变量 </p>
<p><strong>例子</strong> ：<code>SET (SRC_LST main.c other.c)</code> </p>
<p><strong>说明</strong>：用变量代替值，例子中定义 <code>SRC_LST</code> 代替后面的字符串。</p>
<p>我们可以使用 <code>$&#123;NAME&#125;</code> 来获取变量的名称。</p>
<p><strong>cmake 常用变量</strong></p>
<table>
<thead>
<tr>
<th align="left">环境变量名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CMAKE_BINARY_DIR, PROJECT_BINARY_DIR, <code>&lt;projectname&gt;</code>_BINARY_DIR</td>
<td align="left">如果是 <code>in source</code> 编译,指得就是工程顶层目录,如果是 <code>out-of-source</code> 编译,指的是工程编译发生的目录。PROJECT_BINARY_DIR 跟其他指令稍有区别,现在,你可以理解为他们是一致的。</td>
</tr>
<tr>
<td align="left">CMAKE_SOURCE_DIR, PROJECT_SOURCE_DIR, <code>&lt;projectname&gt;</code>_SOURCE_DIR</td>
<td align="left">工程顶层目录。</td>
</tr>
<tr>
<td align="left">CMAKE_CURRENT_SOURCE_DIR</td>
<td align="left">当前处理的 CMakeLists.txt 所在的路径,比如上面我们提到的 src 子目录。</td>
</tr>
<tr>
<td align="left">CMAKE_CURRRENT_BINARY_DIR</td>
<td align="left">如果是 <code>in-source</code> 编译,它跟 CMAKE_CURRENT_SOURCE_DIR 一致,如果是 <code>out-of-source</code> 编译,他指的是 target 编译目录。</td>
</tr>
<tr>
<td align="left">EXECUTABLE_OUTPUT_PATH , LIBRARY_OUTPUT_PATH</td>
<td align="left">最终目标文件存放的路径。</td>
</tr>
<tr>
<td align="left">PROJECT_NAME</td>
<td align="left">通过 PROJECT 指令定义的项目名称。</td>
</tr>
</tbody></table>
<p><strong>cmake 系统信息</strong></p>
<table>
<thead>
<tr>
<th align="left">系统信息变量名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CMAKE_MAJOR_VERSION</td>
<td align="left">CMAKE 主版本号,比如 2.4.6 中的 2</td>
</tr>
<tr>
<td align="left">CMAKE_MINOR_VERSION</td>
<td align="left">CMAKE 次版本号,比如 2.4.6 中的 4</td>
</tr>
<tr>
<td align="left">CMAKE_PATCH_VERSION</td>
<td align="left">CMAKE 补丁等级,比如 2.4.6 中的 6</td>
</tr>
<tr>
<td align="left">CMAKE_SYSTEM</td>
<td align="left">系统名称,比如 Linux-2.6.22</td>
</tr>
<tr>
<td align="left">CMAKE_SYSTEM_NAME</td>
<td align="left">不包含版本的系统名,比如 Linux</td>
</tr>
<tr>
<td align="left">CMAKE_SYSTEM_VERSION</td>
<td align="left">系统版本,比如 2.6.22</td>
</tr>
<tr>
<td align="left">CMAKE_SYSTEM_PROCESSOR</td>
<td align="left">处理器名称,比如 i686.</td>
</tr>
<tr>
<td align="left">UNIX</td>
<td align="left">在所有的类 UNIX 平台为 TRUE,包括 OS X 和 cygwin</td>
</tr>
<tr>
<td align="left">WIN32</td>
<td align="left">在所有的 win32 平台为 TRUE,包括 cygwin</td>
</tr>
</tbody></table>
<p><strong>cmake 编译选项</strong></p>
<table>
<thead>
<tr>
<th align="left">编译控制开关名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BUILD_SHARED_LIBS</td>
<td align="left">使用 <code>ADD_LIBRARY</code> 时生成动态库</td>
</tr>
<tr>
<td align="left">BUILD_STATIC_LIBS</td>
<td align="left">使用 <code>ADD_LIBRARY</code> 时生成静态库</td>
</tr>
<tr>
<td align="left">CMAKE_C_FLAGS</td>
<td align="left">设置 C 编译选项,也可以通过指令 ADD_DEFINITIONS()添加。</td>
</tr>
<tr>
<td align="left">CMAKE_CXX_FLAGS</td>
<td align="left">设置 C++编译选项,也可以通过指令 ADD_DEFINITIONS()添加。</td>
</tr>
</tbody></table>
<h2 id="不引入第三方库"><a href="#不引入第三方库" class="headerlink" title="不引入第三方库"></a>不引入第三方库</h2><p>目录结构：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">./Demo1</span><br><span class="line"><span class="code">    |</span></span><br><span class="line"><span class="code">    +--- main.cc</span></span><br><span class="line"><span class="code">    |</span></span><br><span class="line"><span class="code">    +--- math/</span></span><br><span class="line"><span class="code">          |</span></span><br><span class="line"><span class="code">          +--- MathFunctions.cc</span></span><br><span class="line"><span class="code">          |</span></span><br><span class="line"><span class="code">          +--- MathFunctions.h</span></span><br></pre></td></tr></table></figure>

<p>需要在项目根目录 Demo1 和 math 目录里各编写一个 CMakeLists.txt 文件。将 math 目录里的文件编译成静态库再由 main 函数调用。</p>
<p>math 目录中的 CMakeLists.txt：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_LIB_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态链接库MathFunctions</span></span><br><span class="line"><span class="keyword">add_library</span> (MathFunctions <span class="variable">$&#123;DIR_LIB_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>根目录中的 CMakeLists.txt ：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称信息，同时会自动生成 PROJECT_NAME 变量，使用 $&#123;PROJECT_NAME&#125; 即可访问到 Demo1</span></span><br><span class="line"><span class="keyword">project</span> (Demo1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量，使用 $&#123;DIR_SRCS&#125; 可访问到</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 math 子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">math</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标 </span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Demo MathFunctions)</span><br></pre></td></tr></table></figure>

<p>单独命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将从第二个往后的参数保存到 DIR_SRCS 变量中，使用 $&#123;DIR_SRCS&#125; 可以访问到</span></span><br><span class="line"><span class="keyword">set</span>(DIR_SRCS</span><br><span class="line">    MathFunctions.cc</span><br><span class="line">    main.cc</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="引入第三方库"><a href="#引入第三方库" class="headerlink" title="引入第三方库"></a>引入第三方库</h2><h3 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br><span class="line">└── README.adoc</span><br></pre></td></tr></table></figure>

<h3 id="本地导入（find-package）"><a href="#本地导入（find-package）" class="headerlink" title="本地导入（find_package）"></a>本地导入（find_package）</h3><p>以 boost 为例，MakeLists.txt：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (third_party_include)</span><br><span class="line"><span class="comment"># 使用库文件系统和系统查找 Boost，找到了，Boost_FOUND 为真，否则为假</span></span><br><span class="line"><span class="keyword">find_package</span>(Boost <span class="number">1.46</span>.<span class="number">1</span> REQUIRED COMPONENTS filesystem system)</span><br><span class="line"><span class="comment"># 1.46.1 代表需要库的最低版本；REQUIRED 表示找不到会报错；COMPONENTS 用于检测该库的对应组件是否存在，如果不存在则认为找到的库不满足条件。</span></span><br><span class="line"><span class="keyword">if</span>(Boost_FOUND)</span><br><span class="line">    <span class="keyword">message</span> (<span class="string">&quot;boost found&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span> (FATAL_ERROR <span class="string">&quot;Cannot find Boost&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(third_party_include main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(third_party_include PRIVATE Boost::filesystem)</span><br></pre></td></tr></table></figure>

<p>这里使用 <code>find_package</code> 命令来在本地搜索对应的第三方库，Boost 代表需要查询的库名称；1.46.1 代表需要库的最低版本；REQUIRED 表示该库是必须的，如果找不到会报错；COMPONENTS 用于检测该库的对应组件是否存在，如果不存在则认为找到的库不满足条件。</p>
<h3 id="外部导入（FetchContent）"><a href="#外部导入（FetchContent）" class="headerlink" title="外部导入（FetchContent）"></a>外部导入（FetchContent）</h3><p>以 GoogleTest 库为例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">project</span>(my_project)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入 FetchContent 模块</span></span><br><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line"><span class="comment"># 获取第三方库，可以是一个 URL 或者一个 Git 仓库</span></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  googletest</span><br><span class="line">  URL https://github.com/google/googletest/archive/<span class="number">609281088</span>cfefc76f9d0ce82e1ff6c30cc3591e5.zip</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将这个第三方库引入项目</span></span><br><span class="line">FetchContent_MakeAvailable(googletest)</span><br></pre></td></tr></table></figure>

<h2 id="使用外部头文件和库文件："><a href="#使用外部头文件和库文件：" class="headerlink" title="使用外部头文件和库文件："></a>使用外部头文件和库文件：</h2><p>如果系统中安装，并提供了响应的.cmake文件，可以直接使用<code>find_package()</code>添加依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加依赖项</span></span><br><span class="line">find_package(OpenCV REQUIRED)</span><br><span class="line">find_package(ZLIB REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加源文件</span></span><br><span class="line">add_executable(detect detect.cpp)</span><br><span class="line">target_link_libraries(detect PRIVATE libdeploy.so <span class="variable">$&#123;OpenCV_LIBS&#125;</span> <span class="variable">$&#123;ZLIB_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>FFmpeg 解码视频流</title>
    <url>/2024/05/14/FFmpeg%20%E8%A7%A3%E7%A0%81%E8%A7%86%E9%A2%91%E6%B5%81/</url>
    <content><![CDATA[<h1 id="FFmpeg-解码视频流"><a href="#FFmpeg-解码视频流" class="headerlink" title="FFmpeg 解码视频流"></a>FFmpeg 解码视频流</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文讲解从网络接收 H.265 视频裸流后使用 FFmpeg 相关库解码得到 YUVJ420P 格式的图片然后转为 RGB 格式图片并使用 jpeglib 库保存为 jpeg 文件。仅展示部分代码。</p>
<p>包含对 FFmpeg 的解码 H.265 视频裸流、图片保存格式 YUV 和 RGB 及两者之间的转换、jpeglib 将 RGB 格式图片保存为 jpeg 文件的相关内容。</p>
<h2 id="FFmpeg-库"><a href="#FFmpeg-库" class="headerlink" title="FFmpeg 库"></a>FFmpeg 库</h2><p>包含各种库，本文主要使用到以下库：</p>
<p><a href="https://ffmpeg.org/doxygen/trunk/group__libavc.html">libavcodec</a> 编码&#x2F;解码库</p>
<p><a href="https://ffmpeg.org/doxygen/trunk/group__libavf.html">libavformat</a> I&#x2F;O 和复用&#x2F;解复用库</p>
<p><a href="https://ffmpeg.org/doxygen/trunk/group__lavu.html">libavutil</a> 通用实用程序库</p>
<p><a href="https://ffmpeg.org/doxygen/trunk/group__libsws.html">libswscale</a> 颜色转换和缩放库</p>
<h2 id="跟解码相关的结构体"><a href="#跟解码相关的结构体" class="headerlink" title="跟解码相关的结构体"></a>跟<strong>解码</strong>相关的结构体</h2><ul>
<li><code>AVCodecContext</code>：可以是 <strong>编码器</strong> 的上下文，也可以是 <strong>解码器</strong> 的上下文，两者使用的是同一种数据结构（后面有些结构体和 API，编码器和解码器都可以使用，但为了方便，后面只提解码器）。</li>
<li><code>AVCodec</code>：存储解码器信息（为了方便，后面简称就是“解码器”了，基本上也可以这么理解）。</li>
<li><code>AVCodecParameters</code>：存储解码参数。</li>
<li><code>AVPacket</code>：原始数据包（已编码压缩的 IBP 帧），这里面的数据通常是一帧视频的数据，或者一帧音频的数据。本身是没有编码数据的，只是管理编码数据。</li>
<li><code>AVFrame</code>：解码之后的帧。<code>AVFrame</code> 跟 <code>AVPacket</code> 类似，是一个管理数据的结构体，本身是没有数据的，只是引用了数据。</li>
</ul>
<h2 id="与解码器相关的-API-函数"><a href="#与解码器相关的-API-函数" class="headerlink" title="与解码器相关的 API 函数"></a>与解码器相关的 API 函数</h2><ul>
<li><p><code>const AVCodec* avcodec_find_decoder(enum AVCodecID id)</code>:</p>
<p>  根据参数传入的解码器的 <code>AVCodecID</code> 返回指定的解码器。<code>AVCodecID</code> 是一个枚举类型，比如：传入 <code>AV_CODEC_ID_H265</code> 返回解码 H265 视频流的解码器。</p>
</li>
<li><p><code>AVCodecContext* avcodec_alloc_context3	(const AVCodec *codec)</code>：</p>
<p>  接收一个<code>AVCodec</code>（ <strong>编解码</strong>）参数，返回根据指定解码器初始化后的解码器上下文。如果为 NULL，则不会初始化特定于解码器的默认值，这可能会导致默认设置不理想。</p>
<p>  使用 <code>void avcodec_free_context	(AVCodecContext **avctx	)</code> 释放解码器上下文资源。</p>
</li>
<li><p><code>AVCodecParameters *avcodec_parameters_alloc()</code>：</p>
<p>  分配新的 AVCodecParameters 并将其字段设置为默认值，返回的AVCodecParameters必须使用 <code>avcodec_parameters_free（）</code> 释放。</p>
</li>
<li><p><code>int avcodec_parameters_from_context(struct AVCodecParameters *par,const AVCodecContext *codec)</code></p>
<p>  根据提供的<code>AVCodecContext</code>中的值填充<code>AVCodecParameters</code>。par 中任何分配的字段都将被释放，并替换为解码器中相应字段的副本。成功时 &gt;&#x3D; 0，失败时为负 AVERROR 代码。</p>
</li>
<li><p><code>int avcodec_parameters_to_context(AVCodecContext *codec, const struct AVCodecParameters *par)</code>：</p>
<p>  根据<code>AVCodecParameters</code> 参数提供的<strong>解码器参数</strong>（宽高，像素格式等信息）复制到 <code>AVCodecContext</code>（解码器上下文）。</p>
</li>
<li><p><code>int avcodec_open2( AVCodecContext *avctx, const AVCodec* codec, AVDictionary **options)</code>：</p>
<p>  使用初始化后<code>AVCodecContext</code>（编解码器上下文）和设定的选项打开一个编&#x2F;解码器。在使用此函数前，必须使用<code>avcodec_alloc_context3()</code>初始化上下文。</p>
</li>
<li><p><code>int avcodec_send_packet(AVCodecContext* avctx, const AVPacket* avpkt)</code>：</p>
<p>  往 <code>AVCodecContext</code> 绑定的解码器发送一个 <code>AVPacket</code> （需要被解码的一个原始数据帧）。帧的所有权仍属于调用者。返回0表示成功；返回 <code>AVERROR(EAGAIN)</code> 表示当前状态不接受输入，必须调用下面的函数读取输出，然后重新发送数据包；调用前必须用 <code>avcodec_open2()</code> 打开 <code>AVCodecContext</code>。</p>
</li>
<li><p><code>int avcodec_receive_frame(AVCcodecContext* avtx, AVFrame* frame)</code>：</p>
<p>  从 <code>AVCodecContext</code> 绑定的解码器读取一个 <code>AVFrame</code>（解码后的一个输出数据帧），返回值为0表示成功，返回一帧；为 <code>AVERROR(EAGAIN)</code> 表示输出不可用，需要继续输入（可能是B\P帧)；为 <code>AVERROR_EOF</code> 表示解码器完全刷新，不会再有输出帧。</p>
</li>
</ul>
<h2 id="与-AVPacket-和-AVFrame-相关的函数"><a href="#与-AVPacket-和-AVFrame-相关的函数" class="headerlink" title="与 AVPacket 和 AVFrame 相关的函数"></a>与 AVPacket 和 AVFrame 相关的函数</h2><ul>
<li><p><code>AVPacket *av_packet_alloc()</code>：</p>
<p>  创建一个 AVPacket 并将其字段设置为默认值，失败时返回 NULL。必须使用<code>av_packet_free（）</code>释放生成的结构。函数仅分配 AVPacket 本身，而不分配数据缓冲区。这些必须通过其他方式分配，例如使用<code>av_new_packet</code>。</p>
</li>
<li><p><code>AVFrame *av_frame_alloc()</code>：</p>
<p>  创建一个 AVFrame 并将其字段设置为默认值。失败时返回 NULL。必须使用<code>av_frame_free()</code>释放生成的结构。函数仅分配 AVFrame 本身，而不分配数据缓冲区。这些必须通过其他方式分配，例如使用<code>av_frame_get_buffer()</code> 。</p>
</li>
<li><p><code>void* av_malloc(size_t *size*)</code></p>
<p>  分配一个内存块，其对齐方式适合所有内存访问（包括 CPU 上可用的矢量）。类似于 malloc。主要用于为初始化后的<code>AVPacket</code>和<code>AVFrame</code>分配 data 内存。</p>
</li>
<li><p><code>int av_packet_from_data(AVPacket *pkt, uint8_t *data, int size)</code>:</p>
<p>  从已经使用 <code>av_malloc()</code> 分配内存的数据初始化引用计数的数据包。<code>pkt</code>指向要初始化的数据包，<code>data</code> 为由<code>av_malloc()</code>分配的数据缓冲区。成功返回 0，数据归基础 AVBuffer 所有。调用方可能无法通过其他方式访问数据。</p>
</li>
</ul>
<h2 id="AVCodec-和-AVCodecParameters补充"><a href="#AVCodec-和-AVCodecParameters补充" class="headerlink" title="AVCodec 和 AVCodecParameters补充"></a><code>AVCodec</code> 和 <code>AVCodecParameters</code>补充</h2><ul>
<li><code>AVCodec</code> 里面放的是 <strong>解码器的相关信息</strong> 。</li>
</ul>
<p><code>AVCodec</code> 是使用 <code>avcodec_find_decoder()</code> 函数获得的（见上文），传递个函数一个 <code>AVCodecID</code>，返回一个对应的解码器指针。这是引入 FFmpeg 库的时候，他初始化了一堆静态的编解码变量给你。</p>
<p>例如：传递的 <code>AVCodecID</code> 是 <code>AV_CODEC_ID_H265</code> ，就会返回与 <code>H265</code> 视频相关的 <code>AVCodec</code> 指针， <code>AVCodecID</code> 是 <code>AV_CODEC_ID_H264</code> ，就会返回与 <code>264</code> 视频相关的 <code>AVCodec</code> 指针。</p>
<p>只要是用 H264 编码的视频，使用的<strong>解码器</strong>都是一样的，用的是同一个 <code>AVCodec</code>。</p>
<ul>
<li><code>AVCodecParameters</code> 里面放的是 <strong>解码参数</strong>。</li>
</ul>
<p>虽然都是 H265 视频文件，但是他们的宽高，采样这些信息，可能会不一样，这些信息就存在<code>AVCodecParameters</code>里，</p>
<p>当 <code>avformat_open_input</code> 函数打开一个 MP4 的时候，解码参数就会放在 <code>codecpar</code> 字段里，如下：</p>
<p><code>int avformat_open_input(AVFormatContext** ps, const char* url, const AVInputFormat* fmt, AVDictionary** options)</code></p>
<p>但是如果直接获得的裸流，比如本问所描述的，没有文件供打开而获得 <code>AVCodecParameters</code>，因此需要使用<code>AVCodecParameters *avcodec_parameters_alloc()</code>和<code>int avcodec_parameters_from_context(struct AVCodecParameters *par,const AVCodecContext *codec)</code>来构建 AVCodecParameters 。</p>
<p>例如：ps 为 NULL 时，自动分配 AVFormatContext 并将其写入 ps 中，url 可以是网络 URL 也可以是本地文件名；fmt为 NULL 时，此参数强制使用个特定的输入格式，不为 NULL 时自动检测格式；options 参数被销毁，并替换为包含未找到的选项的字典，可能为 NULL。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">avformat_open_input(&amp;fmt_ctx, filename, <span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">AVCodecContext *avctx = avcodec_alloc_context3(<span class="literal">NULL</span>);</span><br><span class="line">ret = avcodec_parameters_to_context(avctx, fmt_ctx-&gt;streams[<span class="number">0</span>]-&gt;codecpar);</span><br></pre></td></tr></table></figure>

<p>上面的 <code>codecpar</code> 就是一个 <code>AVCodecParameters</code>，只需要用 <code>avcodec_parameters_to_context</code> 函数把 <code>codecpar</code> 的参数复制给 <code>AVCodecContext</code> 即可。</p>
<h2 id="解码流程"><a href="#解码流程" class="headerlink" title="解码流程"></a>解码流程</h2><h3 id="打开解码器的一般流程"><a href="#打开解码器的一般流程" class="headerlink" title="打开解码器的一般流程"></a>打开解码器的一般流程</h3><p><code>avcodec_alloc_context3()</code> ➔ <code>avcodec_parameters_to_context()</code> ➔ <code>avcodec_find_decoder()</code> ➔ <code>avcodec_open2()</code></p>
<p><code>avcodec_alloc_context3</code> 跟 <code>avcodec_open2</code> 这两个函数都可以接受 <code>AVCodec</code> 参数，选一个函数来接受即可，千万不要往这两个函数传递不一样的 <code>AVCodec</code> 参数。</p>
<p><code>avcodec_alloc_context3()</code> 传入 NULL，初始化一个解码器上下文。</p>
<p><code>avcodec_parameters_to_context()</code>将已有的解码参数复制到解码器上下文。</p>
<p><code>avcodec_find_decoder()</code>根据传入 ID 获得对应的解码器，根据传传入的解码器上下文和解码器信息打开解码器。</p>
<p>示例代码部分如下（为了简短均为没有检测返回值，实际应用时应该检测返回值）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="type">char</span> filename[] = <span class="string">&quot;juren-30s.mp4&quot;</span>;</span><br><span class="line"></span><br><span class="line">fmt_ctx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">avformat_open_input(&amp;fmt_ctx, filename,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">AVCodecContext *avctx = avcodec_alloc_context3(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">avcodec_parameters_to_context(avctx, fmt_ctx-&gt;streams[<span class="number">0</span>]-&gt;codecpar);</span><br><span class="line"></span><br><span class="line">AVCodec *codec = avcodec_find_decoder(avctx-&gt;codec_id);</span><br></pre></td></tr></table></figure>

<h2 id="H-265视频解码流程"><a href="#H-265视频解码流程" class="headerlink" title="H.265视频解码流程"></a>H.265视频解码流程</h2><p>首先，我们已经从网络接收到了待处理的一个个原始视频帧的缓冲区，里面是 H.265 视频裸流。这里注意，裸流可能不包含前四个字节：<code>0x00，0x00，0x00，0x01</code>，这四个字节是区分一帧的关键必须包含，如果没有就手动添加到<code>packet-&gt;data</code>开头，否则交由解码器解码时会报错。</p>
<p>开启一个发数据包的循环不断的将其作为 <code>AVPacket</code> 发给解码器。</p>
<p>解码器收到一个 <code>AVPacket</code>后，我们不一定立马就能从解码器读到一个 <code>AVFrame</code>，因为视频可能有 B 帧，一个单独的 B 帧无法得到一个完整的帧。需要继续给解码器提供后续的 <code>AVPacket</code> 才能得到一个完整的帧。同时在我们提供一个 <code>AVPacket</code> 后，也可能会得到两个完整的帧（由于 B 帧的存在）。</p>
<p>因此，我们发一个 <code>AVPacket</code>后，再开启一个循环读解码器，如果返回值为0，就说明得到一帧 YUV 信息，进行一些处理。如果返回值为<code>EAGAIN</code>，它表示解码器需要输入更多的 <code>AVPacket</code> ，才能解码出 <code>AVFrame</code>，我们就跳出第读解码器的循环，进入发 <code>AVPacket</code> 的循环继续发 <code>AVPacket</code> 。</p>
<p>当所有的 <code>AVPacket</code> 都已经发完时，解码器还可能在等待后续的 <code>AVPacket</code> 到来以解码之前收到的 B 帧，但此时我们已经没有 <code>AVPacket</code> 可以发送给解码器了。此时需要往解码器发一个 <code>size</code> 跟 <code>data</code> 都是 0 的 <code>AVPacket</code>（NULL）。这样解码器就会把它内部剩余的帧，全部都刷出来。</p>
<p>当解码器完全没有帧可以输出的时候，就会返回 <code>AVERROR_EOF</code>。</p>
<h2 id="解码后得到的-AVFrame"><a href="#解码后得到的-AVFrame" class="headerlink" title="解码后得到的 AVFrame"></a>解码后得到的 <code>AVFrame</code></h2><p>部分字段：</p>
<ul>
<li><code>frame-&gt;width</code>,<code>frame-&gt;height</code>：帧的宽高。</li>
<li><code>frame-&gt;pts</code>：帧的显示时间点</li>
<li><code>frame-&gt;pkt_duration</code>：帧的持续时间</li>
<li><code>frame-&gt;format</code>：帧的格式，有很多，整数枚举类型，0 代表 <code>AV_PIX_FMT_YUV420P</code>。</li>
<li><code>frame-&gt;key_frame</code>：（已弃用，使用 flags 中的<code>AV_FRAME_FLAG_KEY</code>代替）代表当前帧是不是关键帧，第一帧通常都是关键帧。I 帧为关键帧，可以单独解码出一个<code>AVFrame</code> ，B、P 帧不是关键帧，不能单独解码出一个<code>AVFrame</code> 。</li>
<li><code>frame-&gt;pict_type</code>：这个是 <code>AVPictureType</code> 枚举类型，1 代表 <code>AV_PICTURE_TYPE_I</code> ，即 I 帧。</li>
<li><code>frame-&gt;data</code>：存储帧的 Y、U、V 信息。</li>
</ul>
<p>解码的到的一般是 YUV420P 格式即上面<code>frame-&gt;format</code>的值：<code>AV_PIX_FMT_YUV420P</code>。它是一个存储帧的格式，以一定的方式存储 Y、U、V 信息（这方面展开说有些多，这里只看 YUV420P ）：</p>
<ul>
<li><p>Y 表示一帧的一块区域的明亮度，U 和 V 表示这块区域的色度与浓度。每个 Y U V 在内存中都占8位。</p>
</li>
<li><p>420 表示4:2:0采样，一个像素一个 Y，水平和垂直方向上都是每两个像素采一个 U 和 V。即每四个Y共用一组 UV 分量。内存上 Y 是 UV 大小的四倍。</p>
</li>
<li><p>P 表示Planar，YUV 按平面分开放，三个平面依次存放，YUV都是连续存储的：</p>
  <img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407161638520.png" alt="image-20240716163803984" style="zoom:80%;" /></li>
</ul>
<p><code>AVFrame</code> 结构体里面有一个 <code>data</code> 字段，存储了 YUV  数据， YUV420P 使用 planar 格式的内存布局来存储，YUV420 使用 packed 格式的内存布局来存储，这里以 YUV420P 为例：</p>
<p><code>data[0]</code> 会指向 Y 数据，<code>data[1]</code> 指向 U 数据，<code>data[2]</code> 指向 V 数据。还有一个 <code>linesize</code> 数组字段来管理这些数据的大小。例如<code>linesize[0]</code>表示<code>data[0]</code>指向的 Y 数据的一行的大小。YUV420P 的格式，U 或者 V 的大小应该是 Y的 4 分之一。</p>
<p>如果直接打印出 <code>linesize</code> 的值，会发现 U、V 的值是 Y 的二分之一。这是因为<code>linesize</code> 里存的是 <code>stride</code> 值。</p>
<p>stride 值 &#x3D; 图像宽度 * 分量数 * 单位样本宽度 &#x2F; 水平子采样因子 &#x2F; 8</p>
<p>分量数就是通道数，YUV420P 是 planer 内存布局 ，所以分量数是 1。单位样本宽度是指一个样本的宽度占多少位，YUV420P 为 16 位。</p>
<p>最重要的是水平采样因子，水平子采样因子指在水平方向上每多少个像素采样出一个色度样本。YUV420P 水平方向其实是每两个像素采样一个色度样本，所以是水平采样因子是 2。</p>
<p>还有一个<strong>垂直采样因子</strong>，YUV420P 的 <strong>垂直采样因子</strong> 也是 2 。但是 垂直采样因子不会影响 stride 值。</p>
<p><code>frame-&gt;linesize</code> 并不是 UV 分量的真实数据大小，而是一个 stride 值。并且从上面可以看出，如果使用的是 YUV420P 格式，会有：stride 值 &#x3D; width * 1 * 16 &#x2F; 2 &#x2F; 8 &#x3D; width，实际上就是帧的宽度 width。最终这个值可能还会内存对齐。</p>
<h2 id="YUV420P-格式的帧保存为图片"><a href="#YUV420P-格式的帧保存为图片" class="headerlink" title="YUV420P 格式的帧保存为图片"></a>YUV420P 格式的帧保存为图片</h2><p>通过<code>data</code>字段我们就可以得到帧的 Y、U、V 信息。 通过 <code>linesize</code> 字段我们可以的到他们的大小。但是一般情况下是<code>data</code>字段都是有<strong>内存对齐</strong>现象存在的。如果<code>linesize</code> 里存的 <code>stride</code> 值大小不足2的n次方，则会填充多余数据以达到2的n次方。例如，计算的到的<code>linesize[0]</code>为480，而它实际大小确是512。因此我们需要镜多余的数据剔除。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;frame-&gt;height; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(m_YuvBuf + a, frame-&gt;data[<span class="number">0</span>] + i * frame-&gt;linesize[<span class="number">0</span>], frame-&gt;width);</span><br><span class="line">    a += frame-&gt;width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;frame-&gt;height / <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(m_YuvBuf + a, frame-&gt;data[<span class="number">1</span>] + i * frame-&gt;linesize[<span class="number">1</span>], frame-&gt;width / <span class="number">2</span>);</span><br><span class="line">    a += frame-&gt;width / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;frame-&gt;height / <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(m_YuvBuf + a, frame-&gt;data[<span class="number">2</span>] + i * frame-&gt;linesize[<span class="number">2</span>], frame-&gt;width / <span class="number">2</span>);</span><br><span class="line">    a += frame-&gt;width / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，已经将 H265 裸流保存为了 YUV420P 的文件。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ffmpeg.org/">FFmpeg 官网</a></p>
<p><a href="https://ffmpeg.org/doxygen/trunk/index.html">FFmpeg doxygen文档</a></p>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>GSteamer 学习笔记</title>
    <url>/2024/06/02/GSteamer%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="GSteamer-学习笔记"><a href="#GSteamer-学习笔记" class="headerlink" title="GSteamer 学习笔记"></a>GSteamer 学习笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是笔者阅读 GStreamer 官方文档去学习 GStreamer 时的记录，大部分内容可以在 GStreamer 官方文档中找到。</p>
<p>笔者学习 GStreamer 的主要目的是：使用 GStreamer 处理从 TCP Socket 接收到的 H.265 裸流（使用 live555 的 testRTSPclient 程序从 RTSP URL 中获取到），将其解码并保存为 jpeg 图片。</p>
<p>笔者最终放弃使用 GStreamer 的想法，使用 FFmpeg 完成了上述目的。</p>
<h2 id="Elements-元素"><a href="#Elements-元素" class="headerlink" title="Elements 元素"></a>Elements 元素</h2><p>GStreamer 中最重要的对象是 <code>GstElement</code> 对象。元素是媒体管道的基本构建基块。使用的所有不同的高级组件都派生自 <code>GstElement</code> 。每个解码器、编码器、解复用器、视频或音频输出实际上都是一个 <code>GstElement</code></p>
<p>对于解码器元素，您将输入编码数据，该元素将输出解码数据。</p>
<p>源元素生成供管道使用的数据，例如从磁盘或声卡读取数据。源元素的可视化显示了我们将如何可视化源元素。我们总是在元素的右侧绘制一个源垫。源元素不接受数据，它们只生成数据。您可以在图中看到这一点，因为它只有一个源pad（在右侧）。源键盘只能生成数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407131343463.png" alt="image-20240713134242338"></p>
<h3 id="Filters-convertors-demuxers-muxers-and-codecs-滤波器、转换器、解复用器、多路复用器和编解码器"><a href="#Filters-convertors-demuxers-muxers-and-codecs-滤波器、转换器、解复用器、多路复用器和编解码器" class="headerlink" title="Filters, convertors, demuxers, muxers and codecs  滤波器、转换器、解复用器、多路复用器和编解码器"></a>Filters, convertors, demuxers, muxers and codecs  滤波器、转换器、解复用器、多路复用器和编解码器</h3><p>滤波器和类似滤波器的元件具有输入和输出 pad。它们对输入（接收）pad 上接收的数据进行操作，并将在输出（源）pad 上提供数据。此类元素的示例包括音量元素（滤波器）、视频缩放器（转换器）、Ogg 解复用器或 Vorbis 解码器。</p>
<p>类似过滤器的元件可以具有任意数量的源或接收垫。例如，视频解复用器将有一个接收器 pad 和几个 （1-N） 源 pad，一个用于容器格式中包含的每个基本流。另一方面，解码器只有一个源和接收 pad。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407131342444.png" alt="image-20240713134223075"></p>
<p>过滤器元素的可视化显示了我们将如何可视化类似过滤器的元素。此特定元素具有一个源垫和一个接收垫。接收输入数据的接收垫在元件的左侧绘制;源键盘仍然在右侧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407131342891.png" alt="image-20240713134254302"></p>
<p>具有多个输出 pad 的滤波元件的可视化显示了另一个类似滤波器的滤波器元件，该滤波元件具有多个输出（源）pad。例如，一个此类元素的示例可以是包含音频和视频的 Ogg 流的 Ogg 解复用器。一个源 pad 将包含基本视频流，另一个将包含基本音频流。解复用器通常会在创建新 pad 时触发信号。然后，应用程序程序员可以在信号处理程序中处理新的初级流。</p>
<h3 id="Sink-elements-接收器元素"><a href="#Sink-elements-接收器元素" class="headerlink" title="Sink elements 接收器元素"></a>Sink elements 接收器元素</h3><p>接收器元素是媒体管道中的端点。他们接受数据，但不产生任何东西。磁盘写入、声卡播放和视频输出都将由接收器元素实现。接收器元素的可视化显示接收器元素。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407131344169.png" alt="image-20240713134444575"></p>
<h3 id="Creating-a-GstElement-创建-GstElement"><a href="#Creating-a-GstElement-创建-GstElement" class="headerlink" title="Creating a GstElement 创建 GstElement"></a>Creating a <code>GstElement</code> 创建 <code>GstElement</code></h3><p>创建元素的最简单方法是使用 <code>gst_element_factory_make ()</code> .此函数采用工厂名称和新创建的元素的元素名称。例如，元素的名称是稍后可用于在 bin 中查找元素的名称。该名称也将用于调试输出。可以作为 name 参数传递 <code>NULL</code> 以获取唯一的默认名称。</p>
<p>当您不再需要该元素时，您需要使用 <code>gst_object_unref ()</code> 取消引用它。这会将元素的引用计数减少 1。元素在创建时的引用计数为 1。当 refcount 减少到 0 时，元素将被完全销毁。</p>
<p>下面的示例 [1] 展示了如何从名为 fakesrc 的元素工厂创建名为 source 的元素。它检查创建是否成功。检查后，它会取消引用元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    GstElement *element;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init GStreamer */</span></span><br><span class="line">    gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create element */</span></span><br><span class="line">    element = gst_element_factory_make (<span class="string">&quot;fakesrc&quot;</span>, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!element) &#123;</span><br><span class="line">        g_print (<span class="string">&quot;Failed to create element of type &#x27;fakesrc&#x27;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gst_object_unref (GST_OBJECT (element));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gst_element_factory_make</code> 实际上是两个函数组合的简写。 <code>GstElement</code> 对象是从工厂创建的。要创建元素，您必须使用唯一的工厂名称访问 <code>GstElementFactory</code> 对象。这是用 <code>gst_element_factory_find ()</code> .</p>
<p>以下代码片段用于获取可用于创建 fakesrc 元素（假数据源）的工厂。该函数<code>gst_element_factory_create ()</code> 将使用元素工厂创建具有给定名称的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span>  argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    GstElementFactory *factory;</span><br><span class="line">    GstElement * element;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init GStreamer */</span></span><br><span class="line">    gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create element, method #2 */</span></span><br><span class="line">    factory = gst_element_factory_find (<span class="string">&quot;fakesrc&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!factory) &#123;</span><br><span class="line">        g_print (<span class="string">&quot;Failed to find factory of type &#x27;fakesrc&#x27;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    element = gst_element_factory_create (factory, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!element) &#123;</span><br><span class="line">        g_print (<span class="string">&quot;Failed to create element, even though its factory exists!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gst_object_unref (GST_OBJECT (element));</span><br><span class="line">    gst_object_unref (GST_OBJECT (factory));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用元素作为-GObject"><a href="#使用元素作为-GObject" class="headerlink" title="使用元素作为 GObject"></a>使用元素作为 <code>GObject</code></h3><p>A <code>GstElement</code> 可以具有多个属性，这些属性是使用标准 <code>GObject</code> 属性实现的。因此，支持查询、设置和获取属性值 <code>GParamSpecs</code> 的常用 <code>GObject</code> 方法。</p>
<p>每个 <code>GstElement</code> 都从其父 <code>GstObject</code> 级继承至少一个属性：“name”属性。这是我们提供给函数 <code>gst_element_factory_make ()</code> 的名称，或者 <code>gst_element_factory_create ()</code> .可以使用函数 <code>gst_object_set_name</code> 获取和设置此属性，或者 <code>gst_object_get_name</code> 使用如下所示的 <code>GObject</code> 属性机制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    GstElement *element;</span><br><span class="line">    gchar *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init GStreamer */</span></span><br><span class="line">    gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create element */</span></span><br><span class="line">    element = gst_element_factory_make (<span class="string">&quot;fakesrc&quot;</span>, <span class="string">&quot;source&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get name */</span></span><br><span class="line">    g_object_get (G_OBJECT (element), <span class="string">&quot;name&quot;</span>, &amp;name, <span class="literal">NULL</span>);</span><br><span class="line">    g_print (<span class="string">&quot;The name of the element is &#x27;%s&#x27;.\n&quot;</span>, name);</span><br><span class="line">    g_free (name);</span><br><span class="line"></span><br><span class="line">    gst_object_unref (GST_OBJECT (element));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数插件都提供额外的属性，以提供有关其配置或配置元素的更多信息。 <code>gst-inspect</code> 是查询特定元素属性的有用工具，它还将使用属性自省来简要说明属性的功能以及它支持的参数类型和范围。有关 的详细信息，请参阅附录中的 gst-inspect <code>gst-inspect</code> 。</p>
<p>有关 <code>GObject</code> 属性的更多信息，我们建议您阅读 GObject 手册和 Glib 对象系统简介。</p>
<p><code>GstElement</code> 还提供了各种 <code>GObject</code> 信号，可用作灵活的回调机制。在这里，您也可以用来 <code>gst-inspect</code> 查看特定元素支持哪些信号。总之，信号和属性是元素和应用程序交互的最基本方式。</p>
<h3 id="有关元件工厂的更多信息"><a href="#有关元件工厂的更多信息" class="headerlink" title="有关元件工厂的更多信息"></a>有关元件工厂的更多信息</h3><p>在上一节中，我们简要介绍了 <code>GstElementFactory</code> 该对象作为创建元素实例的一种方式。然而，元素工厂远不止于此。元素工厂是从 GStreamer 注册表中检索到的基本类型，它们描述了 GStreamer 可以创建的所有插件和元素。这意味着元素工厂对于自动元素实例化（例如自动插件的作用）和创建可用元素列表非常有用。</p>
<h3 id="使用工厂获取有关元素的信息"><a href="#使用工厂获取有关元素的信息" class="headerlink" title="使用工厂获取有关元素的信息"></a>使用工厂获取有关元素的信息</h3><p>像 <code>gst-inspect</code> 这样的工具将提供有关元素的一些通用信息，例如编写插件的人、描述性名称（和简称）、排名和类别。该类别可用于获取可以使用此元素工厂创建的元素的类型。类别的示例包括 <code>Codec/Decoder/Video</code> （视频解码器）、 <code>Codec/Encoder/Video</code> （视频编码器）、 <code>Source/Video</code> （视频生成器）、 <code>Sink/Video</code> （视频输出），当然，所有这些也都存在于音频中。然后， <code>Codec/Demuxer</code> <code>Codec/Muxer</code> 还有更多。 <code>gst-inspect</code> 将列出所有工厂的列表，并 <code>gst-inspect &lt;factory-name&gt;</code> 列出上述所有信息，以及更多。</p>
<p>可以使用 <code>gst_registry_pool_feature_list (GST_TYPE_ELEMENT_FACTORY)</code> 来获取 GStreamer 所知道的所有元素工厂的列表。</p>
<h3 id="找出元素可以包含哪些-pad"><a href="#找出元素可以包含哪些-pad" class="headerlink" title="找出元素可以包含哪些 pad"></a>找出元素可以包含哪些 pad</h3><p>也许元素工厂最强大的功能是它们包含元素可以生成的的完整描述，以及这些 pad 的功能（通俗地说：哪些类型的媒体可以通过这些 pad 进行流式传输），而无需实际将这些插件加载到内存中。这可用于为编码器提供解码器选择列表，也可以用于媒体播放器的自动插入目的。当前所有基于 GStreamer 的媒体播放器和自动插件都以这种方式工作。我们将在 <code>GstPad</code> <code>GstCaps</code> 下一章中更深入地了解这些功能：Pads 和 capabilities</p>
<h3 id="链接元素"><a href="#链接元素" class="headerlink" title="链接元素"></a>链接元素</h3><p>通过将源元素与零个或多个类似筛选器的元素以及最终的接收器元素链接起来，可以设置媒体管道。数据将流经元素。这是 GStreamer 中媒体处理的基本概念。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407131413943.png" alt="image-20240713141346614"></p>
<p>通过链接这三个元素，我们创建了一个非常简单的元素链。这样做的效果是，源元素的输出将用作类似过滤器的元素的输入。类似筛选器的元素将对数据执行某些操作，并将结果发送到最终的接收器元素。</p>
<p>在代码中，上面的图是这样写的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    GstElement *pipeline;</span><br><span class="line">    GstElement *source, *filter, *sink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init */</span></span><br><span class="line">    gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create pipeline */</span></span><br><span class="line">    pipeline = gst_pipeline_new (<span class="string">&quot;my-pipeline&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create elements */</span></span><br><span class="line">    source = gst_element_factory_make (<span class="string">&quot;fakesrc&quot;</span>, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">    filter = gst_element_factory_make (<span class="string">&quot;identity&quot;</span>, <span class="string">&quot;filter&quot;</span>);</span><br><span class="line">    sink = gst_element_factory_make (<span class="string">&quot;fakesink&quot;</span>, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* must add elements to pipeline before linking them */</span></span><br><span class="line">    gst_bin_add_many (GST_BIN (pipeline), source, filter, sink, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* link */</span></span><br><span class="line">    <span class="keyword">if</span> (!gst_element_link_many (source, filter, sink, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        g_warning (<span class="string">&quot;Failed to link elements!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [..]</span><br></pre></td></tr></table></figure>

<p>对于更具体的行为，还有函数 <code>gst_element_link ()</code> 和 <code>gst_element_link_pads ()</code> .您还可以获取对单个焊盘的引用，并使用各种 <code>gst_pad_link_* ()</code> 功能链接这些焊盘。有关更多详细信息，请参阅 API 参考。</p>
<p>重要提示：在链接元素或管道之前，必须将元素添加到图格或管道中，因为将元素添加到图格中会断开任何已存在的链接。此外，不能直接链接不在同一 bin 或管道中的元素;如果要链接不同层次结构级别的元素或填充物，则需要使用 ghost pads（稍后将详细介绍 ghost pads）。</p>
<h3 id="元素状态"><a href="#元素状态" class="headerlink" title="元素状态"></a>元素状态</h3><p>创建后，元素实际上不会执行任何操作。您需要更改元素状态以使其执行某些操作。GStreamer 知道四种元素状态，每种状态都有非常具体的含义。这四个状态是：</p>
<ul>
<li><p><code>GST_STATE_NULL</code> ：这是默认状态。在此状态下不会分配任何资源，因此，过渡到该状态将释放所有资源。当元素的 refcount 达到 0 并被释放时，该元素必须处于此状态。</p>
</li>
<li><p><code>GST_STATE_READY</code> ：在就绪状态下，元素已分配其所有全局资源，即可以保留在流中的资源。您可以考虑打开设备、分配缓冲区等。但是，流不会在此状态下打开，因此流位置自动为零。如果以前打开了流，则应在此状态下关闭该流，并应重置位置、属性等。</p>
</li>
<li><p><code>GST_STATE_PAUSED</code> ：在此状态下，元素已打开流，但未主动处理它。允许元素修改流的位置、读取和处理数据等，以便在状态更改为 PAUSE 后立即准备播放，但不允许播放会使时钟运行的数据。总之，PAUSED 与 PLAYING 相同，但没有运行时钟。</p>
<p>  进入 <code>PAUSED</code> 状态的元素应为尽快进入 <code>PLAYING</code> 状态做好准备。例如，视频或音频输出将等待数据到达并对其进行排队，以便它们可以在状态更改后立即播放。此外，视频接收器已经可以播放第一帧（因为这还不会影响时钟）。自动插拔器可以使用相同的状态转换来将管道插入在一起。但是，大多数其他元素（如编解码器或筛选器）不需要在此状态下显式执行任何操作。</p>
</li>
<li><p><code>GST_STATE_PLAYING</code> ：在 <code>PLAYING</code> 状态中，元素的操作与 <code>PAUSED</code> 状态中的元素完全相同，只是时钟现在运行。</p>
</li>
</ul>
<p>可以使用函数 <code>gst_element_set_state ()</code> 更改元素的状态。如果将元素设置为另一种状态，GStreamer 将在内部遍历所有中间状态。因此，如果将元素从 <code>NULL</code> 设置为 <code>PLAYING</code> ，GStreamer 将在内部将元素设置为介 <code>READY</code> 于 和 <code>PAUSED</code> 之间。</p>
<p>移动到 <code>GST_STATE_PLAYING</code> 时，管道将自动处理数据。它们不需要以任何形式进行迭代。在内部，GStreamer 将启动线程来为他们承担此任务。GStreamer 还将负责将消息从管道的线程切换到应用程序自己的线程，方法是使用 <code>GstBus</code> .有关详细信息，请参阅 Bus 文档。</p>
<p>当您将 bin 或管道设置为特定目标状态时，它通常会自动将状态更改传播到 bin 或管道中的所有元素，因此通常只需设置顶级管道的状态即可启动或关闭管道。但是，当动态地将元素添加到已经运行的管道中时，例如从“pad 添加”信号回调中，您需要使用 <code>gst_element_set_state ()</code> 或 <code>gst_element_sync_state_with_parent ()</code> 自行将其设置为所需的目标状态。</p>
<h2 id="Bins-箱"><a href="#Bins-箱" class="headerlink" title="Bins 箱"></a>Bins 箱</h2><p>bin 是容器元素。您可以将元素添加到 bin 中。由于 bin 本身就是一个元素，因此 bin 的处理方式与任何其他元素相同。因此，上一章（元素）也适用于 bin。</p>
<p>bin 允许您将一组链接的元素组合成一个逻辑元素。您不再处理单个元素，而只处理一个元素，即 bin。我们将看到，当您要构建复杂的管道时，这非常强大，因为它允许您将管道分解为更小的块。</p>
<p>bin 还将管理其中包含的元素。它将对元素执行状态更改，以及收集和转发总线消息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407131424109.png" alt="image-20240713142442923"></p>
<p>GStreamer 程序员可以使用一种特殊类型的 bin：</p>
<ul>
<li>管道：管理所包含元素的同步和总线消息的通用容器。顶层 bin 必须是一个管道，因此每个应用程序至少需要其中一个。</li>
</ul>
<h3 id="Creating-a-bin"><a href="#Creating-a-bin" class="headerlink" title="Creating a bin"></a>Creating a bin</h3><p>bin 的创建方式与其他元素的创建方式相同，即使用元素工厂。还有便利功能可用（ <code>gst_bin_new ()</code> 和 <code>gst_pipeline_new ()</code> ）。要将元素添加到 bin 中或从 bin 中删除元素，可以使用 <code>gst_bin_add ()</code> 和 <code>gst_bin_remove ()</code> 。请注意，添加元素的 bin 将获得该元素的所有权。如果销毁 bin，则该元素将与它一起取消引用。如果从 bin 中删除元素，则该元素将自动取消引用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    GstElement *bin, *pipeline, *source, *sink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init */</span></span><br><span class="line">    gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create */</span></span><br><span class="line">    pipeline = gst_pipeline_new (<span class="string">&quot;my_pipeline&quot;</span>);</span><br><span class="line">    bin = gst_bin_new (<span class="string">&quot;my_bin&quot;</span>);</span><br><span class="line">    source = gst_element_factory_make (<span class="string">&quot;fakesrc&quot;</span>, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">    sink = gst_element_factory_make (<span class="string">&quot;fakesink&quot;</span>, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First add the elements to the bin */</span></span><br><span class="line">    gst_bin_add_many (GST_BIN (bin), source, sink, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* add the bin to the pipeline */</span></span><br><span class="line">    gst_bin_add (GST_BIN (pipeline), bin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* link the elements */</span></span><br><span class="line">    gst_element_link (source, sink);</span><br><span class="line"></span><br><span class="line">    [..]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有多种功能可以在 bin 中查找元素。最常用的是 <code>gst_bin_get_by_name ()</code> 和 <code>gst_bin_get_by_interface ()</code> 。您还可以使用函数 <code>gst_bin_iterate_elements ()</code> 循环访问 bin 包含的所有元素。有关详细信息，请参阅<code>GstBin</code>API 参考。</p>
<h3 id="Bin-管理其子项的状态"><a href="#Bin-管理其子项的状态" class="headerlink" title="Bin 管理其子项的状态"></a>Bin 管理其子项的状态</h3><p>Bins 管理其中包含的所有元素的状态。如果使用 <code>gst_element_set_state ()</code> 将 bin（或管道，这是一种特殊的顶级 bin 类型）设置为特定目标状态，它将确保其中包含的所有元素也将设置为此状态。这意味着通常只需设置顶级管道的状态即可启动或关闭管道。</p>
<p>bin 将对其从 sink 元素到源元素的所有子元素执行状态更改。这可确保下游元素在上游元素被带到 <code>PAUSED</code> 或 <code>PLAYING</code> 时准备好接收数据。同样，在关闭时，接收器元素将设置为 <code>READY</code> or <code>NULL</code> first，这将导致上游元素收到 <code>FLUSHING</code> 错误，并在元素设置为 <code>READY</code> or <code>NULL</code> 状态之前停止流线程。</p>
<p>但是请注意，如果元素被添加到已经在运行的 bin 或管道中，例如从“pad-added”信号回调中，其状态不会自动与添加它的 bin 或管道的当前状态或目标状态保持一致。相反，您需要自己使用 <code>gst_element_set_state ()</code> 或 <code>gst_element_sync_state_with_parent ()</code> 在将元素添加到已运行的管道时将其设置为所需的目标状态。</p>
<h2 id="Bus-总线"><a href="#Bus-总线" class="headerlink" title="Bus 总线"></a>Bus 总线</h2><p>总线是一个简单的系统，它负责将消息从流式处理线程转发到其自己的线程上下文中的应用程序。总线的优点是，即使 GStreamer 本身是大量线程的，应用程序也不需要线程感知即可使用 GStreamer。</p>
<p>默认情况下，每个管道都包含总线，因此应用程序不需要创建总线或任何内容。应用程序唯一应该做的就是在总线上设置消息处理程序，这类似于对象的信号处理程序。当主循环运行时，会定期检查总线是否有新消息，当有消息可用时会调用回调。</p>
<p>有两种不同的总线使用方式：</p>
<ul>
<li><p>运行 GLib&#x2F;Gtk+ 主循环（或自己定期迭代默认的 GLib 主上下文）并将某种监视连接到总线上。这样，GLib 主循环将检查总线是否有新消息，并在有消息时通知您。</p>
<p>  通常，在这种情况下，您会使用 <code>gst_bus_add_watch ()</code> or <code>gst_bus_add_signal_watch ()</code> 。</p>
<p>  要使用总线，请使用 <code>gst_bus_add_watch ()</code> 将消息处理程序附加到管道的总线上。每当管道向总线发出消息时，都会调用此处理程序。在此处理程序中，检查信号类型（请参阅下一节）并执行相应的操作。处理程序的返回值应该是 <code>TRUE</code> 保持处理程序连接到总线，返回 <code>FALSE</code> 以删除它。</p>
</li>
<li><p>自行检查 bus 上的消息。这可以使用 <code>gst_bus_peek ()</code> 和&#x2F;或 <code>gst_bus_poll ()</code> 来完成。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> GMainLoop *loop;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> gboolean</span><br><span class="line"><span class="title function_">my_bus_callback</span> <span class="params">(GstBus * bus, GstMessage * message, gpointer data)</span></span><br><span class="line">&#123;</span><br><span class="line">  g_print (<span class="string">&quot;Got %s message\n&quot;</span>, GST_MESSAGE_TYPE_NAME (message));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (GST_MESSAGE_TYPE (message)) &#123;</span><br><span class="line">    <span class="keyword">case</span> GST_MESSAGE_ERROR:&#123;</span><br><span class="line">      GError *err;</span><br><span class="line">      gchar *debug;</span><br><span class="line"></span><br><span class="line">      gst_message_parse_error (message, &amp;err, &amp;debug);</span><br><span class="line">      g_print (<span class="string">&quot;Error: %s\n&quot;</span>, err-&gt;message);</span><br><span class="line">      g_error_free (err);</span><br><span class="line">      g_free (debug);</span><br><span class="line"></span><br><span class="line">      g_main_loop_quit (loop);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> GST_MESSAGE_EOS:</span><br><span class="line">      <span class="comment">/* end-of-stream */</span></span><br><span class="line">      g_main_loop_quit (loop);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">/* unhandled message */</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* we want to be notified again the next time there is a message</span></span><br><span class="line"><span class="comment">   * on the bus, so returning TRUE (FALSE means we want to stop watching</span></span><br><span class="line"><span class="comment">   * for messages on the bus and our callback should not be called again)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gint</span><br><span class="line"><span class="title function_">main</span> <span class="params">(gint argc, gchar * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  GstElement *pipeline;</span><br><span class="line">  GstBus *bus;</span><br><span class="line">  guint bus_watch_id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* init */</span></span><br><span class="line">  gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* create pipeline, add handler */</span></span><br><span class="line">  pipeline = gst_pipeline_new (<span class="string">&quot;my_pipeline&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* adds a watch for new message on our pipeline&#x27;s message bus to</span></span><br><span class="line"><span class="comment">   * the default GLib main context, which is the main context that our</span></span><br><span class="line"><span class="comment">   * GLib main loop is attached to below</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));</span><br><span class="line">  bus_watch_id = gst_bus_add_watch (bus, my_bus_callback, <span class="literal">NULL</span>);</span><br><span class="line">  gst_object_unref (bus);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* [...] */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* create a mainloop that runs/iterates the default GLib main context</span></span><br><span class="line"><span class="comment">   * (context NULL), in other words: makes the context check if anything</span></span><br><span class="line"><span class="comment">   * it watches for has happened. When a message has been posted on the</span></span><br><span class="line"><span class="comment">   * bus, the default main context will automatically call our</span></span><br><span class="line"><span class="comment">   * my_bus_callback() function to notify us of that message.</span></span><br><span class="line"><span class="comment">   * The main loop will be run until someone calls g_main_loop_quit()</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  loop = g_main_loop_new (<span class="literal">NULL</span>, FALSE);</span><br><span class="line">  g_main_loop_run (loop);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* clean up */</span></span><br><span class="line">  gst_element_set_state (pipeline, GST_STATE_NULL);</span><br><span class="line">  gst_object_unref (pipeline);</span><br><span class="line">  g_source_remove (bus_watch_id);</span><br><span class="line">  g_main_loop_unref (loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的是要知道处理程序将在 mainloop 的线程上下文中调用。这意味着管道和应用程序之间通过总线的交互是异步的，因此不适合某些实时目的，例如音轨之间的交叉淡入淡出、执行（理论上）无缝播放或视频效果。所有这些事情都应该在管道上下文中完成，这可以通过编写 GStreamer 插件来获得最简单的操作。不过，它对于其主要目的非常有用：将消息从管道传递到应用程序。这种方法的优点是 GStreamer 在内部执行的所有线程都对应用程序隐藏，应用程序开发人员根本不需要担心线程问题。</p>
<p>请注意，如果您使用的是默认的 GLib 主环路集成，则可以连接到总线上的“消息”信号，而不是连接总线。这样，您就不必 <code>switch()</code> 处理所有可能的消息类型;只需以 的形式 <code>message::&lt;type&gt;</code> 连接到感兴趣的信号，其中 <code>&lt;type&gt;</code> 是特定的消息类型（有关消息类型的说明，请参阅下一节）。</p>
<p>上面的片段也可以写成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GstBus *bus;</span><br><span class="line"></span><br><span class="line">[..]</span><br><span class="line"></span><br><span class="line">bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));</span><br><span class="line">gst_bus_add_signal_watch (bus);</span><br><span class="line">g_signal_connect (bus, <span class="string">&quot;message::error&quot;</span>, G_CALLBACK (cb_message_error), <span class="literal">NULL</span>);</span><br><span class="line">g_signal_connect (bus, <span class="string">&quot;message::eos&quot;</span>, G_CALLBACK (cb_message_eos), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">[..]</span><br></pre></td></tr></table></figure>

<p>如果不使用 GLib 主循环，则默认情况下异步消息信号将不可用。但是，您可以安装一个自定义同步处理程序，该处理程序用于唤醒自定义主循环并用于 <code>gst_bus_async_signal_func ()</code> 发出信号。（有关详细信息，另请参阅文档）</p>
<h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>GStreamer 有一些预定义的消息类型，可以通过总线传递。但是，这些消息是可扩展的。插件可以定义其他消息，应用程序可以决定为这些消息提供特定代码或忽略它们。强烈建议所有应用程序至少通过向用户提供视觉反馈来处理错误消息。</p>
<p>所有消息都有消息源、类型和时间戳。消息源可用于查看发出消息的元素。例如，对于某些消息，只有顶级管道发出的消息对大多数应用程序（例如状态更改通知）感兴趣。下面是所有消息的列表，以及它们的作用以及如何解析消息特定内容的简短说明。</p>
<h2 id="Pads-和-capabilities"><a href="#Pads-和-capabilities" class="headerlink" title="Pads 和 capabilities"></a>Pads 和 capabilities</h2><p>正如我们在 Elements 中看到的，pads 是元素与外界的接口。数据从一个元素的 source pad 流到另一个元素的 sink pad。元素可以处理的特定类型的媒体将由 pads 的功能公开。我们将在本章后面详细讨论功能（请参阅 <a href="https://gstreamer.freedesktop.org/documentation/application-development/basics/pads.html#capabilities-of-a-pad">Capabilities of a pad</a>）。</p>
<h3 id="Pads"><a href="#Pads" class="headerlink" title="Pads"></a>Pads</h3><p>Pad 类型由两个属性定义：其方向和可用性。正如我们之前提到的，GStreamer 定义了两个 pad 方向：源 pad 和接收 pad。该术语是从元素内部的视图定义的：元素在其接收 pad 上接收数据，并在其源 pad 上生成数据。从原理上讲，接收 pad 绘制在元素的左侧，而源 pad 绘制在元素的右侧。在此类图形中，数据从左向右流动。</p>
<p>与 pad 可用性相比，pad 方向非常简单。pad 可以有三种可用性中的任何一种：always, sometimes and on-request。这三种类型的含义正如它所说的那样：always pad 始终存在，sometimes pad 只存在于特定情况下（并且可以随机消失），并且 on-request pad 仅在应用程序明确请求时才会出现。</p>
<h3 id="Dynamic-or-sometimes-pads"><a href="#Dynamic-or-sometimes-pads" class="headerlink" title="Dynamic (or sometimes) pads"></a>Dynamic (or sometimes) pads</h3><p>创建元素时，某些元素可能没有所有 pad。例如，使用 Ogg 解复用器元件时可能会发生这种情况。当该元素在 Ogg 流中检测到这样的流时，它将读取 Ogg 流并为每个包含的基本流（vorbis、theora）创建动态 pad。同样，它将在流结束时删除 pad。例如，此原理对于解复用器元件非常有用。</p>
<p>运行 <code>gst-inspect-1.0 oggdemux</code> 将显示该元素只有一个焊盘：一个名为“sink”的 sink 焊盘。其他焊盘处于“休眠状态”。您可以在 pad 模板中看到这一点，因为有一个“可用性：有时”属性。根据您播放的 Ogg 文件的类型，将创建 pad。我们将看到，当您要创建动态管道时，这一点非常重要。您可以将信号处理程序附加到元素，以便在元素从其“sometimes” pad 模板之一创建新 pad 时通知您。以下代码段是执行此操作的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gst/gst.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cb_new_pad</span> <span class="params">(GstElement *element, GstPad *pad, gpointer data)</span></span><br><span class="line">&#123;</span><br><span class="line">    gchar *name;</span><br><span class="line"></span><br><span class="line">    name = gst_pad_get_name (pad);</span><br><span class="line">    g_print (<span class="string">&quot;A new pad %s was created\n&quot;</span>, name);</span><br><span class="line">    g_free (name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* here, you would setup a new pad link for the newly created pad */</span></span><br><span class="line">    [..]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">    <span class="title function_">main</span> <span class="params">(<span class="type">int</span>   argc,</span></span><br><span class="line"><span class="params">          <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    GstElement *pipeline, *source, *demux;</span><br><span class="line">    GMainLoop *loop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init */</span></span><br><span class="line">    gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create elements */</span></span><br><span class="line">    pipeline = gst_pipeline_new (<span class="string">&quot;my_pipeline&quot;</span>);</span><br><span class="line">    source = gst_element_factory_make (<span class="string">&quot;filesrc&quot;</span>, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">    g_object_set (source, <span class="string">&quot;location&quot;</span>, argv[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    demux = gst_element_factory_make (<span class="string">&quot;oggdemux&quot;</span>, <span class="string">&quot;demuxer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* you would normally check that the elements were created properly */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* put together a pipeline */</span></span><br><span class="line">    gst_bin_add_many (GST_BIN (pipeline), source, demux, <span class="literal">NULL</span>);</span><br><span class="line">    gst_element_link_pads (source, <span class="string">&quot;src&quot;</span>, demux, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* listen for newly created pads */</span></span><br><span class="line">    g_signal_connect (demux, <span class="string">&quot;pad-added&quot;</span>, G_CALLBACK (cb_new_pad), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start the pipeline */</span></span><br><span class="line">    gst_element_set_state (GST_ELEMENT (pipeline), GST_STATE_PLAYING);</span><br><span class="line">    loop = g_main_loop_new (<span class="literal">NULL</span>, FALSE);</span><br><span class="line">    g_main_loop_run (loop);</span><br><span class="line"></span><br><span class="line">    [..]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅从“pad-added”回调中向管道添加元素的情况并不少见。如果执行此操作，请不要忘记使用 <code>gst_element_set_state ()</code> 或 <code>gst_element_sync_state_with_parent ()</code> 将新添加元素的状态设置为管道的目标状态。</p>
<h3 id="Request-pads"><a href="#Request-pads" class="headerlink" title="Request pads"></a>Request pads</h3><p>元素也可以具有请求 pad。这些 pad 不是自动创建的，而只是按需创建。这对于多路复用器、聚合器和 T 恤元件非常有用。聚合器是将多个输入流的内容合并到一个输出流中的元素。Tee 元素则相反：它们是具有一个输入流并将此流复制到每个输出 pad 的元素，这些输出 pad 是根据请求创建的。每当应用程序需要流的另一个副本时，它只需从 tee 元素请求新的输出 pad 即可。</p>
<p>以下代码段演示如何从“tee”元素请求新的输出 pad ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">some_function</span> <span class="params">(GstElement * tee)</span></span><br><span class="line">&#123;</span><br><span class="line">    GstPad *pad;</span><br><span class="line">    gchar *name;</span><br><span class="line"></span><br><span class="line">    pad = gst_element_request_pad_simple (tee, <span class="string">&quot;src%d&quot;</span>);</span><br><span class="line">    name = gst_pad_get_name (pad);</span><br><span class="line">    g_print (<span class="string">&quot;A new pad %s was created\n&quot;</span>, name);</span><br><span class="line">    g_free (name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* here, you would link the pad */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* [..] */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* and, after doing that, free our reference */</span></span><br><span class="line">    gst_object_unref (GST_OBJECT (pad));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该 <code>gst_element_request_pad_simple ()</code> 方法可用于根据 pad 模板的名称从元素中获取 pad。也可以请求与另一个 pad 模板兼容的 pad。如果要将元件链接到多路复用器元件，并且需要请求兼容的 pad ，这将非常有用。该方法 <code>gst_element_get_compatible_pad ()</code> 可用于请求兼容的 pad，如下例所示。它将从任何输入的 Ogg 多路复用器请求兼容 pad。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">link_to_multiplexer</span> <span class="params">(GstPad * tolink_pad, GstElement * mux)</span></span><br><span class="line">&#123;</span><br><span class="line">  GstPad *pad;</span><br><span class="line">  gchar *srcname, *sinkname;</span><br><span class="line"></span><br><span class="line">  srcname = gst_pad_get_name (tolink_pad);</span><br><span class="line">  pad = gst_element_get_compatible_pad (mux, tolink_pad, <span class="literal">NULL</span>);</span><br><span class="line">  gst_pad_link (tolink_pad, pad);</span><br><span class="line">  sinkname = gst_pad_get_name (pad);</span><br><span class="line">  gst_object_unref (GST_OBJECT (pad));</span><br><span class="line"></span><br><span class="line">  g_print (<span class="string">&quot;A new pad %s was created and linked to %s\n&quot;</span>, sinkname, srcname);</span><br><span class="line">  g_free (sinkname);</span><br><span class="line">  g_free (srcname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Capabilities-of-a-pad"><a href="#Capabilities-of-a-pad" class="headerlink" title="Capabilities of a pad"></a>Capabilities of a pad</h3><p>由于 pad 在外界如何看待元素方面起着非常重要的作用，因此使用 capabilities 实现了一种机制来描述可以流过 pad 或当前流经 pad 的数据。在这里，我们将简要描述什么是 capabilities 以及如何使用它们，足以理解这个概念。</p>
<p> capabilities 附加到 pad 模板和 pad 上。对于 pad 模板，它将描述可能流式传输通过从此模板创建的 pad 的媒体类型。对于 pad ，它可以是可能的上限列表（通常是 pad 模板功能的副本），在这种情况下， pad 尚未协商，或者它是当前流经此 pad 的媒体类型，在这种情况下， pad 已经协商好了。</p>
<h3 id="Dissecting-capabilities-解剖能力"><a href="#Dissecting-capabilities-解剖能力" class="headerlink" title="Dissecting capabilities 解剖能力"></a>Dissecting capabilities 解剖能力</h3><p>打击垫的功能在 <code>GstCaps</code> 对象中描述。在内部，a <code>GstCaps</code> 将包含一个或多个 <code>GstStructure</code> 将描述一种媒体类型的内容。协商 pad 将具有仅包含一个结构的功能集。此外，此结构将仅包含固定值。对于未协商的 pad 或 pad 模板，这些约束不成立。</p>
<p>例如，下面是“vorbisdec”元素功能的转储，您将通过运行 <code>gst-inspect vorbisdec</code> .您将看到两个 pad ：源 pad 和接收 pad 。这两个 pad 始终可用，并且都附加了功能。接收器 pad 将接受 vorbis 编码的音频数据，媒体类型为“audio&#x2F;x-vorbis”。源 pad 将用于将原始（解码）音频样本发送到下一个元素，其原始音频媒体类型（在本例中为“audio&#x2F;x-raw”）。源 pad 还将包含音频采样率和通道数量的属性，以及一些您现在无需担心的属性。</p>
<h3 id="使用什么-capabilities"><a href="#使用什么-capabilities" class="headerlink" title="使用什么 capabilities"></a>使用什么 capabilities</h3><p>capabilities（简称：caps）描述在两个 pad 之间传输的数据类型，或者一个 pad（模板）支持的数据类型。这使得它们对于各种目的非常有用：</p>
<ul>
<li><p>Autoplugging：根据其功能自动查找要链接到 pad 的元素。所有自动插入器都使用此方法。</p>
</li>
<li><p>Compatibility detection：当两个 pad 连接时，GStreamer 可以验证两个 pad 是否正在谈论相同的媒体类型。连接两个 pad 并检查它们是否兼容的过程称为“上限协商”。</p>
</li>
<li><p>Metadata：通过读取 pad 的功能，应用程序可以提供有关通过 pad 传输的媒体类型的信息，即有关当前正在播放的流的信息。</p>
</li>
<li><p>Filtering：应用程序可以使用功能将两个 pad 之间流式传输的可能媒体类型限制为其支持的流类型的特定子集。例如，应用程序可以使用“过滤上限”来设置应在两个 pad 之间流式传输的特定（固定或非固定）视频大小。您将在本手册后面的“手动向管道添加或删除数据”中看到过滤上限的示例。您可以通过将 capsfilter 元素插入管道并设置其“caps”属性来进行 caps 过滤。 Caps 过滤器通常放置在 audioconvert、audioresample、videoconvert 或 videoscale 等转换器元素之后，以强制这些转换器在流中的某个点将数据转换为特定的输出格式。</p>
</li>
</ul>
<h3 id="Using-capabilities-for-metadata"><a href="#Using-capabilities-for-metadata" class="headerlink" title="Using capabilities for metadata"></a>Using capabilities for metadata</h3><p>垫可以附加一组（即一个或多个）功能。功能 ( <code>GstCaps</code> ) 表示为一个或多个 <code>GstStructure</code> 的数组，每个 <code>GstStructure</code> 是一个字段数组，其中每个字段由一个字段名称组成字符串（例如“width”）和键入的值（例如 <code>G_TYPE_INT</code> 或 <code>GST_TYPE_INT_RANGE</code> ）。</p>
<p>请注意，pad 的可能功能（即，通常您发现的 pad 模板的上限，如 gst-inspect 中所示）、pad 允许的上限（可以与 pad 的上限相同）之间存在明显差异。模板上限或其子集，具体取决于对等 pad 的可能上限）和最后协商的上限（这些描述了流或缓冲区的确切格式，并且仅包含一个结构，并且没有像范围或列表之类的可变位，即。它们是固定 caps）。</p>
<p>您可以通过查询一个结构的各个属性来获取一组功能中的属性值。您可以使用 <code>gst_caps_get_structure ()</code> 从大写中获取结构，并使用 <code>gst_caps_get_size ()</code> 获取 <code>GstCaps</code> 中的结构数量。</p>
<p>当 Caps 仅包含一种结构时，称为 <em>simple caps</em> ；当 Caps 仅包含一种结构且没有可变字段类型（如可能值的范围或列表）时，称为 <em>fixed caps</em> 。另外两种特殊类型的 caps 是 ANY caps 和 empty caps。</p>
<p>以下是如何从一组固定视频上限中提取宽度和高度的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_video_props</span> <span class="params">(GstCaps *caps)</span></span><br><span class="line">&#123;</span><br><span class="line">    gint width, height;</span><br><span class="line">    <span class="type">const</span> GstStructure *str;</span><br><span class="line"></span><br><span class="line">    g_return_if_fail (gst_caps_is_fixed (caps));</span><br><span class="line"></span><br><span class="line">    str = gst_caps_get_structure (caps, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!gst_structure_get_int (str, <span class="string">&quot;width&quot;</span>, &amp;width) ||</span><br><span class="line">        !gst_structure_get_int (str, <span class="string">&quot;height&quot;</span>, &amp;height)) &#123;</span><br><span class="line">        g_print (<span class="string">&quot;No width/height available\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_print (<span class="string">&quot;The video size of this set of capabilities is %dx%d\n&quot;</span>,</span><br><span class="line">             width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Creating-capabilities-for-filtering"><a href="#Creating-capabilities-for-filtering" class="headerlink" title="Creating capabilities for filtering"></a>Creating capabilities for filtering</h3><p>虽然功能主要在插件内部用于描述 pad 的媒体类型，但应用程序程序员通常还必须对功能有基本的了解，以便与插件交互，尤其是在使用 filtered caps 时。当您使用 filtered caps 或 fixation 时，您将允许在两个 pad 之间传输的媒体类型限制为其支持的媒体类型的子集。您可以使用管道中的 <code>capsfilter</code> 元素来执行此操作。为此，您还需要创建自己的 <code>GstCaps</code> 。最简单的方法是使用函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> gboolean</span><br><span class="line">    <span class="title function_">link_elements_with_filter</span> <span class="params">(GstElement *element1, GstElement *element2)</span></span><br><span class="line">&#123;</span><br><span class="line">    gboolean link_ok;</span><br><span class="line">    GstCaps *caps;</span><br><span class="line"></span><br><span class="line">    caps = gst_caps_new_simple (<span class="string">&quot;video/x-raw&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;format&quot;</span>, G_TYPE_STRING, <span class="string">&quot;I420&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;width&quot;</span>, G_TYPE_INT, <span class="number">384</span>,</span><br><span class="line">                                <span class="string">&quot;height&quot;</span>, G_TYPE_INT, <span class="number">288</span>,</span><br><span class="line">                                <span class="string">&quot;framerate&quot;</span>, GST_TYPE_FRACTION, <span class="number">25</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    link_ok = gst_element_link_filtered (element1, element2, caps);</span><br><span class="line">    gst_caps_unref (caps);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!link_ok) &#123;</span><br><span class="line">        g_warning (<span class="string">&quot;Failed to link element1 and element2!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> link_ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将强制这两个元素之间的数据流达到特定的视频格式、宽度、高度和帧速率（或者，如果在所涉及的元素的上下文中无法实现链接将失败）。请记住，当您使用 <code>gst_element_link_filtered ()</code> 时，它会自动为您创建一个 <code>capsfilter</code> 元素，并将其插入到您要连接的两个元素之间的容器或管道中（如果您曾经想要断开这些元件的连接，因为这样您就必须将这两个元件与 capsfilter 断开连接）。</p>
<h2 id="Buffers-and-Events-缓冲区和事件"><a href="#Buffers-and-Events-缓冲区和事件" class="headerlink" title="Buffers and Events 缓冲区和事件"></a>Buffers and Events 缓冲区和事件</h2><p>流经管道的数据由缓冲区和事件的组合组成。缓冲区包含实际的媒体数据。事件包含控制信息，例如寻找信息和流结束通知程序。所有这些都会在管道运行时自动流过。本章主要是为了向您解释这个概念；您不需要为此做任何事情。</p>
<h3 id="Buffers-缓冲器"><a href="#Buffers-缓冲器" class="headerlink" title="Buffers 缓冲器"></a>Buffers 缓冲器</h3><p>缓冲区包含将流经您创建的管道的数据。源元素通常会创建一个新的缓冲区，并将其通过 pad 传递到链中的下一个元素。当使用 GStreamer 基础设施创建媒体管道时，您不必自己处理缓冲区；这些元素会为你做到这一点。</p>
<p>除其他外，缓冲区还包括：</p>
<ul>
<li><p>指向内存对象的指针。内存对象封装了内存中的一个区域。</p>
</li>
<li><p>缓冲区的时间戳。</p>
</li>
<li><p>指示有多少元素正在使用此缓冲区的引用计数。当没有元素引用缓冲区时，该引用计数将用于销毁缓冲区。</p>
</li>
<li><p>缓冲区标志。</p>
</li>
</ul>
<p>简单的情况是创建一个缓冲区，分配内存，将数据放入其中，然后传递到下一个元素。该元素读取数据，执行某些操作（例如创建新缓冲区并对其进行解码），然后取消引用该缓冲区。这会导致数据被释放并且缓冲区被破坏。典型的视频或音频解码器的工作原理如下。</p>
<p>不过，还有更复杂的场景。元素可以就地修改缓冲区，即无需分配新缓冲区。元素还可以写入硬件内存（例如来自视频捕获源）或从 X 服务器分配的内存（使用 XShm）。缓冲区可以是只读的，等等。</p>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>GStreamer 示例代码学习记录</title>
    <url>/2024/06/05/GStreamer%20%E6%95%99%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="GStreamer-示例代码学习记录"><a href="#GStreamer-示例代码学习记录" class="headerlink" title="GStreamer 示例代码学习记录"></a>GStreamer 示例代码学习记录</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是笔者阅读 GStreamer 官方文档中的基础教程和播放教程去学习 GStreamer 时的记录，大部分内容可以在 GStreamer 官方文档中找到。</p>
<p>笔者学习 GStreamer 的主要目的是：使用 GStreamer 处理从 TCP Socket 接收到的 H.265 裸流（使用 live555 的 testRTSPclient 程序从 RTSP URL 中获取到），将其解码并保存为 jpeg 图片。</p>
<p>部分教程与目的关系不大，为涉及到。笔者最终放弃使用 GStreamer 的想法，使用 FFmpeg 完成了上述目的。</p>
<h2 id="基础教程1："><a href="#基础教程1：" class="headerlink" title="基础教程1："></a>基础教程1：</h2><p>媒体流从 source 元素到 sink 元素，中间通过一系列中间元素比如 filter过滤器元素，所有这些的集合称为 pipeline。管道是一种特殊类型的 bin，也是用于包含其他元素的元素。因此，适用于 bin 的所有方法也适用于管道。pipeline 的状态为 GST_STATE_PLAYING 时播放流经的音&#x2F;视频。</p>
<p>playbin 是一个特殊的元素，它既作为源又作为接收器，是一个完整的流水线。在内部，它创建并连接所有必要的元素来播放媒体，见下例，URI 作为唯一参数传递给playbin。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gst_init</span> (&amp;argc, &amp;argv); <span class="comment">// 初始化，必须是第一个GStreamer命令</span></span><br><span class="line"><span class="comment">// gst_parse_launch 采用管道的文本表示，并将其转换为实际的管</span></span><br><span class="line">pipeline = <span class="built_in">gst_parse_launch</span> (</span><br><span class="line">    <span class="string">&quot;playbin uri=https://gstreamer.freedesktop.org/data/media/sintel_trailer-480p.webm&quot;</span>, </span><br><span class="line">    <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 元素相关</span></span><br><span class="line"><span class="comment">// 可以使用gst_element_factory_make（）创建新元素。第一个参数是要创建的元素的类型，第二个参数是我们要给这个特定实例的名称。</span></span><br><span class="line">source = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;videotestsrc&quot;</span>, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">sink = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;autovideosink&quot;</span>, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总线和消息</span></span><br><span class="line"><span class="comment">// 从总线上获得消息msg，本例的调用将阻塞，直到通过该总线接收到ERROR或 EOS （End-Of-Stream）(参数所设置，可设置其他参数)</span></span><br><span class="line">GstBus *bus = <span class="built_in">gst_element_get_bus</span> (pipeline); <span class="comment">// 得到管道的总线</span></span><br><span class="line">GstMessage *msg =</span><br><span class="line">      <span class="built_in">gst_bus_timed_pop_filtered</span> (bus, GST_CLOCK_TIME_NONE,</span><br><span class="line">      GST_MESSAGE_ERROR | GST_MESSAGE_EOS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置某个元素的状态，每个元素只有一个关联的状态，</span></span><br><span class="line"><span class="built_in">gst_element_set_state</span> (pipeline, GST_STATE_PLAYING);</span><br><span class="line"><span class="keyword">if</span> (ret == GST_STATE_CHANGE_FAILURE) &#123;</span><br><span class="line">    <span class="built_in">g_printerr</span> (<span class="string">&quot;Unable to set the pipeline to the playing state.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">gst_object_unref</span> (pipeline);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理</span></span><br><span class="line"><span class="built_in">gst_message_unref</span> (msg); <span class="comment">//  上面获得的总线返回的消息必须由此释放</span></span><br><span class="line"><span class="built_in">gst_object_unref</span> (bus); <span class="comment">// 上面获得的总线必须由此释放</span></span><br><span class="line"><span class="built_in">gst_element_set_state</span> (pipeline, GST_STATE_NULL); <span class="comment">// 将管道设置为NULL状态将确保它释放它已分配的任何资源</span></span><br><span class="line"><span class="built_in">gst_object_unref</span> (pipeline); <span class="comment">// 上面获得的管道取消引用管道将销毁管道及其所有内容。</span></span><br></pre></td></tr></table></figure>

<h2 id="基础教程2"><a href="#基础教程2" class="headerlink" title="基础教程2:"></a>基础教程2:</h2><p>videotestsrc 是一个源元素（产生数据），它创建一个测试视频模式。此元素对于调试目的（和教程）很有用，通常在真实的应用程序中找不到。</p>
<p>autovideosink 是一个接收器元素（消耗数据），它在窗口上显示它接收的图像。根据操作系统的不同，存在几个具有不同功能范围的视频接收器。autovideosink 会自动选择并实例化最好的一个，因此不必担心细节，并且代码更加独立于平台。</p>
<p>管道：</p>
<p>GStreamer 中的所有元素通常必须包含在管道中才能使用，因为它负责一些时钟和消息传递功能。我们使用gst_pipeline_new（）创建管道。</p>
<p>属性：</p>
<p>GStreamer元素都是一种特殊的GObject，它是提供属性设施的实体。大多数 GStreamer 元素都具有可自定义的属性：命名属性，可以修改这些属性以更改元素的行为（可写属性），或者查询这些属性以了解元素的内部状态（可读属性）。</p>
<p>使用g_object_get（）读取属性，使用g_object_set（）写入属性。g_object_set() 接受以 NULL 结尾的属性名称、属性值对列表，因此可以一次性更改多个属性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将元素添加到管道中（注意强制转换为bin类型）。此函数接受要添加的元素列表，以NULL结尾。可以使用gst_bin_add（）添加单个元素。</span></span><br><span class="line">GstElement *pipeline, *source, *sink;   <span class="comment">// 元素类型</span></span><br><span class="line">pipeline = <span class="built_in">gst_pipeline_new</span> (<span class="string">&quot;test-pipeline&quot;</span>); <span class="comment">// 创建管道</span></span><br><span class="line"><span class="built_in">gst_bin_add_many</span> (<span class="built_in">GST_BIN</span> (pipeline), source, sink, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// gst_element_link (source, sink)将管道中的元素连接起来，需要注意顺序，第一个参数是源，第二个参数是目的地。只有同一bin中的元素才能连接在一起。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">gst_element_link</span> (source, sink) != TRUE) &#123;</span><br><span class="line">    <span class="built_in">g_printerr</span> (<span class="string">&quot;Elements could not be linked.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">gst_object_unref</span> (pipeline);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更改了源的pattern属性，该属性控制元素输出的测试视频的类型。</span></span><br><span class="line"><span class="built_in">g_object_set</span> (source, <span class="string">&quot;pattern&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得总线，阻塞等待错误或者结尾消息，与教程1一样</span></span><br><span class="line">bus = <span class="built_in">gst_element_get_bus</span> (pipeline);</span><br><span class="line">msg =</span><br><span class="line">    <span class="built_in">gst_bus_timed_pop_filtered</span> (bus, GST_CLOCK_TIME_NONE,</span><br><span class="line">                                GST_MESSAGE_ERROR | GST_MESSAGE_EOS);</span><br><span class="line"><span class="comment">// 但这次简称msg可能的其他错误输出：</span></span><br><span class="line"><span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    GError *err;</span><br><span class="line">    gchar *debug_info;</span><br><span class="line"><span class="comment">// GST_MESSAGE_TYPE() 宏可以分析错误类型，gst_message_parse_error() 可以返回一个错误结构和一个对调试有用的字符串。</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">GST_MESSAGE_TYPE</span> (msg)) &#123;</span><br><span class="line">        <span class="keyword">case</span> GST_MESSAGE_ERROR:</span><br><span class="line">            <span class="built_in">gst_message_parse_error</span> (msg, &amp;err, &amp;debug_info);</span><br><span class="line">            <span class="built_in">g_printerr</span> (<span class="string">&quot;Error received from element %s: %s\n&quot;</span>,</span><br><span class="line">                        <span class="built_in">GST_OBJECT_NAME</span> (msg-&gt;src), err-&gt;message);</span><br><span class="line">            <span class="built_in">g_printerr</span> (<span class="string">&quot;Debugging information: %s\n&quot;</span>,</span><br><span class="line">                        debug_info ? debug_info : <span class="string">&quot;none&quot;</span>);</span><br><span class="line">            <span class="built_in">g_clear_error</span> (&amp;err);</span><br><span class="line">            <span class="built_in">g_free</span> (debug_info);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GST_MESSAGE_EOS:</span><br><span class="line">            <span class="built_in">g_print</span> (<span class="string">&quot;End-Of-Stream reached.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* We should not reach here because we only asked for ERRORs and EOS */</span></span><br><span class="line">            <span class="built_in">g_printerr</span> (<span class="string">&quot;Unexpected message received.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">gst_message_unref</span> (msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基础教程3动态管道"><a href="#基础教程3动态管道" class="headerlink" title="基础教程3动态管道"></a>基础教程3动态管道</h2><p>pad：GStreamer 元素相互通信的端口称为 pad ( <code>GstPad</code> )。存在 sink pad（数据通过其进入元素）和 source pad（数据通过其退出元素）。自然地，source 元素仅包含 source pad，sink 元素仅包含 sink pad，而 filter 元素包含两者。</p>
<p>多路分配器 demuxer 包含一个 sink pad（多路复用数据通过其到达）和多个 source pads（一个用于在容器中找到的每个流）：</p>
<p>demuxer 只有在收到视频流之后，收集到流的信息，才会创建自己的 source pad，因此，不能事先构建 demuxer 之后的连接。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存在结构体中便于处理</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CustomData</span> &#123;</span><br><span class="line">  GstElement *pipeline;</span><br><span class="line">  GstElement *source;</span><br><span class="line">  GstElement *convert;</span><br><span class="line">  GstElement *resample;</span><br><span class="line">  GstElement *sink;</span><br><span class="line">&#125; CustomData;</span><br><span class="line"><span class="comment">/* Create the elements */</span></span><br><span class="line">data.source = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;uridecodebin&quot;</span>, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">data.convert = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;audioconvert&quot;</span>, <span class="string">&quot;convert&quot;</span>);</span><br><span class="line">data.resample = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;audioresample&quot;</span>, <span class="string">&quot;resample&quot;</span>);</span><br><span class="line">data.sink = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;autoaudiosink&quot;</span>, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line"><span class="comment">// 链接元素转换器、重采样和接收器，但我们不将它们与源链接，因为此时它不包含源焊盘。我们只是让这个分支（转换器+接收器）不链接，直到稍后。</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gst_element_link_many</span> (data.convert, data.resample, data.sink, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">  <span class="built_in">g_printerr</span> (<span class="string">&quot;Elements could not be linked.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">gst_object_unref</span> (data.pipeline);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过属性设置要播放的文件的 URI</span></span><br><span class="line"><span class="built_in">g_object_set</span> (data.source, <span class="string">&quot;uri&quot;</span>, <span class="string">&quot;https://gstreamer.freedesktop.org/data/media/sintel_trailer-480p.webm&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p> <code>uridecodebin</code> 将在内部实例化所有必要的元素（源、解复用器和解码器），以将 URI 转换为原始音频和&#x2F;或视频流。它完成了 <code>playbin</code> 一半的工作。由于它包含解复用器，因此它的源焊盘最初不可用，我们需要动态链接到它们。</p>
<p><code>audioconvert</code> 对于在不同音频格式之间进行转换非常有用，确保此示例可以在任何平台上运行，因为音频解码器生成的格式可能与音频接收器期望的格式不同。</p>
<p><code>audioresample</code> 对于在不同音频采样率之间进行转换非常有用，同样确保此示例适用于任何平台，因为音频解码器产生的音频采样率可能不是音频接收器支持的采样率。</p>
<p><code>autoaudiosink</code> 相当于上一教程中的 <code>autovideosink</code> 。它将音频流渲染到声卡。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加给源（uridecodebin 元素）一个“pad-added”信号，第三个参数提供回调函数，第四个参数是数据指针（CustomData 结构的指针），对数据指针不执行任何操作，只是转发到回调函数便于共享信息。</span></span><br><span class="line"><span class="built_in">g_signal_connect</span> (data.source, <span class="string">&quot;pad-added&quot;</span>, <span class="built_in">G_CALLBACK</span> (pad_added_handler), &amp;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调：src 是触发信号的 GstElement，本例只能是uridecodebin，因为它是我们附加的唯一信号。信号处理程序的第一个参数始终是触发它的对象。</span></span><br><span class="line"><span class="comment">// new_pad 是刚刚添加到 src 元素的 GstPad 。这通常是我们想要链接的pad。</span></span><br><span class="line"><span class="comment">// data 是上面提到的数据指针。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">pad_added_handler</span> <span class="params">(GstElement *src, GstPad *new_pad, CustomData *data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// gst_element_get_static_pad () 检索uridercodebin 的 sink pad，之前我们直接连接元素（实际上连接的pad，由 GStreamer 自己完成了），现在我们自己连接 pad</span></span><br><span class="line">    <span class="comment">// uridecodebin 可以创建任意数量的 pad，对于每一个 pad，都会调用此回调。一旦我们已经链接，下面的代码行将阻止我们尝试链接到新的 pad。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">gst_pad_is_linked</span> (sink_pad)) &#123;</span><br><span class="line">        <span class="built_in">g_print</span> (<span class="string">&quot;We are already linked. Ignoring.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得pad 当前输出的数据类型，存在 GstCaps 结构中。</span></span><br><span class="line">    new_pad_caps = <span class="built_in">gst_pad_get_current_caps</span> (new_pad, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 本例中我们想要的 pad 只有一个音频，使用下面的函数获得第一个 GstStructure</span></span><br><span class="line">    new_pad_struct = <span class="built_in">gst_caps_get_structure</span> (new_pad_caps, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 得到结构的名称，其中包含格式的主要描述（实际上是其媒体类型）</span></span><br><span class="line">    <span class="comment">// 如果名称不是 audio/x-raw ，则这不是解码的音频，忽略。    </span></span><br><span class="line">    new_pad_type = <span class="built_in">gst_structure_get_name</span> (new_pad_struct);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">g_str_has_prefix</span> (new_pad_type, <span class="string">&quot;audio/x-raw&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">g_print</span> (<span class="string">&quot;It has type &#x27;%s&#x27; which is not raw audio. Ignoring.\n&quot;</span>, new_pad_type);</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// gst_pad_link() 尝试链接两个 pad。必须指定从 source 到 sink 的链接，并且两个 pad 必须由驻留在同一容器（或管道）中的元素拥有。</span></span><br><span class="line">    ret = <span class="built_in">gst_pad_link</span> (new_pad, sink_pad);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GST_PAD_LINK_FAILED</span> (ret)) &#123;</span><br><span class="line">        <span class="built_in">g_print</span> (<span class="string">&quot;Type is &#x27;%s&#x27; but link failed.\n&quot;</span>, new_pad_type);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">g_print</span> (<span class="string">&quot;Link succeeded (type &#x27;%s&#x27;).\n&quot;</span>, new_pad_type);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="基础教程4"><a href="#基础教程4" class="headerlink" title="基础教程4"></a>基础教程4</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">msg = <span class="built_in">gst_bus_timed_pop_filtered</span> (bus, <span class="number">100</span> * GST_MSECOND,</span><br><span class="line">    GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_ERROR | GST_MESSAGE_EOS | GST_MESSAGE_DURATION);</span><br></pre></td></tr></table></figure>

<p>从总线上获取消息的函数，这次加上超时，如果100毫秒没消息，返回 NULL，依次来更新终端显示。</p>
<p>事件用数字乘以 GST_MSECOND 等宏表示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">gst_element_query_position</span> (data.pipeline, GST_FORMAT_TIME, &amp;current)) &#123;</span><br><span class="line">  <span class="built_in">g_printerr</span> (<span class="string">&quot;Could not query current position.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">GST_CLOCK_TIME_IS_VALID</span> (data.duration)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">gst_element_query_duration</span> (data.pipeline, GST_FORMAT_TIME, &amp;data.duration)) &#123;</span><br><span class="line">     <span class="built_in">g_printerr</span> (<span class="string">&quot;Could not query current duration.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gst_element_query_position()</code> 隐藏了查询对象的管理，直接为我们提供结果。直接获得当前流的播放的位置。</p>
<p> <code>gst_element_query_duration()</code>函数获得流的总长度。</p>
<p> <code>GST_TIME_FORMAT</code> 和 <code>GST_TIME_ARGS</code> 宏的使用提供用户友好的 GStreamer 时间表示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (data.seek_enabled &amp;&amp; !data.seek_done &amp;&amp; current &gt; <span class="number">10</span> * GST_SECOND) &#123;</span><br><span class="line">  <span class="built_in">g_print</span> (<span class="string">&quot;\nReached 10s, performing seek...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">gst_element_seek_simple</span> (data.pipeline, GST_FORMAT_TIME,</span><br><span class="line">      GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, <span class="number">30</span> * GST_SECOND);</span><br><span class="line">  data.seek_done = TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>gst_element_seek_simple()</code> 来“简单地”执行查找。第二个参数表示以时间为单位指定目的地。</p>
<p>第三个参数是<code>GstSeekFlags</code>，本例中的两个选项：</p>
<p><code>GST_SEEK_FLAG_FLUSH</code> ：这会在执行查找之前丢弃当前管道中的所有数据。当管道重新填充并且新数据开始显示时可能会暂停一点，但会大大提高应用程序的“响应能力”。如果未提供此标志，则“陈旧”数据可能会显示一段时间，直到新位置出现在管道末尾。</p>
<p><code>GST_SEEK_FLAG_KEY_UNIT</code> ：对于大多数编码视频流，不可能寻找任意位置，而只能寻找称为关键帧的某些帧。使用此标志时，搜索实际上会移动到最近的关键帧并立即开始生成数据。如果不使用此标志，管道将在内部移动到最近的关键帧（它没有其他选择），但数据在到达请求的位置之前不会显示。最后一种选择更准确，但可能需要更长的时间。</p>
<p>第四个参数提供搜索位置，本例是30秒，即跳转到30秒处继续播放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> GST_MESSAGE_DURATION:</span><br><span class="line"><span class="comment">/* The duration has changed, mark the current one as invalid */</span></span><br><span class="line">data-&gt;duration = GST_CLOCK_TIME_NONE;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>消息类型为<code>GST_MESSAGE_DURATION</code>时，每当流的总长度发生变化时，该消息就会发布到总线上。这里我们只是将总长度（时间）标记为无效，以便稍后重新查询。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> GST_MESSAGE_STATE_CHANGED: &#123;</span><br><span class="line">    GstState old_state, new_state, pending_state;</span><br><span class="line">    <span class="built_in">gst_message_parse_state_changed</span> (msg, &amp;old_state, &amp;new_state, &amp;pending_state);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GST_MESSAGE_SRC</span> (msg) == <span class="built_in">GST_OBJECT</span> (data-&gt;pipeline)) &#123;</span><br><span class="line">        <span class="built_in">g_print</span> (<span class="string">&quot;Pipeline state changed from %s to %s:\n&quot;</span>,</span><br><span class="line">                 <span class="built_in">gst_element_state_get_name</span> (old_state), <span class="built_in">gst_element_state_get_name</span> (new_state));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remember whether we are in the PLAYING state or not */</span></span><br><span class="line">        data-&gt;playing = (new_state == GST_STATE_PLAYING);</span><br></pre></td></tr></table></figure>

<p>消息类型为<code>GST_MESSAGE_STATE_CHANGED</code>时打印流的前后状态，搜索和时间查询通常仅在处于 <code>PAUSED</code> 或 <code>PLAYING</code> 状态时才能获得有效答复，因为所有元素都有机会接收信息并配置自身。在这里，我们使用 <code>playing</code> 变量来跟踪管道是否处于 <code>PLAYING</code> 状态。另外，如果我们刚刚进入 <code>PLAYING</code> 状态，我们将执行第一个查询。我们询问管道是否允许在此流上查找：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (data-&gt;playing) &#123;</span><br><span class="line">    <span class="comment">/* We just moved to PLAYING. Check if seeking is possible */</span></span><br><span class="line">    GstQuery *query;</span><br><span class="line">    gint64 start, end;</span><br><span class="line">    query = <span class="built_in">gst_query_new_seeking</span> (GST_FORMAT_TIME);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">gst_element_query</span> (data-&gt;pipeline, query)) &#123;</span><br><span class="line">        <span class="built_in">gst_query_parse_seeking</span> (query, <span class="literal">NULL</span>, &amp;data-&gt;seek_enabled, &amp;start, &amp;end);</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;seek_enabled) &#123;</span><br><span class="line">            <span class="built_in">g_print</span> (<span class="string">&quot;Seeking is ENABLED from %&quot;</span> GST_TIME_FORMAT <span class="string">&quot; to %&quot;</span> GST_TIME_FORMAT <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                     <span class="built_in">GST_TIME_ARGS</span> (start), <span class="built_in">GST_TIME_ARGS</span> (end));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">g_print</span> (<span class="string">&quot;Seeking is DISABLED for this stream.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">g_printerr</span> (<span class="string">&quot;Seeking query failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">gst_query_unref</span> (query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gst_query_new_seeking()</code> 创建一个“寻求”类型的新查询对象，格式为 <code>GST_FORMAT_TIME</code> 。这表明我们有兴趣通过指定我们想要移动到的新时间来进行搜索。我们还可以请求 <code>GST_FORMAT_BYTES</code> ，然后查找源文件内的特定字节位置，但这通常不太有用。<br>然后，该查询对象通过 <code>gst_element_query()</code> 传递到管道。结果存储在同一查询中，并且可以使用 <code>gst_query_parse_seeking()</code> 轻松检索。它提取一个布尔值，指示是否允许查找以及可以查找的范围。</p>
<h2 id="基础教程6"><a href="#基础教程6" class="headerlink" title="基础教程6"></a>基础教程6</h2><p>Pad 允许信息进入和离开元素，Pad 可以指定 Pad 传输的信息类型，比如“分辨率为 320x200 像素、每秒 30 帧的 RGB 视频”，可以支持多种功能。从 Pad 到 Pad 传输的实际信息必须只有一种明确指定的类型。通过”协商“，两个链接的 Pad 就通用类型达成一致，因此 Pad 的功能变得固定（它们只有一种类型且不包含范围）。</p>
<p>为了将两个元素连接在一起，他们必须有一个公共的功能子集。</p>
<p>Pad 是根据 Pad 模板创建的，该模板指示 Pad 可能具有的所有可能功能。模板可用于创建多个相似的 Pad，并且还允许提前拒绝元素之间的连接：如果其 Pad 模板的功能没有公共子集（它们的交集为空），则无需进一步协商。Pad 模板可以被视为谈判过程的第一步。随着流程的发展，实际的 Pad 会被实例化，其功能也会得到完善，直到它们被修复（或协商失败）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Shows the CURRENT capabilities of the requested pad in the given element */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print_pad_capabilities</span> <span class="params">(GstElement *element, gchar *pad_name)</span> </span>&#123;</span><br><span class="line">    GstPad *pad = <span class="literal">NULL</span>;</span><br><span class="line">    GstCaps *caps = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Retrieve pad */</span></span><br><span class="line">   <span class="comment">// 从给定元素中获得指定的 Pad。此 Pad 是静态的，因为它始终存在于元素中。</span></span><br><span class="line">    pad = <span class="built_in">gst_element_get_static_pad</span> (element, pad_name);</span><br><span class="line">    <span class="keyword">if</span> (!pad) &#123;</span><br><span class="line">        <span class="built_in">g_printerr</span> (<span class="string">&quot;Could not retrieve pad &#x27;%s&#x27;\n&quot;</span>, pad_name);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Retrieve negotiated caps (or acceptable caps if negotiation is not finished yet) */</span></span><br><span class="line">    <span class="comment">// 获得 Pad 的当前 Capability，可能有可能无，可能固定可能不固定</span></span><br><span class="line">    caps = <span class="built_in">gst_pad_get_current_caps</span> (pad);</span><br><span class="line">    <span class="keyword">if</span> (!caps)</span><br><span class="line">        <span class="comment">//  获得当前可接受的 Pad 功能</span></span><br><span class="line">        caps = <span class="built_in">gst_pad_query_caps</span> (pad, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Print and free */</span></span><br><span class="line">    <span class="comment">// 打印并释放</span></span><br><span class="line">    <span class="built_in">g_print</span> (<span class="string">&quot;Caps for the %s pad:\n&quot;</span>, pad_name);</span><br><span class="line">    <span class="built_in">print_caps</span> (caps, <span class="string">&quot;      &quot;</span>);</span><br><span class="line">    <span class="built_in">gst_caps_unref</span> (caps);</span><br><span class="line">    <span class="built_in">gst_object_unref</span> (pad);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建元素工厂 */</span></span><br><span class="line">source_factory = <span class="built_in">gst_element_factory_find</span> (<span class="string">&quot;audiotestsrc&quot;</span>);</span><br><span class="line">sink_factory = <span class="built_in">gst_element_factory_find</span> (<span class="string">&quot;autoaudiosink&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!source_factory || !sink_factory) &#123;</span><br><span class="line">  <span class="built_in">g_printerr</span> (<span class="string">&quot;Not all element factories could be created.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印工厂的 Pad 信息 */</span></span><br><span class="line"><span class="built_in">print_pad_templates_information</span> (source_factory);</span><br><span class="line"><span class="built_in">print_pad_templates_information</span> (sink_factory);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 让工厂实例化实际的元素 */</span></span><br><span class="line">source = <span class="built_in">gst_element_factory_create</span> (source_factory, <span class="string">&quot;source&quot;</span>);</span><br><span class="line">sink = <span class="built_in">gst_element_factory_create</span> (sink_factory, <span class="string">&quot;sink&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在之前的教程中，我们直接使用 <code>gst_element_factory_make()</code> 创建元素且没有谈论工厂，但现在我们用 <code>GstElementFactory</code> 负责实例化特定类型的元素，由其工厂名称标识。</p>
<p><code>gst_element_factory_find()</code> 创建类型为“videotestsrc”的工厂，然后使用它通过 <code>gst_element_factory_create()</code> 实例化多个“videotestsrc”元素。 <code>gst_element_factory_make()</code> 实际上是 <code>gst_element_factory_find()</code> + <code>gst_element_factory_create()</code> 的快捷方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> GST_MESSAGE_STATE_CHANGED:</span><br><span class="line"><span class="comment">/* We are only interested in state-changed messages from the pipeline */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GST_MESSAGE_SRC</span> (msg) == <span class="built_in">GST_OBJECT</span> (pipeline)) &#123;</span><br><span class="line">    GstState old_state, new_state, pending_state;</span><br><span class="line">    <span class="built_in">gst_message_parse_state_changed</span> (msg, &amp;old_state, &amp;new_state, &amp;pending_state);</span><br><span class="line">    <span class="built_in">g_print</span> (<span class="string">&quot;\nPipeline state changed from %s to %s:\n&quot;</span>,</span><br><span class="line">             <span class="built_in">gst_element_state_get_name</span> (old_state), <span class="built_in">gst_element_state_get_name</span> (new_state));</span><br><span class="line">    <span class="comment">/* Print the current capabilities of the sink element */</span></span><br><span class="line">    <span class="built_in">print_pad_capabilities</span> (sink, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>每次管道状态发生变化时，这都会简单地打印当前的 Pad Caps。您应该在输出中看到初始 Caps（Pad 模板的 Caps）如何逐渐细化，直到完全固定（它们包含没有范围的单一类型）。</p>
<h2 id="基础教程7-多线程和Pad可用性"><a href="#基础教程7-多线程和Pad可用性" class="headerlink" title="基础教程7:多线程和Pad可用性"></a>基础教程7:多线程和Pad可用性</h2><p>GStreamer 是一个多线程框架。这意味着，它在内部根据需要创建和销毁线程，例如，将流与应用程序线程解耦。此外，插件还可以自由创建线程用于自己的处理，例如，视频解码器可以创建 4 个线程以充分利用 4 核 CPU。</p>
<p>除此之外，在构建管道时，应用程序可以明确指定分支（管道的一部分）在不同的线程上运行（例如，让音频和视频解码器同时执行）。</p>
<p>这是使用 <code>queue</code> 元素完成的，其工作原理为：接收器 Pad 只是将数据排队并返回控制。在不同的线程上，数据出队并推送到下游。该元素还用于缓冲，如后面的流教程中所示。队列的大小可以通过属性来控制。</p>
<p>此示例构建以下管道：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407120920861.png" alt="image-20240712092033912"></p>
<p>source 是一个合成音频信号（连续音调），它使用 <code>tee</code> 元素进行分割（它把 sink pad 接收的所有内容用 source pad 发送出去）。然后，一个分支将信号发送到声卡，另一个分支渲染波形视频并将其发送到屏幕。</p>
<p>如图所示，队列创建一个新线程，因此该管道在 3 个线程中运行。具有多个接收器的管道通常需要多线程，因为为了同步，接收器通常会阻塞执行，直到所有其他接收器准备好为止，并且如果只有一个线程，则它们无法准备好，会被第一个接收器阻塞。</p>
<p>在基础教程 3：动态管道中，我们看到一个元素 ( <code>uridecodebin</code> ) 一开始就没有 pad，它们随着数据开始流动并且媒体流经元素而出现。这些称为 <strong>Sometimes Pads</strong>，与始终可用且称为 <strong>Always Pads</strong>的常规 pad 形成对比。</p>
<p>第三种 pad 是 Request Pad，它是按需创建的。典型的示例是 <code>tee</code> 元素，它有一个 sink pad 并且没有初始 source pad：需要请求它们，然后 <code>tee</code> 添加它们。通过这种方式，输入流可以被复制任意多次。缺点是使用 Request Pads 链接元素并不像链接 Always Pads 那样自动，如本示例的演练所示。</p>
<p>此外，要在 <code>PLAYING</code> 或 <code>PAUSED</code> 状态下请求（或释放）Pad，需要采取额外的注意事项（Pad 阻塞），本教程中未对此进行描述。不过，在 <code>NULL</code> 或 <code>READY</code> 状态下请求（或释放）pad 是安全的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建元素 */</span></span><br><span class="line"><span class="comment">// 都是直接使用gst_element_factory_make()，参数是类型和名称</span></span><br><span class="line">audio_source = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;audiotestsrc&quot;</span>, <span class="string">&quot;audio_source&quot;</span>);</span><br><span class="line">tee = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;tee&quot;</span>, <span class="string">&quot;tee&quot;</span>);</span><br><span class="line">audio_queue = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;queue&quot;</span>, <span class="string">&quot;audio_queue&quot;</span>);</span><br><span class="line">audio_convert = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;audioconvert&quot;</span>, <span class="string">&quot;audio_convert&quot;</span>);</span><br><span class="line">audio_resample = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;audioresample&quot;</span>, <span class="string">&quot;audio_resample&quot;</span>);</span><br><span class="line">audio_sink = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;autoaudiosink&quot;</span>, <span class="string">&quot;audio_sink&quot;</span>);</span><br><span class="line">video_queue = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;queue&quot;</span>, <span class="string">&quot;video_queue&quot;</span>);</span><br><span class="line">visual = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;wavescope&quot;</span>, <span class="string">&quot;visual&quot;</span>);</span><br><span class="line">video_convert = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;videoconvert&quot;</span>, <span class="string">&quot;video_convert&quot;</span>);</span><br><span class="line">video_sink = <span class="built_in">gst_element_factory_make</span> (<span class="string">&quot;autovideosink&quot;</span>, <span class="string">&quot;video_sink&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>audiotestsrc</code> 产生合成音。 <code>wavescope</code> 消耗音频信号并呈现波形，就像它是一个示波器一样。我们已经使用过 <code>autoaudiosink</code> 和 <code>autovideosink</code> 。</p>
<p>转换元素（ <code>audioconvert</code> 、 <code>audioresample</code> 和 <code>videoconvert</code> ）对于保证管道可以链接是必需的。事实上，音频和视频接收器的功能取决于硬件，并且您在设计时不知道它们是否与 <code>audiotestsrc</code> 和 <code>wavescope</code> 生成的 Caps 匹配。不过，如果 Caps 匹配，这些元素将以“直通”模式运行，不会修改信号，对性能的影响可以忽略不计。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 配置元素 */</span></span><br><span class="line"><span class="built_in">g_object_set</span> (audio_source, <span class="string">&quot;freq&quot;</span>, <span class="number">215.0f</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">g_object_set</span> (visual, <span class="string">&quot;shader&quot;</span>, <span class="number">0</span>, <span class="string">&quot;style&quot;</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p><code>audiotestsrc</code> 的“freq”属性控制波的频率（215Hz 使波在窗口中看起来几乎静止）， <code>wavescope</code> 使波连续。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Link all elements that can be automatically linked because they have &quot;Always&quot; pads */</span></span><br><span class="line"><span class="comment">// 放在一个管道中</span></span><br><span class="line"><span class="built_in">gst_bin_add_many</span> (<span class="built_in">GST_BIN</span> (pipeline), audio_source, tee, audio_queue, audio_convert, audio_sink,</span><br><span class="line">                  video_queue, visual, video_convert, video_sink, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 连接所有可以自动连接的元素，如上图所示的三部分</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">gst_element_link_many</span> (audio_source, tee, <span class="literal">NULL</span>) != TRUE ||</span><br><span class="line">    <span class="built_in">gst_element_link_many</span> (audio_queue, audio_convert, audio_sink, <span class="literal">NULL</span>) != TRUE ||</span><br><span class="line">    <span class="built_in">gst_element_link_many</span> (video_queue, visual, video_convert, video_sink, <span class="literal">NULL</span>) != TRUE) &#123;</span><br><span class="line">    <span class="built_in">g_printerr</span> (<span class="string">&quot;Elements could not be linked.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">gst_object_unref</span> (pipeline);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码块将所有元素添加到管道中，然后链接可以自动链接的元素（带有 Always Pads 的元素）。</p>
<p><code>gst_element_link_many()</code> 实际上可以将元素与 Request Pads 链接起来。它在内部请求 Pad，因此不必担心链接的元素具有 Always 或者 Request Pads。这实际上很不方便，因为之后您仍然需要释放所请求的 Pad，而且，如果 Pad 是由<code>gst_element_link_many()</code> 自动请求的，会很容易忘记。始终手动请求 Request Pads ，以避免出现麻烦，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 手动连接具有 &quot;Request&quot; pads 的 tee 元素*/</span></span><br><span class="line"><span class="comment">// 用下面的函数请求 tee 的 source pad（Request pad），负责 audio</span></span><br><span class="line">tee_audio_pad = <span class="built_in">gst_element_request_pad_simple</span> (tee, <span class="string">&quot;src_%u&quot;</span>);</span><br><span class="line"><span class="built_in">g_print</span> (<span class="string">&quot;Obtained request pad %s for audio branch.\n&quot;</span>, <span class="built_in">gst_pad_get_name</span> (tee_audio_pad));</span><br><span class="line"><span class="comment">// 用下面的函数请求 tee 的 sink pad（Always Pad），负责 audio</span></span><br><span class="line">queue_audio_pad = <span class="built_in">gst_element_get_static_pad</span> (audio_queue, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line"><span class="comment">// 用下面的函数请求 tee 的 source pad（Request pad），负责 video</span></span><br><span class="line">tee_video_pad = <span class="built_in">gst_element_request_pad_simple</span> (tee, <span class="string">&quot;src_%u&quot;</span>);</span><br><span class="line"><span class="built_in">g_print</span> (<span class="string">&quot;Obtained request pad %s for video branch.\n&quot;</span>, <span class="built_in">gst_pad_get_name</span> (tee_video_pad));</span><br><span class="line"><span class="comment">// 用下面的函数请求 tee 的 sink pad（Always Pad），负责 video</span></span><br><span class="line">queue_video_pad = <span class="built_in">gst_element_get_static_pad</span> (video_queue, <span class="string">&quot;sink&quot;</span>)</span><br><span class="line"><span class="comment">// 连接</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">gst_pad_link</span> (tee_audio_pad, queue_audio_pad) != GST_PAD_LINK_OK ||</span><br><span class="line">    <span class="built_in">gst_pad_link</span> (tee_video_pad, queue_video_pad) != GST_PAD_LINK_OK) &#123;</span><br><span class="line">    <span class="built_in">g_printerr</span> (<span class="string">&quot;Tee could not be linked.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">gst_object_unref</span> (pipeline);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">gst_object_unref</span> (queue_audio_pad);</span><br><span class="line"><span class="built_in">gst_object_unref</span> (queue_video_pad);</span><br></pre></td></tr></table></figure>

<p>要链接 request pad，需要通过向元素“请求”它们来获取它们。一个元素可能能够生成不同类型的请求 pad，因此，在请求它们时，必须提供所需的 pad 模板名称。tee 有两个 pad 模板，分别为“sink”（用于其接收器 pad）和“src_%u”（用于Request pad）。我们使用<code>gst_element_request_pad_simple()</code>从 tee（用于音频和视频分支）请求两个 pad  。</p>
<p>然后，我们从这些请求 Pad 需要链接到的下游元素获取 Pad。这些是普通的 Always Pad，因此我们使用 <code>gst_element_get_static_pad()</code> 获取它们。</p>
<p>最后，我们将 pad 与 <code>gst_pad_link()</code> 链接起来。这是 <code>gst_element_link()</code> 和 <code>gst_element_link_many()</code> 内部使用的函数。</p>
<p>我们获得的sink Pad需要通过 <code>gst_object_unref()</code> 来释放。当我们不再需要它们时，在程序结束时，请求垫将被释放。</p>
<p>然后，我们将管道设置为正常播放，并等待生成错误消息或 EOS。剩下要做的唯一一件事就是清理请求的 Pad：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gst_element_release_request_pad</span> (tee, tee_audio_pad);</span><br><span class="line"><span class="built_in">gst_element_release_request_pad</span> (tee, tee_video_pad);</span><br><span class="line"><span class="built_in">gst_object_unref</span> (tee_audio_pad);</span><br><span class="line"><span class="built_in">gst_object_unref</span> (tee_video_pad);</span><br></pre></td></tr></table></figure>

<p><code>gst_element_release_request_pad()</code> 从 <code>tee</code> 释放 pad，但仍需要使用 <code>gst_object_unref()</code> 取消引用（释放）它。</p>
<h2 id="基础教程8：简化管道"><a href="#基础教程8：简化管道" class="headerlink" title="基础教程8：简化管道"></a>基础教程8：简化管道</h2><p>用于将应用程序数据注入 GStreamer 管道的元素是 <code>appsrc</code> ，其对应元素用于将 GStreamer 数据提取回应用程序是 <code>appsink</code> 。 <code>appsrc</code> 只是一个常规源，由应用程序提供数据（在GStreamer中视为<code>appsrc</code> 提供。 <code>appsink</code> 是一个常规接收器，流经 GStreamer 管道的数据将被消费（实际上由应用程序获得并使用）。</p>
<p><code>appsrc</code> 可以在多种模式下工作：在拉模式下，它每次需要时都会向应用程序请求数据。在推送模式下，应用程序按照自己的节奏推送数据。此外，在推送模式下，当已经提供了足够的数据时，应用程序可以选择在推送功能中阻塞，或者可以监听 <code>enough-data</code> 和 <code>need-data</code> 信号来控制流量。</p>
<p>数据以称为缓冲区（buffers）的块的形式通过 GStreamer 管道。类型是<code>GstBuffer</code>，Source Pad 产生缓冲区，由 Sink Pad 消耗； GStreamer 获取这些缓冲区并将它们从一个元素传递到另一个元素。</p>
<p>缓冲区仅表示一个数据单元，不要假设所有缓冲区都具有相同的大小，或表示相同的时间量。如果单个缓冲区进入一个元素，那么单个缓冲区也不一定会出来。元素可以随意处理接收到的缓冲区。 <code>GstBuffer</code> 也可能包含多个实际内存缓冲区。实际的内存缓冲区是使用 <code>GstMemory</code> 对象抽象出来的，一个 <code>GstBuffer</code> 可以包含多个 <code>GstMemory</code> 对象。</p>
<p>每个缓冲区都附加了时间戳和持续时间，描述了缓冲区内容应在哪个时刻被解码、渲染或显示。例如， <code>filesrc</code> （读取文件的 GStreamer 元素）生成具有“ANY”上限且没有时间戳信息的缓冲区。解复用后（请参阅基础教程 3：动态管道），缓冲区可以具有一些特定的上限，例如“video&#x2F;x-h264”。解码后，每个缓冲区将包含一个带有原始上限的视频帧（例如“video&#x2F;x-raw-yuv”）和非常精确的时间戳（指示何时应显示该帧）。</p>
<p>本教程以两种方式扩展了基础教程 7：多线程和 Pad 可用性：首先，将 <code>audiotestsrc</code> 替换为将生成音频数据的 <code>appsrc</code> 。其次，一个新分支被添加到 <code>tee</code> 中，因此进入音频接收器和波形显示的数据也被复制到 <code>appsink</code> 中。 <code>appsink</code> 将信息上传回应用程序，然后应用程序仅通知用户已收到数据，但它显然可以执行更复杂的任务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407121011878.png" alt="image-20240712101109001"></p>
<p>创建管道的代码是基础教程 7：多线程和 Pad 可用性的放大版本。它涉及实例化所有元素，将元素与Always Pads 链接，并手动链接 <code>tee</code> 元素的Request Pads。</p>
<p>关于 <code>appsrc</code> 和 <code>appsink</code> 元素的配置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Configure appsrc */</span></span><br><span class="line"><span class="comment">// 构建一个 GstAudioInfo info，生成 audio_caps并设置到data.app_source</span></span><br><span class="line">gst_audio_info_set_format (&amp;info, GST_AUDIO_FORMAT_S16, SAMPLE_RATE, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">audio_caps = gst_audio_info_to_caps (&amp;info);</span><br><span class="line">g_object_set (data.app_source, <span class="string">&quot;caps&quot;</span>, audio_caps, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 连接信号，当源队列需要数据和数据足够时触发回调函数来启动/停止信号生成</span></span><br><span class="line">g_signal_connect (data.app_source, <span class="string">&quot;need-data&quot;</span>, G_CALLBACK (start_feed), &amp;data);</span><br><span class="line">g_signal_connect (data.app_source, <span class="string">&quot;enough-data&quot;</span>, G_CALLBACK (stop_feed), &amp;data);</span><br></pre></td></tr></table></figure>

<p>需要在 <code>appsrc</code> 上设置的第一个属性是 <code>caps</code> 。它指定元素将生成的数据类型，因此 GStreamer 可以检查是否可以与下游元素链接（即，下游元素是否能够理解此类数据）。此属性必须是 <code>GstCaps</code> 对象，可以使用 <code>gst_caps_from_string()</code> 轻松地从字符串构建该对象。</p>
<p>然后我们连接到 <code>need-data</code> 和 <code>enough-data</code> 信号。当 <code>appsrc</code> 的内部数据队列不足或几乎满时，它们会分别被触发。我们将使用这些信号来（分别）启动和停止我们的信号生成过程。</p>
<p>启动管道、等待消息和最终清理都像往常一样完成。让我们回顾一下我们刚刚注册的回调：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当 appsrc 需要数据时，触发下面的回调函数。主循环添加一个空闲处理程序以开始将数据推送到 appsrc</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">start_feed</span> <span class="params">(GstElement *source, guint size, CustomData *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data-&gt;sourceid == <span class="number">0</span>) &#123;</span><br><span class="line">        g_print (<span class="string">&quot;Start feeding\n&quot;</span>);</span><br><span class="line">        data-&gt;sourceid = g_idle_add ((GSourceFunc) push_data, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>appsrc</code> 的内部队列即将耗尽（数据耗尽）时调用此函数。我们在这里做的唯一一件事就是向 <code>g_idle_add()</code> 注册一个 GLib 空闲函数，该函数将数据提供给 <code>appsrc</code> 直到它再次填满。 GLib 空闲函数是 GLib 在“空闲”时（即没有更高优先级的任务要执行时）从其主循环调用的方法。显然，它需要一个 GLib <code>GMainLoop</code> 来实例化并运行。</p>
<p>这只是 <code>appsrc</code> 允许的多种方法之一。特别是，缓冲区不需要使用 GLib 从主线程输入 <code>appsrc</code> ，并且不需要使用 <code>need-data</code> 和 <code>enough-data</code> 信号来与 <code>appsrc</code> 同步（尽管据称这是最方便的）。</p>
<p>我们记下 <code>g_idle_add()</code> 返回的 sourceid，以便稍后禁用它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当 appsrc 有足够的数据时，此回调会触发，我们可以停止发送。</span></span><br><span class="line"><span class="comment">//我们从主循环中删除空闲处理程序</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stop_feed</span> <span class="params">(GstElement *source, CustomData *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data-&gt;sourceid != <span class="number">0</span>) &#123;</span><br><span class="line">        g_print (<span class="string">&quot;Stop feeding\n&quot;</span>);</span><br><span class="line">        g_source_remove (data-&gt;sourceid);</span><br><span class="line">        data-&gt;sourceid = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>appsrc</code> 的内部队列足够满时调用此函数，因此我们停止推送数据。这里我们简单地使用 <code>g_source_remove()</code> 删除空闲函数（空闲函数被实现为 <code>GSource</code> ）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 此方法由主循环中的空闲 GSource 调用，将 CHUNK_SIZE 字节输入到 appsrc 中。</span></span><br><span class="line"><span class="comment">* 当 appsrc 请求我们开始发送数据（需要数据信号）时，ide 处理程序会添加到主循环中</span></span><br><span class="line"><span class="comment">* 并在 appsrc 有足够的数据（足够数据信号）时被删除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> gboolean <span class="title function_">push_data</span> <span class="params">(CustomData *data)</span> &#123;</span><br><span class="line">    GstBuffer *buffer;</span><br><span class="line">    GstFlowReturn ret;</span><br><span class="line">    GstMapInfo <span class="built_in">map</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    gint num_samples = CHUNK_SIZE / <span class="number">2</span>; <span class="comment">/* Because each sample is 16 bits */</span></span><br><span class="line">    gfloat freq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个新的空缓冲区，本例被设置为固定1024字节 */</span></span><br><span class="line">    buffer = gst_buffer_new_and_alloc (CHUNK_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set its timestamp and duration */</span></span><br><span class="line">    <span class="comment">// CustomData.num_samples 变量计算到目前为止生成的样本数量（即当前时间是多少）</span></span><br><span class="line">    <span class="comment">// 因此可以使用 GstBuffer 中的 GST_BUFFER_TIMESTAMP 宏对该缓冲区添加时间戳。</span></span><br><span class="line">    GST_BUFFER_TIMESTAMP (buffer) = gst_util_uint64_scale (data-&gt;num_samples, GST_SECOND, SAMPLE_RATE);</span><br><span class="line">    <span class="comment">// 由于我们生成相同大小的缓冲区，因此它们的持续时间相同</span></span><br><span class="line">    <span class="comment">// num_samples是缓冲区的样本数量，即16bits</span></span><br><span class="line">    <span class="comment">// 使用 GstBuffer 中的 GST_BUFFER_DURATION 设置缓冲区的持续总时间。</span></span><br><span class="line">    GST_BUFFER_DURATION (buffer) = gst_util_uint64_scale (num_samples, GST_SECOND, SAMPLE_RATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 产生一些迷幻波形，跳过 */</span></span><br><span class="line">    <span class="keyword">if</span> (gst_buffer_map (buf, &amp;<span class="built_in">map</span>, GST_MAP_READ)) &#123;</span><br><span class="line">        gint16 *raw = (gint16 *) <span class="built_in">map</span>.data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在此处创建样本 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 完成后取消映射缓冲区 */</span> </span><br><span class="line">        gst_buffer_unmap (buf, &amp;<span class="built_in">map</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这是提供 <code>appsrc</code> 的函数。 GLib 会以我们无法控制的时间和速率调用它，但我们知道，当它的工作完成时（当 <code>appsrc</code> 中的队列已满时），我们将禁用它。</p>
<p><code>gst_util_uint64_scale()</code> 是一个实用函数，可以缩放（乘法和除法）可能很大的数字，而不必担心溢出。</p>
<p>为了访问缓冲区的内存，您首先必须将其映射到 <code>gst_buffer_map()</code> ，这将为您提供 <code>GstMapInfo</code> 结构内的指针和大小，其中 <code>gst_buffer_map()</code> 将在成功时填充。请小心，不要写入超过缓冲区末尾的内容：您分配了它，因此您知道它的大小（以字节和样本为单位）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Push the buffer into the appsrc */</span></span><br><span class="line">g_signal_emit_by_name (data-&gt;app_source, <span class="string">&quot;push-buffer&quot;</span>, buffer, &amp;ret);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free the buffer now that we are done with it */</span></span><br><span class="line">gst_buffer_unref (buffer);</span><br></pre></td></tr></table></figure>

<p>请注意，还有 <code>gst_app_src_push_buffer()</code> 作为 <code>gstreamer-app-1.0</code> 库的一部分，与上面的信回调相比，它可能是一个更好的用于将缓冲区推送到 appsrc 的函数，因为它具有适当的键入签名，这样就很难出错。但是，请注意，如果您使用 <code>gst_app_src_push_buffer()</code> ，它将获得传递的缓冲区的所有权，因此在这种情况下，您不必在推送后取消引用它。</p>
<p>准备好缓冲区后，我们将其与 <code>push-buffer</code> 操作信号一起传递给 <code>appsrc</code> （请参阅播放教程 1：Playbin 用法末尾的信息框），然后 <code>gst_buffer_unref()</code> 因为我们不再需要它了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Configure appsink */</span></span><br><span class="line"><span class="comment">// 设置收到新缓冲区时的回调函数，当 sink 收到新缓冲区时调用，</span></span><br><span class="line">  g_object_set (data.app_sink, <span class="string">&quot;emit-signals&quot;</span>, TRUE, <span class="string">&quot;caps&quot;</span>, audio_caps, <span class="literal">NULL</span>);</span><br><span class="line">  g_signal_connect (data.app_sink, <span class="string">&quot;new-sample&quot;</span>, G_CALLBACK (new_sample),</span><br><span class="line">      &amp;data);</span><br><span class="line">  gst_caps_unref (audio_caps);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The appsink has received a buffer */</span></span><br><span class="line"><span class="type">static</span> GstFlowReturn <span class="title function_">new_sample</span> <span class="params">(GstElement *sink, CustomData *data)</span> &#123;</span><br><span class="line">    GstSample *sample;</span><br><span class="line">    <span class="comment">/* Retrieve the buffer */</span></span><br><span class="line">    <span class="comment">// 使用 pull-sample 操作信号来获得缓冲区 sample，这里仅仅打印提示符</span></span><br><span class="line">    g_signal_emit_by_name (sink, <span class="string">&quot;pull-sample&quot;</span>, &amp;sample);</span><br><span class="line">    <span class="keyword">if</span> (sample) &#123;</span><br><span class="line">        <span class="comment">/* The only thing we do in this example is print a * to indicate a received buffer */</span></span><br><span class="line">        g_print (<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        gst_sample_unref (sample);</span><br><span class="line">        <span class="keyword">return</span> GST_FLOW_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> GST_FLOW_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>appsink</code> 接收缓冲区时调用上面的函数。使用 <code>pull-sample</code> 操作信号来检索缓冲区，然后在屏幕上打印一些指示符。</p>
<p> <code>gst_app_src_pull_sample()</code> 作为 <code>gstreamer-app-1.0</code> 库的一部分，与上面的信号发射相比，它可能是一个更好的用于从 appsink 中提取样本&#x2F;缓冲区的函数，因为它有一个正确的类型签名，所以很难出错。</p>
<p>为了获取数据指针，我们需要像上面一样使用 <code>gst_buffer_map()</code> ，它将使用指向数据的指针和数据大小（以字节为单位）填充 <code>GstMapInfo</code> 辅助结构。处理完数据后，不要忘记再次 <code>gst_buffer_unmap()</code> 缓冲区。</p>
<p>此缓冲区不必与我们在 <code>push_data</code> 函数中生成的缓冲区匹配，路径中的任何元素都可以以任何方式更改缓冲区（本例中没有：只有一个 <code>tee</code> 在 <code>appsrc</code> 和 <code>appsink</code> 之间的路径中，并且 <code>tee</code> 不会更改缓冲区的内容）。</p>
<p>最后 <code>gst_sample_unref()</code> 检索到的样本，本教程就完成了。</p>
<p>基础教程9：媒体信息采集</p>
<p>感觉用处不大</p>
<p>基础教程10：</p>
<p>无用</p>
<h2 id="基础教程11：调试工具"><a href="#基础教程11：调试工具" class="headerlink" title="基础教程11：调试工具"></a>基础教程11：调试工具</h2><p>GStreamer 及其插件充满了调试跟踪，即代码中将特别有趣的信息打印到控制台的位置，以及时间戳、进程、类别、源代码文件、函数和元素信息。调试输出由 <code>GST_DEBUG</code> 环境变量控制。</p>
<p>GStreamer 调试日志非常详细，完全启用会打印很多。设置 <code>GST_DEBUG=2</code>就可以获得 <code>ERROR</code> 和 <code>WARNING</code> 消息。</p>
<p>使用 <code>GST_ERROR()</code> 、 <code>GST_WARNING()</code> 、 <code>GST_INFO()</code> 、 <code>GST_LOG()</code> 和 <code>GST_DEBUG()</code> 宏。它们接受与 <code>printf</code> 相同的参数，并使用 <code>default</code> 类别（ <code>default</code> 将在输出日志中显示为“DEBUG”类别，对应值为5）。</p>
<p>获取管道图：</p>
<p>GStreamer 能够输出图形文件。这些是 <code>.dot</code> 文件，可以使用 GraphViz 等免费程序读取，描述管道的拓扑结构以及每个链接中协商的上限。</p>
<p>要获取 <code>.dot</code> 文件，只需将 <code>GST_DEBUG_DUMP_DOT_DIR</code> 环境变量设置为指向要放置文件的文件夹即可。 <code>gst-launch-1.0</code> 将在每次状态更改时创建一个 <code>.dot</code> 文件，因此您可以看到上限协商的演变。取消设置变量以禁用此功能。在您的应用程序中，您可以在方便时使用 <code>GST_DEBUG_BIN_TO_DOT_FILE()</code> 和 <code>GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS()</code> 宏生成 <code>.dot</code> 文件。</p>
<p>基础教程 12：流式传输</p>
<p>感觉用处不大</p>
<h3 id="基础教程13：播放速度"><a href="#基础教程13：播放速度" class="headerlink" title="基础教程13：播放速度"></a>基础教程13：播放速度</h3><p>所要做的就是改变播放速率，该变量对于正常播放来说等于 1.0，对于快速模式大于 1.0（绝对值），对于慢速模式小于 1.0（绝对值），对于向前播放为正值，反向播放时为负值。</p>
<p>GStreamer 提供了两种更改播放速率的机制：Step Events 和 Seek Events。除了更改后续播放速率（仅限正值）之外，Step Events 还允许跳过给定数量的媒体。此外，“Seek Events”允许跳转到流中的任何位置并设置正和负播放速率。</p>
<p>Step Events 是更改播放速率的更方便的方法，因为创建它们所需的参数数量减少了；但是，它们有一些缺点，因此本教程中使用 Seek Events。Step Events 仅影响接收器（在管道末端），因此只有当管道的其余部分可以支持以不同的速度运行时，它们才会起作用， Seek Events 会一直通过管道，因此每个元素都可以对它们做出反应。 Step Events 事件的优点是行动速度更快。步骤事件也无法改变播放方向。</p>
<p>要使用这些事件，需要创建它们，然后将其传递到管道，它们在管道中向上游传播，直到到达可以处理它们的元素。如果一个事件被传递到像 <code>playbin</code> 这样的 bin 元素上，它只会将事件提供给它的所有接收器，这将导致执行多次查找。常见的方法是通过 <code>video-sink</code> 或 <code>audio-sink</code> 属性检索 <code>playbin</code> 的接收器之一，并将事件直接送入接收器。</p>
<p>帧步进是一种允许逐帧播放视频的技术。它是通过暂停管道，然后发送 Step Events 每次跳过一帧来实现的。</p>
<p>main 函数中的初始化代码没有什么新内容：实例化了 <code>playbin</code> 管道，安装了 I&#x2F;O 监视器来跟踪击键，并执行了 GLib 主循环。然后，在键盘处理函数中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Process keyboard input */</span></span><br><span class="line"><span class="type">static</span> gboolean <span class="title function_">handle_keyboard</span> <span class="params">(GIOChannel *source, GIOCondition cond, CustomData *data)</span> &#123;</span><br><span class="line">    gchar *str = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_io_channel_read_line (source, &amp;str, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) != G_IO_STATUS_NORMAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (g_ascii_tolower (str[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            data-&gt;playing = !data-&gt;playing;</span><br><span class="line">            gst_element_set_state (data-&gt;pipeline, data-&gt;playing ? GST_STATE_PLAYING : GST_STATE_PAUSED);</span><br><span class="line">            g_print (<span class="string">&quot;Setting state to %s\n&quot;</span>, data-&gt;playing ? <span class="string">&quot;PLAYING&quot;</span> : <span class="string">&quot;PAUSE&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>与之前的教程一样，暂停&#x2F;播放切换是通过 <code>gst_element_set_state()</code> 处理的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">	<span class="keyword">if</span> (g_ascii_isupper (str[<span class="number">0</span>])) &#123;</span><br><span class="line">    	data-&gt;rate *= <span class="number">2.0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	data-&gt;rate /= <span class="number">2.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	send_seek_event (data);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">	data-&gt;rate *= <span class="number">-1.0</span>;</span><br><span class="line">	send_seek_event (data);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>使用“S”和“s”将当前播放速率加倍或减半，使用“d”反转当前播放方向。在这两种情况下，都会更新 <code>rate</code> 变量并调用 <code>send_seek_event</code> 。我们来回顾一下这个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Send seek event to change rate */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">send_seek_event</span> <span class="params">(CustomData *data)</span> &#123;</span><br><span class="line">    gint64 position;</span><br><span class="line">    GstEvent *seek_event;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Obtain the current position, needed for the seek event */</span></span><br><span class="line">    <span class="keyword">if</span> (!gst_element_query_position (data-&gt;pipeline, GST_FORMAT_TIME, &amp;position)) &#123;</span><br><span class="line">        g_printerr (<span class="string">&quot;Unable to retrieve current position.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该函数创建一个新的 Seek Event 并将其发送到管道以更新速率。首先，使用 <code>gst_element_query_position()</code> 恢复当前位置。这是必需的，因为 Seek  Events 跳转到流中的另一个位置，并且由于我们实际上不想移动，所以我们跳转到当前位置。使用 Step Events 会更简单，但该事件目前尚未完全发挥作用，如简介中所述。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create the seek event */</span></span><br><span class="line"><span class="keyword">if</span> (data-&gt;rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    seek_event = gst_event_new_seek (data-&gt;rate, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH </span><br><span class="line">| GST_SEEK_FLAG_ACCURATE, GST_SEEK_TYPE_SET, position, GST_SEEK_TYPE_END, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    seek_event = gst_event_new_seek (data-&gt;rate, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH </span><br><span class="line">| GST_SEEK_FLAG_ACCURATE, GST_SEEK_TYPE_SET, <span class="number">0</span>, GST_SEEK_TYPE_SET, position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Seek 事件是使用 <code>gst_event_new_seek()</code> 创建的。它的参数基本上是新的速率、新的开始位置和新的停止位置。无论哪种播放方向，起始位置都必须小于停止位置，因此两个播放方向要区别对待。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (data-&gt;video_sink == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* If we have not done so, obtain the sink through which we will send the seek events */</span></span><br><span class="line">    g_object_get (data-&gt;pipeline, <span class="string">&quot;video-sink&quot;</span>, &amp;data-&gt;video_sink, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新的事件最终通过 <code>gst_element_send_event()</code> 发送到选定的接收器。</p>
<p>回到键盘处理程序及，看一下帧步进代码，这非常简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (data-&gt;video_sink == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* If we have not done so, obtain the sink through which we will send the step events */</span></span><br><span class="line">    g_object_get (data-&gt;pipeline, <span class="string">&quot;video-sink&quot;</span>, &amp;data-&gt;video_sink, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gst_element_send_event (data-&gt;video_sink,</span><br><span class="line">                        gst_event_new_step (GST_FORMAT_BUFFERS, <span class="number">1</span>, ABS (data-&gt;rate), TRUE, FALSE));</span><br><span class="line">g_print (<span class="string">&quot;Stepping one frame\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>使用 <code>gst_event_new_step()</code> 创建一个新的步进事件，其参数基本上指定要跳过的量（示例中为 1 帧）和新速率（我们不更改）。</p>
<p>视频接收器是从 <code>playbin</code> 获取的，以防万一我们还没有，就像以前一样。</p>
<p>这样我们就完成了。测试本教程时，请记住，向后播放在许多元素中都不是最佳的。</p>
<h2 id="基础教程-14：方便的元素："><a href="#基础教程-14：方便的元素：" class="headerlink" title="基础教程 14：方便的元素："></a>基础教程 14：方便的元素：</h2><p>都是用在 <code>gst-launch-1.0</code> 工具中的参数，其中部分：</p>
<h3 id="uridecodebin"><a href="#uridecodebin" class="headerlink" title="uridecodebin"></a><code>uridecodebin</code></h3><p>该元素将数据从 URI 解码为原始媒体。它选择一个可以处理给定 URI 方案的源元素并将其连接到 <code>decodebin</code> 元素。它的作用就像一个解复用器，因此它提供与媒体中找到的流一样多的源 pad。</p>
<h3 id="decodebin"><a href="#decodebin" class="headerlink" title="decodebin"></a><code>decodebin</code></h3><p>该元素通过自动插入使用可用的解码器和解复用器自动构建解码管道，直到获得原始媒体。它由 <code>uridecodebin</code> 内部使用，通常使用起来更方便，因为它也创建了合适的源元素。它取代了旧的 <code>decodebin</code> 元素。它的作用就像一个解复用器，因此它提供与媒体中找到的流一样多的源 pad。</p>
<h3 id="videoconvert"><a href="#videoconvert" class="headerlink" title="videoconvert"></a><code>videoconvert</code></h3><p>元素从一种颜色空间（例如 RGB）转换为另一种颜色空间（例如 YUV）。它还可以在不同的 YUV 格式（例如 I420、NV12、YUY2 …）或 RGB 格式排列（例如 RGBA、ARGB、BGRA …）之间进行转换。这通常是解决谈判问题时的首选。当不需要时，由于其上游和下游元素已经可以相互理解，因此它以直通模式运行，对性能的影响最小。根据经验，每当您使用大写字母在设计时未知的元素（如 <code>autovideosink</code> ）或可能因外部因素（如解码用户）而变化时，请始终使用 <code>videoconvert</code> 。提供的文件。</p>
<h3 id="videorate"><a href="#videorate" class="headerlink" title="videorate"></a><code>videorate</code></h3><p>该元素接受带有时间戳的视频帧的传入流，并生成与源板的帧速率匹配的流。校正是通过丢弃和复制帧来执行的，没有使用花哨的算法来插值帧。这对于允许需要不同帧速率的元素进行链接非常有用。与其他适配器一样，如果不需要（因为两个 Pad 都可以同意帧速率），它会以直通模式运行并且不会影响性能。</p>
<h3 id="videoscale"><a href="#videoscale" class="headerlink" title="videoscale"></a><code>videoscale</code></h3><p>该元素调整视频帧的大小。默认情况下，元素会尝试在源焊盘和接收焊盘上协商到相同的大小，以便不需要缩放。因此，如果不需要扩展，则可以安全地将此元素插入管道中以获得更稳健的行为，而无需任何成本。该元素支持广泛的色彩空间，包括各种 YUV 和 RGB 格式，因此通常能够在管道中的任何位置运行。如果要将视频输出到大小由用户控制的窗口，则最好使用 <code>videoscale</code> 元素，因为并非所有视频接收器都能够执行缩放操作。</p>
<h2 id="播放教程3：缩短管道"><a href="#播放教程3：缩短管道" class="headerlink" title="播放教程3：缩短管道"></a>播放教程3：缩短管道</h2><p>基础教程 8：缩短管道展示了应用程序如何使用名为 appsrc 和 appsink 的两个特殊元素手动提取数据或将数据注入到管道中。<code>playbin</code> 也允许使用这些元素，但连接它们的方法不同。要将 <code>appsink</code> 连接到 <code>playbin</code> ，请参阅播放教程 7：自定义 playbin 接收器。本教程展示 如何将 <code>appsrc</code> 与 <code>playbin</code> 连接并配置<code>appsrc</code></p>
<p>要使用 <code>appsrc</code> 作为管道源，只需实例化 <code>playbin</code> 并将其 URI 设置为 <code>appsrc://</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create the playbin element */</span></span><br><span class="line">data.pipeline = gst_parse_launch (<span class="string">&quot;playbin uri=appsrc://&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p><code>playbin</code> 将创建一个内部 <code>appsrc</code> 元素并触发 <code>source-setup</code> 信号以允许应用程序对其进行配置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g_signal_connect (data.pipeline, <span class="string">&quot;source-setup&quot;</span>, G_CALLBACK (source_setup), &amp;data);</span><br></pre></td></tr></table></figure>

<p>设置 <code>appsrc</code> 的<code>caps</code> 属性非常重要，因为一旦信号处理程序返回， <code>playbin</code> 将根据这些上限实例化管道中的下一个元素：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 当 playbin 创建 appsrc 元素时会调用此函数，因此我们有机会对其进行配置。*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">source_setup</span> <span class="params">(GstElement *pipeline, GstElement *source, CustomData *data)</span> &#123;</span><br><span class="line">    GstAudioInfo info;</span><br><span class="line">    GstCaps *audio_caps;</span><br><span class="line"></span><br><span class="line">    g_print (<span class="string">&quot;Source has been created. Configuring.\n&quot;</span>);</span><br><span class="line">    data-&gt;app_source = source;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configure appsrc */</span></span><br><span class="line">    gst_audio_info_set_format (&amp;info, GST_AUDIO_FORMAT_S16, SAMPLE_RATE, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    audio_caps = gst_audio_info_to_caps (&amp;info);</span><br><span class="line">    g_object_set (source, <span class="string">&quot;caps&quot;</span>, audio_caps, <span class="string">&quot;format&quot;</span>, GST_FORMAT_TIME, <span class="literal">NULL</span>);</span><br><span class="line">    g_signal_connect (source, <span class="string">&quot;need-data&quot;</span>, G_CALLBACK (start_feed), data);</span><br><span class="line">    g_signal_connect (source, <span class="string">&quot;enough-data&quot;</span>, G_CALLBACK (stop_feed), data);</span><br><span class="line">    gst_caps_unref (audio_caps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>appsrc</code> 的配置与基础教程 8：缩短管道完全相同：将 caps 设置为 <code>audio/x-raw</code> ，并注册了两个回调，因此元素可以告诉应用程序何时需要启动和停止推送数据。有关更多详细信息，请参阅基础教程 8：缩短管道。</p>
<p>从这一点开始， <code>playbin</code> 负责处理管道的其余部分，应用程序只需要担心在被告知时生成更多数据。</p>
<p>要了解如何使用 <code>appsink</code> 元素从 <code>playbin</code> 中提取数据，请参阅播放教程 7：自定义 playbin 接收器。</p>
<h2 id="播放教程-7：自定义-playbin-接收器"><a href="#播放教程-7：自定义-playbin-接收器" class="headerlink" title="播放教程 7：自定义 playbin 接收器"></a>播放教程 7：自定义 playbin 接收器</h2><p><code>playbin</code> 可以通过手动选择其音频和视频接收器来进一步自定义。这允许应用程序依赖 <code>playbin</code> 来检索和解码媒体，然后自行管理最终的渲染&#x2F;显示。</p>
<p><code>playbin</code> 的两个属性允许选择所需的音频和视频接收器： <code>audio-sink</code> 和 <code>video-sink</code> （分别）。应用程序只需要实例化适当的 <code>GstElement</code> 并通过这些属性将其传递给 <code>playbin</code> 。但是，此方法只允许使用单个元素作为接收器。如果需要更复杂的管道，例如均衡器加音频接收器，则需要将其包装在 Bin 中，因此它看起来 <code>playbin</code> 就好像它是单个 Element 一样。</p>
<p>Bin ( <code>GstBin</code> ) 是一个封装部分管道的容器，因此可以将它们作为单个元素进行管理。例如，我们在所有教程中使用的 <code>GstPipeline</code> 是 <code>GstBin</code> 的类型，它不与外部元素交互。 Bin 内的元素通过 Ghost Pad ( <code>GstGhostPad</code> ) 连接到外部元素，这是 Bin 表面上的 Pad，它只是将数据从外部 Pad 转发到内部元素上的给定 Pad。</p>
<p><code>GstBin</code> 也是 <code>GstElement</code> 的一种类型，因此它们可以在需要 Element 的任何地方使用，特别是作为 <code>playbin</code> 的接收器（然后它们被称为水槽）。</p>
<img src="https://cdn.jsdelivr.net/gh/yuanmxc/Picture@main/Typora-PicGo/202407121449898.png" alt="image-20240712144952972" style="zoom: 67%;" />

<p>图 1：带有两个 Elements 和一个 Ghost Pad 的 Bin。</p>
<p><code>GstBin</code> 也是 <code>GstElement</code> 的一种类型，因此它们可以在需要 Element 的任何地方使用，特别是作为 <code>playbin</code> 的接收器（然后它们被称为水槽）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create the elements inside the sink bin */</span></span><br><span class="line">equalizer = gst_element_factory_make (<span class="string">&quot;equalizer-3bands&quot;</span>, <span class="string">&quot;equalizer&quot;</span>);</span><br><span class="line">convert = gst_element_factory_make (<span class="string">&quot;audioconvert&quot;</span>, <span class="string">&quot;convert&quot;</span>);</span><br><span class="line">sink = gst_element_factory_make (<span class="string">&quot;autoaudiosink&quot;</span>, <span class="string">&quot;audio_sink&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!equalizer || !convert || !sink) &#123;</span><br><span class="line">    g_printerr (<span class="string">&quot;Not all elements could be created.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组成的 sink-bin 的所有元素都被实例化。我们使用 <code>equalizer-3bands</code> 和 <code>autoaudiosink</code> ，中间有 <code>audioconvert</code> ，因为我们不确定音频接收器的功能（因为它们是硬件 -依赖）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create the sink bin, add the elements and link them */</span></span><br><span class="line">bin = gst_bin_new (<span class="string">&quot;audio_sink_bin&quot;</span>);</span><br><span class="line">gst_bin_add_many (GST_BIN (bin), equalizer, convert, sink, <span class="literal">NULL</span>);</span><br><span class="line">gst_element_link_many (equalizer, convert, sink, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>这会将新元素添加到 Bin 中并将它们链接起来，就像我们在管道中所做的那样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取bin的第一个元素 equalize r的 sink pad</span></span><br><span class="line">pad = gst_element_get_static_pad (equalizer, <span class="string">&quot;sink&quot;</span>);</span><br><span class="line"><span class="comment">// 用上面获取的pad new 一个 ghost_pad 并启用</span></span><br><span class="line">ghost_pad = gst_ghost_pad_new (<span class="string">&quot;sink&quot;</span>, pad);</span><br><span class="line">gst_pad_set_active (ghost_pad, TRUE);</span><br><span class="line"><span class="comment">// 为 bin 添加 ghost_pad</span></span><br><span class="line">gst_element_add_pad (bin, ghost_pad);</span><br><span class="line"><span class="comment">// 释放旧 pad，ghost_pad 所有权在 bin</span></span><br><span class="line">gst_object_unref (pad);</span><br></pre></td></tr></table></figure>

<p>现在我们需要创建一个 Ghost Pad，以便 Bin 内的部分管道可以连接到外部。该 Ghost Pad 将连接到内部 Elements 之一的 Pad（均衡器的接收器 pad），因此我们使用 <code>gst_element_get_static_pad()</code> 检索该 Pad。请记住基础教程 7：多线程和 Pad 可用性，如果这是 Request Pad 而不是 Always Pad，我们将需要使用 <code>gst_element_request_pad()</code> 。</p>
<p>Ghost Pad 使用 <code>gst_ghost_pad_new()</code> 创建（指向我们刚刚获取的内部 Pad），并使用 <code>gst_pad_set_active()</code> 激活。然后使用 <code>gst_element_add_pad()</code> 将其添加到 Bin，将 Ghost Pad 的所有权转移到 bin，因此我们不必担心释放它。</p>
<p>最后，我们从均衡器 equalizer 获得的 sink Pad 需要用 <code>gst_object_unref()</code> 释放。</p>
<p>此时，我们有了一个功能性的 sink-bin，我们可以将其用作 <code>playbin</code> 中的音频接收器。我们只需要指示 <code>playbin</code> 使用它：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set playbin&#x27;s audio sink to be our sink bin */</span></span><br><span class="line">g_object_set (GST_OBJECT (pipeline), <span class="string">&quot;audio-sink&quot;</span>, bin, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>就像将 <code>playbin</code> 上的 <code>audio-sink</code> 属性设置为新创建的接收器一样简单。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Configure the equalizer */</span></span><br><span class="line">g_object_set (G_OBJECT (equalizer), <span class="string">&quot;band1&quot;</span>, (gdouble)<span class="number">-24.0</span>, <span class="literal">NULL</span>);</span><br><span class="line">g_object_set (G_OBJECT (equalizer), <span class="string">&quot;band2&quot;</span>, (gdouble)<span class="number">-24.0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>剩下的唯一一点就是配置均衡器。对于此示例，两个较高频段被设置为最大衰减，因此低音得到增强。稍微调整一下这些值以感受差异（请参阅 <code>equalizer-3bands</code> 元素的文档以了解允许的值范围）。</p>
<h4 id="gst-app-src-push-buffer"><a href="#gst-app-src-push-buffer" class="headerlink" title="gst_app_src_push_buffer"></a><em>gst_app_src_push_buffer</em></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GstFlowReturn</span><br><span class="line"><span class="title function_">gst_app_src_push_buffer</span> <span class="params">(GstAppSrc * appsrc,</span></span><br><span class="line"><span class="params">                         GstBuffer * buffer)</span></span><br></pre></td></tr></table></figure>

<p>将缓冲区添加到缓冲区队列中，appsrc 元素将其推送到其源焊盘。该函数取得缓冲区的所有权。<br>当 block 属性为 TRUE 时，此函数可以阻塞，直到队列中出现可用空间。</p>
<h4 id="gst-app-src-get-stream-type"><a href="#gst-app-src-get-stream-type" class="headerlink" title="gst_app_src_get_stream_type"></a><em>gst_app_src_get_stream_type</em></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GstAppStreamType</span><br><span class="line"><span class="title function_">gst_app_src_get_stream_type</span> <span class="params">(GstAppSrc * appsrc)</span></span><br></pre></td></tr></table></figure>


<p>获取流类型。使用 <a href="https://gstreamer.freedesktop.org/documentation/applib/gstappsrc.html#gst_app_src_set_stream_type">gst_app_src_set_stream_type</a> 控制 appsrc 的流类型。</p>
<p><strong>参数：</strong></p>
<p><strong><code>appsrc</code></strong> – a <a href="https://gstreamer.freedesktop.org/documentation/applib/gstappsrc.html#GstAppSrc">GstAppSrc</a></p>
<p>返回流类型。</p>
<h4 id="gst-app-src-get-size"><a href="#gst-app-src-get-size" class="headerlink" title="gst_app_src_get_size"></a><em>gst_app_src_get_size</em></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gint64</span><br><span class="line"><span class="title function_">gst_app_src_get_size</span> <span class="params">(GstAppSrc * appsrc)</span></span><br></pre></td></tr></table></figure>

<p>获取流的大小（以字节为单位）。值 -1 表示大小未知。</p>
<p><strong>参数：</strong></p>
<p><strong><code>appsrc</code></strong> – a <a href="https://gstreamer.freedesktop.org/documentation/applib/gstappsrc.html#GstAppSrc">GstAppSrc</a></p>
<p> 返回 – 之前使用 gst_app_src_set_size 设置的流的大小；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -g src/server.cc -o server `pkg-config --cflags --libs gstreamer-1.0 gstreamer-video-1.0` -lstdc++ -lpthread -lstdc++ -lstdc++fs -lstdc++ -lgstapp-1.0 -lgstvideo-1.0 -lgstbase-1.0</span><br><span class="line"></span><br><span class="line">gcc -g src/extract_frame.c -o extract_frame `pkg-config --cflags --libs gstreamer-1.0`</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>Git 使用笔记</title>
    <url>/2022/03/25/Git%20%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Git-使用笔记"><a href="#Git-使用笔记" class="headerlink" title="Git 使用笔记"></a>Git 使用笔记</h1><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>远程仓库指 github 仓库（repositoris），本地仓库指自己被 git 管理的文件夹（含有.git 文件夹）。</p>
<ul>
<li><p>重新与远程仓库建立联系，并可以提交代码（自己远程仓库有代码 , 本地无代码，比如重装系统或者换电脑）：</p>
</li>
<li><p>如果只是本地没有了仓库，在与远程仓库建立链接时提示”远程 origin 已存在 “，可以直接 commit+push。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆远程仓库到本地仓库</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:username/repository_name.git(远程仓库地址ssh）</span><br><span class="line"><span class="comment"># cd 进本地仓库</span></span><br><span class="line"><span class="built_in">cd</span> 仓库</span><br><span class="line"><span class="comment"># 初始化 git</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 与远程仓库建立链接（关联远程仓库，远程仓库名字叫 origin）</span></span><br><span class="line">git remote add origin git@github.com:username/repository_name.git(远程仓库地址ssh)</span><br><span class="line"><span class="comment"># 获取远程更新</span></span><br><span class="line">git fetch origin</span><br><span class="line"><span class="comment"># 把更新的内容合并到本地分支</span></span><br><span class="line">git merge origin/main</span><br><span class="line"><span class="comment"># 对代码进行一些修改</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;...&quot;</span></span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个新的仓库：</p>
</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先在 github 上创建一个空仓库（之后其实就可以看到教程了）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 README.md 文件，并写入 &quot;# test&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;# test &quot;</span> &gt;&gt; README.md </span><br><span class="line"><span class="comment"># 初始化.git 文件夹</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 将刚刚创建的 README.md 文件加入 git 管理</span></span><br><span class="line">git add README.md </span><br><span class="line"><span class="comment"># 创建一个提交（即刚刚 README.md 文件的变化）</span></span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span> </span><br><span class="line"><span class="comment"># 创建分支 main 作为默认分支</span></span><br><span class="line">git branch -M main</span><br><span class="line"><span class="comment"># 与远程仓库建立连接，远程仓库的名字默认是 origin（可换）</span></span><br><span class="line">git remote add origin git@github.com:username/repository_name.git（远程仓库地址ssh）</span><br><span class="line"><span class="comment"># 将提交推送到远程仓库（-u 是指第一次提交）</span></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<ul>
<li><p>把本地的仓库提交到一个新建立的远程仓库（即远程仓库为空，本地已经有了一个包含.git 文件的仓库，希望不改变内容，将本地仓库推送到远程并关联）</p>
</li>
<li><pre><code class="bash"># 与远程仓库建立连接（关联）
git remote add origin git@github.com:username/repository_name.git（远程仓库地址ssh）
# 与远程仓库建立连接，远程仓库的名字默认是 origin（可换）
git branch -M main
# 将提交推送到远程仓库（-u 是指第一次提交）
git push -u origin [分支名]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 部分报错解决</span><br><span class="line"></span><br><span class="line">+ 远程 origin/upstream 已存在：</span><br><span class="line">  </span><br><span class="line">  ```bash</span><br><span class="line">  # 查看远程配置</span><br><span class="line">  git remote -v</span><br><span class="line">  # 删除远程配置  </span><br><span class="line">  git remote rm [远程仓库名]     （一般是origin或者upstream）</span><br><span class="line">  # 更改远程配置（可以直接修改，不需要上一步的删除）</span><br><span class="line">  git remote set-url upstream [upstream的新地址]      </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>fatal: 拒绝合并无关的历史：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要将远程仓库和本地仓库关联起来：</span></span><br><span class="line">git branch --set-upstream-to=origin/main main</span><br><span class="line"><span class="comment"># 然后使用 git pull 整合远程仓库和本地仓库</span></span><br><span class="line">git pull --allow-unrelated-histories# 忽略版本不同造成的影响</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="如何给开源社区提交-PR"><a href="#如何给开源社区提交-PR" class="headerlink" title="如何给开源社区提交 PR"></a>如何给开源社区提交 PR</h2><p>假设官方 GitHub 名叫 [officialName]，你的 GitHub 名叫 [yourName]，GitHub 仓库名字叫 [repository]。</p>
<ol>
<li><p>网页操作：在官 C 语言代码方 GitHub 仓库 fork 一个相同的仓库到你的 GitHub.</p>
</li>
<li><p>在你的仓库复制代码地址 [your code SSH&#x2F;HTTPS]，在官方仓库复制代码地址 [official code SSH&#x2F;HTTPS]，然后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆你 GitHub 仓库到本地</span></span><br><span class="line">git <span class="built_in">clone</span> [your code SSH/HTTPS]</span><br><span class="line"><span class="comment"># 添加官方仓库地址</span></span><br><span class="line">git remote add upstream [official code SSH/HTTPS]</span><br><span class="line"><span class="comment"># 检查仓库的远程信息</span></span><br><span class="line">git remote -v</span><br><span class="line"><span class="comment"># 远程信息输出应为：</span></span><br><span class="line">origin  [your code SSH/HTTPS] (fetch)</span><br><span class="line">origin  [your code SSH/HTTPS] (push)</span><br><span class="line">upstream        [official code SSH/HTTPS] (fetch)</span><br><span class="line">upstream        [official code SSH/HTTPS] (push)</span><br></pre></td></tr></table></figure>

<p>fetch 和 push 分别代表你在 fetch（拉取）和 push（推送）的 GitHub 仓库的地址，origin 代表你的 GitHub 仓库，upstream 代表官方的 GitHub 仓库。</p>
</li>
<li><pre><code class="bash"># 从 upstream 中获取最新的代码下载到本地，但是不会自动合并到本地分支中。一般和下面第二个命令一起使用。
git fetch upstream
# 将 upstream 的 master 分支合并到当前本地分支中，如果有冲突需要手动解决（本地分支的代码就与 upstream 的 master 分支保持同步）
git merge upstream/master
# 创建并切换到名为 fixBug 的新分支
git checkout -b fixBug
# 将当前分支 fixBug 推送到远程仓库 origin 上，并将本地分支和远程分支关联起来。
git push -u origin fixBug
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 之后，你可以在 fixBug 分支上进行一些修改，然后通过一下步骤将修改好的代码 push 到 GitHub 仓库的对应分支。</span><br><span class="line"></span><br><span class="line">   当你需要切换分支时，你必须 commit 当前的代码。</span><br><span class="line"></span><br><span class="line">   你的每一次 comiit 都会有所记录，当你 push 后，会把所有的 commit 都交上去，如果你 commit 的文件涉及到一个 pr，那么 pr 中也会有所修改，记录你的 commit。</span><br><span class="line"></span><br><span class="line">   ```bash</span><br><span class="line">   # 查看修改了那些文件</span><br><span class="line">   git status</span><br><span class="line">   # 查看修改内容</span><br><span class="line">   git diff</span><br><span class="line">   # add 提交</span><br><span class="line">   git add .</span><br><span class="line">   # commit 提交（如果官方仓需要 Signed-off-by 检查的就带账号邮箱信息）</span><br><span class="line">   git commit -m &quot;xxxxx&quot; -s</span><br><span class="line">   # 将过去的 n 个 commit 合并为一个 commit（等待尝试）</span><br><span class="line">   git rebase -i HEAD~n # 打开一个编辑器，将第二行开始的每一行的第一个单词从 pick 改为 squash。然后保存文件并退出。另一个编辑器会打开，在这里修改最终的提交信息。</span><br><span class="line">   # 将本次提交合并到上一次提交，如果你上一次提交已经 push 过，需要使用--force 或者--force-with-lease 选项来强制推送。可能会覆盖其他人在远程仓库上做的修改，谨慎使用。</span><br><span class="line">   git commit --amend  # 会打开一个编辑器，让你修改提交信息。</span><br><span class="line">   # push 到远程仓</span><br><span class="line">   git push origin</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>此时，你的 GitHub 仓库的 fixBug 分支的代码已经发生了变化，在 Pull requests 界面你可以找到提交 PR 的方法，然后就就可以按照社区要去提供代码了。对于本地的代码，一旦你创建分支之后，master 和 fixBug 就是两份代码了，你在 fixBug 的修改并不会影响到 master 的的代码。你可以通过 <code>git checkout [分支名]</code> 来切换到你想要的分支。你可以创建多个分支来确保工作的顺利进行。</p>
</li>
</ol>
<h2 id="其他有用的命令"><a href="#其他有用的命令" class="headerlink" title="其他有用的命令"></a>其他有用的命令</h2> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分支操作：</span></span><br><span class="line"><span class="comment"># 查看所有分支</span></span><br><span class="line">git bC语言代码</span><br><span class="line">ranch（*代表当前所在分支）</span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d [branchName](-d换为-D强制删除)</span><br><span class="line"><span class="comment"># 更改分支名</span></span><br><span class="line">git branch -m [oldName] [newName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从远程仓库 upstream 拉取代码（获取最新的代码，但不会将其合并到本地）</span></span><br><span class="line">git fetch upstream</span><br><span class="line"><span class="comment"># 从远程仓库 origin 拉取代码（获取最新的代码，但不会将其合并到本地）</span></span><br><span class="line">git fetch origin</span><br><span class="line"><span class="comment"># 比较本地仓库当前的分支 HEAD 和 upstream/master 分支之间的差异</span></span><br><span class="line">git diff HEAD upstream/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示本地的 commit 历史版本</span></span><br><span class="line">git <span class="built_in">log</span> </span><br><span class="line"><span class="comment"># 根据 commit 历史版本号，可以进行版本回退</span></span><br><span class="line">git reset [版本号]</span><br><span class="line"><span class="comment"># 将本地分支重置为最新拉取的 upstream 仓库的版本</span></span><br><span class="line">git reset --hard upstream/&lt;upstream_branch_name&gt;</span><br><span class="line"><span class="comment"># 将本地分支重置为 oorigin 仓库的版本</span></span><br><span class="line">git reset --hard origin/&lt;origin_branch_name&gt;</span><br><span class="line"><span class="comment"># 将本地仓库的更改推送到 origin（-f 选项强制推送更改，这将覆盖 origin 仓库中的所有更改）</span></span><br><span class="line">git push -f origin &lt;local_branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地未跟踪的目录和文件（d 和 f 分别指目录和文件）</span></span><br><span class="line">git clean -<span class="built_in">df</span></span><br><span class="line"><span class="comment"># 从 origin 指定的(自己的）GitHub 仓库拉取代码</span></span><br><span class="line">git fetch origin</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo+Github Pages 搭建个人博客</title>
    <url>/2023/03/15/Hexo+GitHub%20Pages%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Hexo-GitHub-Pages-搭建个人博客"><a href="#Hexo-GitHub-Pages-搭建个人博客" class="headerlink" title="Hexo+GitHub Pages 搭建个人博客"></a>Hexo+GitHub Pages 搭建个人博客</h1><p>[TOC]</p>
<h2 id="安装-Node-js-、-npm-和-Hexo-CLI"><a href="#安装-Node-js-、-npm-和-Hexo-CLI" class="headerlink" title="安装 Node.js 、 npm 和 Hexo CLI"></a>安装 Node.js 、 npm 和 Hexo CLI</h2><ol>
<li><p>安装 node.js 和 npm。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S nodejs npm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 hexo 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> npm install -g hexo-cli</span><br><span class="line"><span class="comment"># 也可以使用 yay 安装</span></span><br><span class="line">yay -S hexo-cli</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h2><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>可选，新建一个 文件夹存放所有博客相关内容，方便管理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> BlogAll</span><br></pre></td></tr></table></figure>

<h3 id="新建并初始化博客"><a href="#新建并初始化博客" class="headerlink" title="新建并初始化博客"></a>新建并初始化博客</h3><p>文件夹名以 YuanmxcBlog 为例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> BlogAll</span><br><span class="line"><span class="built_in">mkdir</span> YuanmxcBlog</span><br><span class="line"><span class="built_in">cd</span> YuanmxcBlog</span><br><span class="line">hexo init <span class="comment"># 初始化，这会在当前目录下生成一些默认文件</span></span><br><span class="line">npm install <span class="comment"># 安装 package.json 内的项目所需的依赖包在 node_modules 内</span></span><br></pre></td></tr></table></figure>

<p>初始化博客文件夹后，会在当前目录下生成一些默认文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">ls</span></span><br><span class="line">_config.landscape.yml  node_modules  package-lock.json  <span class="built_in">source</span></span><br><span class="line">_config.yml            package.json  scaffolds          themes</span><br></pre></td></tr></table></figure>

<h3 id="博客相关文件简单介绍"><a href="#博客相关文件简单介绍" class="headerlink" title="博客相关文件简单介绍"></a>博客相关文件简单介绍</h3><ul>
<li><p><strong><code>_config.yml</code></strong></p>
<p>Hexo 的默认主配置文件。包括站点的全局配置，例如网站标题、描述、URL、语言、分页设置、部署配置等。用于控制网站的全局行为和外观。</p>
</li>
<li><p><strong><code>_config.landscape.yml</code></strong></p>
<p> 用于特定场景或主题的附加配置文件。Hexo 默认主题 <code>landscape</code> 的配置文件（如果你未使用此主题，可忽略或删除）。后面更改主题时，不同主题或环境需要不同配置，会创建类似的文件。可以覆盖或扩展主配置文件中的某些配置。</p>
</li>
<li><p><strong><code>node_modules</code></strong></p>
<p> 文件夹内包含通过 npm 安装的所有 Node.js 模块和依赖包。Hexo 本身及其插件的所有依赖都在这里。</p>
</li>
<li><p><strong><code>package-lock.json</code></strong></p>
<p>npm 自动生成的文件，记录了项目中所有已安装包的具体版本及其依赖关系。保证每次安装依赖时使用的版本一致，确保环境的可重复性。</p>
</li>
<li><p><strong><code>package.json</code></strong></p>
<p>定义了项目的基本信息（如名称、版本），列出了项目的依赖包以及可执行的脚本（如 Hexo 核心包、插件等）。管理项目依赖和 npm 脚本，帮助开发者维护和分享项目。</p>
</li>
<li><p><strong><code>source</code></strong></p>
<p>用于存放网站内容的文件夹。所有文章、页面、资源（如图片、视频）都放在这里。存储和组织博客内容。</p>
</li>
<li><p><strong><code>scaffolds</code></strong></p>
<p>包含模板文件的文件夹，定义新文章或页面的初始结构。当通过 <code>hexo new</code> 创建新文章或页面时，会基于这些模板生成文件。</p>
</li>
<li><p><strong><code>themes</code></strong></p>
<p>用来存放网站的主题。每个主题都有其独立的文件夹，其中包含模板、样式表、脚本和其他资源。 控制网站的外观和布局。</p>
</li>
</ul>
<h3 id="生成和预览博客"><a href="#生成和预览博客" class="headerlink" title="生成和预览博客"></a>生成和预览博客</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new “HelloWorld”</span><br></pre></td></tr></table></figure>
<p>生成 <code>HelloWorld.md</code> 文件（你的文章），存放在 <code>/your_blogyour_blog/sources/_post/</code> 目录下。该目录下会存放执行该命令后生成的静态站点文件（用于部署）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p>使用缩写 <code> hexo g</code>  亦可。该命令会将 <code>/your_blog/sources/_post/</code> 目录下的 Markdown 文件解析成可以使用浏览器查看的 HTML 文件，存在 <code>blog/public</code> 目录下。同时生成 <code>db.json</code> 文件。</p>
<ul>
<li><p>**<code>db.json</code> **</p>
<p>Hexo 的 <strong>缓存数据库</strong>，用于存储文章、页面等数据的元信息，加速生成过程。如果文章内容或配置有变化，Hexo 会自动更新此文件。</p>
</li>
<li><p><strong><code>public</code></strong></p>
<p>由 <code>hexo generate</code>（或 <code>hexo g</code>）命令生成，存放命令生成的静态网站文件，包含所有渲染后的 HTML、CSS、JS 和资源文件（图片等）。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>使用缩写 <code> hexo s</code>  亦可。该命令会在本地运行服务，可以在提示的网址进行预览博客。(目前使用的是默认主题，后面可以根据自己喜好更换其他主题)。</p>
<h2 id="Hexo-配合-GitHub-Page-部署"><a href="#Hexo-配合-GitHub-Page-部署" class="headerlink" title="Hexo 配合 GitHub Page 部署"></a>Hexo 配合 GitHub Page 部署</h2><h3 id="新建一个-GitHub-仓库"><a href="#新建一个-GitHub-仓库" class="headerlink" title="新建一个 GitHub 仓库"></a>新建一个 GitHub 仓库</h3><ol>
<li><p>新建仓库</p>
<p> 在你的 GtiHub 上新建一个仓库，仓库权限设为 public，仓库名格式为 <code>&lt;你的GitHub用户名&gt;.github.io</code> 。这里以 <code>Yuanmxc.Github.io</code> 为例。或者使用自定义的仓库名，这里以 <code>YuanmxcBlog</code>为例。两者有些许差异。</p>
<blockquote>
<p>1（<code>&lt;username&gt;.github.io</code>）</p>
<ul>
<li>部署位置：自动映射到根域名<ul>
<li>访问地址：<code>https://&lt;username&gt;.github.io</code></li>
<li>直接解析仓库根目录内容（无需子路径）</li>
</ul>
</li>
<li><strong>分支要求</strong>：必须使用<code>master/main</code>分支</li>
<li>用途特性：<ul>
<li>每个账户只能有1个此类仓库</li>
<li>适合作为个人主站&#x2F;博客入口</li>
<li>支持绑定顶级自定义域名（如<code>yourdomain.com</code>）</li>
</ul>
</li>
</ul>
<ol start="2">
<li>普通项目仓库（任意名称）</li>
</ol>
<ul>
<li>部署位置：自动添加仓库名作为子路径<ul>
<li>访问地址：<code>https://&lt;username&gt;.github.io/&lt;repo-name&gt;</code></li>
</ul>
</li>
<li>分支灵活：<ul>
<li>可选择<code>gh-pages</code>分支</li>
<li>或<code>master/main</code>分支的<code>/docs</code>目录</li>
</ul>
</li>
<li>用途特性：<ul>
<li>适合项目文档或子站点</li>
<li>每个项目独立部署</li>
<li>可绑定子域名（如<code>blog.yourdomain.com</code>）</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>设置 Pages 页面</p>
<p> 打开仓库的 Setting 的 Pages 设置，根据你自己的情况进行设置。如果有自己购买的域名，可以设置上（请自行查看其他教程）。</p>
<p> 我的示例：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/Yuanmxc/PicturesAll/Typora-PicGo/%E2%80%9CHexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E2%80%9D%E9%85%8D%E5%9B%BEp1.png" alt="image-20250224210941937"></p>
</li>
</ol>
<h3 id="设置-Hexo-远程部署方式为-Github"><a href="#设置-Hexo-远程部署方式为-Github" class="headerlink" title="设置 Hexo 远程部署方式为 Github"></a>设置 Hexo 远程部署方式为 Github</h3><p>在 <code>YuanmxcBlog</code> 目录下安装使用 Git 进行部署所需的依赖项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>在 <code>YuanmxcBlog/_config.yml</code> 中修改 deploy 属性（注意:之后有空格）。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> [<span class="string">你的仓库地址</span>,<span class="string">如果有ssh推荐使用ssh</span>]</span><br><span class="line">  <span class="comment"># 例如：https://github.com/Yuanmxc/YuanmxcBlog</span></span><br><span class="line">  <span class="comment"># 例如：https://github.com/Yuanmxc/Yuanmxc.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<h3 id="第一次远程部署"><a href="#第一次远程部署" class="headerlink" title="第一次远程部署"></a>第一次远程部署</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy </span><br></pre></td></tr></table></figure>

<p>使用 <code>hexo d</code> 亦可，这个命令会将本地的 <code>public</code> 目录的内容复制到 <code>.deploy_git</code> （新生成的）目录内下。</p>
<ul>
<li><p><strong><code>.deploy_git</code></strong> </p>
<p>这个目录就是 Git 管理的目录，与你上面配置文件中填入的 GitHub 仓库进行绑定，然后通过 Git 操作（<code>git add</code>, <code>git commit</code>, <code>git push</code>）将内容推送到你配置的 GitHub Pages 仓库。同时更新你的 Github page 个人博客展示界面（可能有延迟）。</p>
</li>
</ul>
<p>此时你的目录下应该有以下文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">ls</span> -a</span><br><span class="line">.            _config.yml        node_modules  <span class="built_in">source</span></span><br><span class="line">..           db.json            package.json  themes</span><br><span class="line">.deploy_git  package-lock.json  .github       public</span><br><span class="line">_config.landscape.yml           .gitignore    scaffolds</span><br></pre></td></tr></table></figure>

<p>比之前多了 5 个文件。除了<code>db.json</code>、 <code>public</code> 目录和 <code>deploy_git</code> 目录外，剩下两个生成的文件简单解释如下：</p>
<ul>
<li><p><strong><code>.github</code> 目录</strong></p>
<p>GitHub 相关目录，存放 GitHub Actions 的配置文件（如 <code>.github/workflows/xxx.yml</code>），用于自动化部署或其他 CI&#x2F;CD 流程。</p>
</li>
<li><p><strong><code>.gitignore</code> 文件</strong></p>
<p>定义 Git 忽略的文件&#x2F;目录，避免将临时文件、依赖项等提交到仓库。</p>
<p>常见忽略项：</p>
<ul>
<li><code>node_modules/</code>：npm 依赖目录。</li>
<li><code>public/</code>：生成的静态文件。</li>
<li><code>.deploy_git/</code>：部署临时目录。</li>
<li><code>db.json</code>：Hexo 的缓存数据。</li>
</ul>
</li>
</ul>
<h2 id="后续更新"><a href="#后续更新" class="headerlink" title="后续更新"></a>后续更新</h2><p>经过上面的步骤，你现在已经在本地和 GitHub Pages 部署了你的博客，并可以通过特定的域名去访问它。</p>
<h3 id="以后更新博客"><a href="#以后更新博客" class="headerlink" title="以后更新博客"></a>以后更新博客</h3><ol>
<li><p>写文章：</p>
<p>使用 Typora 等 Markdown 编辑器，在 <code>YuanmxcBlog/sources/_post/</code>目录下创建 Markdown 文件，并编辑。</p>
</li>
<li><p>生成静态文件、本地预览、推送远程更新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g <span class="comment"># 将Markdown文件解析成HTML文件</span></span><br><span class="line">hexo server <span class="comment"># 本地预览（可无）</span></span><br><span class="line">hexo d <span class="comment"># 推送远程更新</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li><p>短时间内对本地配置文件进行修改后，推荐使用 <code>Hexo cl</code> 命令来清除缓存，之后在执行 <code>Hexo s</code> 来查看修改后的效果。</p>
</li>
<li><p>你的 Github 本地仓库应该位于 <code>YuanmxcBlog</code> 目录，并且名为 <code>.deploy_git</code>，不要更改，博客网站就是目录下的文件生成的。执行 <code>hexo d</code> 命令时会自动帮你更改仓库中的文件，不需要手动处理。同时，执行 hexo 命令需要在 <code>YuanmxcBlog</code> 目录下进行操作。</p>
</li>
</ul>
<h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>Hexo 可以自由更换主题，可以自行查找自己喜欢的主题，具体主题使用请查看对应的教程文档，仔细按照教程文档来操作，本站使用主题: <a href="https://github.com/jerryc127/hexo-theme-butterfly">hexo-theme-butterfly hexo-主题-蝴蝶</a>。</p>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>TCP的可靠数据传输</title>
    <url>/2023/03/16/TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<h1 id="TCP的可靠数据传输"><a href="#TCP的可靠数据传输" class="headerlink" title="TCP的可靠数据传输"></a>TCP的可靠数据传输</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>​	   众所周知，TCP是传输层中一种面向连接的、可靠的、基于字节流的通信协议，是网络通信中十分重要的桥梁。本文集中于对可靠的数据传输、流量控制以及拥塞控制三个内容的简单描述，需要读者对TCP有一定了解。</p>
<h2 id="可靠的数据传输"><a href="#可靠的数据传输" class="headerlink" title="可靠的数据传输"></a>可靠的数据传输</h2><h3 id="超时重传、快速重传、sack重传"><a href="#超时重传、快速重传、sack重传" class="headerlink" title="超时重传、快速重传、sack重传"></a>超时重传、快速重传、sack重传</h3><p>​       我们都知道，在TCP中，当发送端的数据到达接收端时，接收端会返回一个确认应答消息，表示已收到消息。但过程往往不会这么顺利，数据可能在错综复杂的网络中丢失。此时，就需要利用重传机制解决。</p>
<h4 id="超时重传："><a href="#超时重传：" class="headerlink" title="超时重传："></a>超时重传：</h4><p>​		当发送端发出一个数据包后，会启动一个定时器（**超时重传时间<code>RTO</code>**），，等待接收端确认收到这个数据包。如果没有在定时范围内收到接收端的确认报文，发送端将重发数据包。这里有两种情况：发送的数据包丢失或者确认应答丢失。</p>
<p>​		显然，<code>RTO</code>应该略大于正常情况下发送端数据发送时刻与发送端收到确认报文时刻的差值（包的往返时间<code>RTT</code>），但由于网络环境的不确定性，<code>RTT</code>在不断变化，因此<code>RTO</code>的值实际上需要很复杂的计算才能得以确定，这里不多做展开。</p>
<p>​		<strong>超时间隔加倍</strong>：每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</p>
<h4 id="快速重传："><a href="#快速重传：" class="headerlink" title="快速重传："></a>快速重传：</h4><p>超时重传也有一些问题，报文段丢失后的等待重传时间相对较长，效率较低。因此又衍生出了<strong>快速重传</strong>。</p>
<p>​		先介绍一下<strong>累计确认机制</strong>：当接收端收到比期望序号大的报文段时，会重复发送最近一次确认的报文段的确认信号，称之为冗余ACK（duplicate ACK）。如图所示，报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。</p>
<blockquote>
<p>图片丢失，还没找</p>
</blockquote>
<p>​		这样，如果在<code>RTO</code>范围内，发送端会收到连续的<strong>三个重复冗余ACK</strong>（实际上收到4个相同ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待<code>RTO</code>再重传，提高了效率。这便是<strong>快速重传机制</strong>。</p>
<p>​		这里采用三次冗余ACK的原因也很耐人寻味，我们知道TCP包是封装在IP包内的，IP包在传输时会乱序，因此TCP包到达接收端也是乱序的，这也会造成接收端发送冗余ACK给发送端。因此我们不能仅凭某一两次的冗余ACK就进行重传。选取三次是经过统计所得出的一个估计值，均衡考虑的最优结果。</p>
<h4 id="SACK重传"><a href="#SACK重传" class="headerlink" title="SACK重传"></a>SACK重传</h4><p>​		快速重传解决了超时时间较长的问题，我们还有另外一个问题：<strong>重传的时候，是重传一个，还是重传所有</strong>。传一个会导致多次触发快速重传，每个丢失的报文都需要三次冗余ACK，传所有报文时，如果后面的部分报文已经收到，会造成重复发送，导致资源浪费。因此有了**<code>SACK</code>方法**。</p>
<p>​		在 TCP 头部选项字段里加一个 <code>SACK</code> 的东西，发送端可以根据它知道哪些数据收到了，哪些数据没收到，从而只重传丢失的数据。</p>
<p>​		基于<code>SACK</code>方法，还有一种**<code>Duplicate SACK</code>**机制又称 **<code>D-SACK</code>**，它使用<code>SACK </code>方法来告诉「发送方」有哪些数据被重复接收了。</p>
<p>​		当连续发送报文时，如果一个报文因网络而延迟到达（已经触发快速重传继续传输后续报文时接收端收到之前延时的报文），回应的ack中的<code>sack</code>就会告诉发送端接收端重复接收了之前已经接收到的报文（即<strong>知道该报文延迟</strong>）。</p>
<p>​		通过这种方式，发送方还可以知道是<strong>自己发送的报文丢失</strong>还是<strong>接收方回应的ACK确认报文丢失</strong>。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>​		由于接收方和发送方的条件不同会会出现发送方数据发送过快，但接收方来不及接受，导致数据丢失的问题，基于此，<code>TCP</code>出现了<strong>流量控制</strong>机制。</p>
<p>​		TCP依靠<strong>滑动窗口</strong>进行流量控制，在TCP中有一个字段叫<code>window</code>，用来<strong>让接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。这样发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。类似于一个先进先出的队列。同时发送方也会有一个滑动窗口，表示自己发送的数据包是否已经收到了接收方的确认报文。双方通过报文的<code>window</code>字段告诉对方自己目前的窗口大小。</p>
<p>发送方的滑动窗口示意：</p>
<blockquote>
<p>图片丢失，还没找</p>
</blockquote>
<p>接收方的滑动窗口示意：</p>
<blockquote>
<p>图片丢失，还没找</p>
</blockquote>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>​		在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，导致恶性循环，因此有了<strong>拥塞控制</strong>来避免发送端的数据填满网络造成拥堵。主要通过三个算法来实现，分别是：**慢开始( slow-start )<strong>、</strong>拥塞避免( congestion avoidance )<strong>、和</strong>快恢复( fast recovery )**。。</p>
<p>​		首先我们需要一个状态变量来表示网络的拥堵状况——<strong>拥塞窗口</strong>（<code>cwnd</code>），只要网络中没有出现阻塞，窗口就会增大，网络中出现阻塞，窗口就会减小。一个传输轮次传输<code>cwnd</code>个报文。</p>
<p><strong>慢启动</strong>：</p>
<p>​		当发送端每收到1个确认ACK（一轮可能收到多个），拥塞窗口的大小就会加1。这使得拥塞窗口呈指数级增长（<code>cwnd</code>为2时，一轮收到2个ACK，<code>cwnd</code>+ 2 &#x3D; 4；<code>cwnd</code>为4时 , 一轮收到4个ACK , <code>cwnd</code> + 4 &#x3D; 8）。</p>
<p>​		当cwnd的值超过慢启动门限（ssthresh一般情况下为65535字节）时，慢启动算法停止，使用<strong>拥塞避免算法</strong>。</p>
<p><strong>拥塞避免</strong>：</p>
<p>​		每收到一个ACK报文，拥塞窗口<code>cwnd</code>增加<code>1/cwnd</code>。这使得拥塞窗口呈线性增长（<code>cwnd</code>为10时，一轮收到10个ACK，<code>cwnd</code>+ 10&#x2F;10 &#x3D; 11；<code>cwnd</code>为11时 , 一轮收到11个ACK , <code>cwnd</code> + 11&#x2F;11 &#x3D; 12）。</p>
<p>​		当<strong>超时重传拥塞</strong>发生以后，<code>ssthresh</code>设置为<code>cwnd/2</code>。<code>cwnd</code>重置为1。</p>
<p>​		当<strong>快速重传拥塞</strong>发生以后，<code>cwnd</code> &#x3D; <code>cwnd/2</code>，<code>ssthresh = cwnd</code>进入快速恢复算法，</p>
<p> <strong>快恢复算法</strong>：</p>
<p>​		进入快恢复算法时，已经发生了<strong>快速重传拥塞</strong>，<code>cwnd</code>和<code>ssthresh</code>已被更新，之后进行如下操作：</p>
<ol>
<li><p>拥塞窗口<code>cwnd = ssthresh + 3</code>（表示有三个数据包被收到）。</p>
</li>
<li><p>重传丢失的数据包。</p>
</li>
<li><p>如果收到的ACK是重复的，cwnd增加1。</p>
</li>
<li><p>如果收到新数据的ACK，把拥塞窗口设置为第1步中ssthresh的值，因为ACK已经确认了新数据，快速恢复过程可以结束，可以再次进入拥塞避免阶段。</p>
<p>下图表示了所有的拥塞算法。</p>
</li>
</ol>
<blockquote>
<p>图片丢失，还没找</p>
</blockquote>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>随笔-24/3/25</title>
    <url>/2024/05/22/RSTP%E3%80%81RTP%E3%80%81RTCP%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="RSTP、RTP、RTCP"><a href="#RSTP、RTP、RTCP" class="headerlink" title="RSTP、RTP、RTCP"></a>RSTP、RTP、RTCP</h1><h2 id="RTSP-RTP-RTCP"><a href="#RTSP-RTP-RTCP" class="headerlink" title="RTSP RTP RTCP"></a>RTSP RTP RTCP</h2><p>RTP(Real-time Transport Protocol)，即实时传输协议，是一个应用层的协议，定义了在网络上传输音频和视频的标准数据包的格式。通常说的 RTSP 包括 RTSP 协议、RTP 协议、RTCP 协议，对于这些协议的作用简单的理解如下：</p>
<ul>
<li><p>RTSP协议：负责服务器与客户端之间的<strong>请求与响应</strong></p>
<p>  一般RTSP服务器会从设备（如摄像头）中获取媒体流，并提供一个 RTSP URL 供客户端进行连接，客户端通过 RTSP URL 向服务器发起连接请求，服务器响应，两者开始交换数据，最后建立连接。</p>
</li>
<li><p>RTP协议：负责服务器与客户端之间<strong>传输媒体数据</strong></p>
<p>  RTP 的端口号通常为偶数，在连接建立后，客户端请求媒体数据，之后服务器通过将媒体流封装为 RTP 包发送给客户端。通常 RTP 的端口为偶数。可以使用 TCP 或者 UDP，一般使用 UDP 并使用 RTCP 协议保证流媒体音视频质量。仅仅是发包。</p>
</li>
<li><p>RTCP 协议：负责提供有关RTP传输质量的反馈，就是<strong>确保RTP传输的质量</strong></p>
<p>  RTCP 的端口号通肠为对应的 RTP 端口号加1。通过 RTCP 协议来对 RTP 包进行控制。</p>
</li>
<li><p>三者的关系：rtsp 并不会发送媒体数据，只是完成服务器和客户端之间的信令交互，rtp 协议负责媒体数据传输，rtcp 负责 rtp 数据包的监视和反馈。rtp 和 rtcp 并没有规定传输层的类型，可以选择 udp 和 tcp。Rtsp 的传输层则要求是基于 tcp。</p>
</li>
</ul>
<h2 id="RTSP-协议"><a href="#RTSP-协议" class="headerlink" title="RTSP 协议"></a>RTSP 协议</h2><p>嵌入式设备（如摄像头）通过服务器生成一个 RTSP URL，客户端通过这个 URL 与服务器建立连接传输媒体流，建立连接的过程用 RTSP（传输层用 TCP ）来完成信令的交互。连接建立后通过 RTP 协议来传输媒体流数据包，通过 RTCP 协议来负责 RTP 数据包的监视和反馈。两者可以选择使用 UDP 或者 TCP。</p>
<h3 id="RTSP-URL"><a href="#RTSP-URL" class="headerlink" title="RTSP URL"></a>RTSP URL</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rtsp_URL = <span class="string">&quot;rtsp://&quot;</span> host [<span class="string">&quot;:&quot;</span> port] [ abs_path ]</span><br><span class="line">host: 有效的域名或 IP 地址</span><br><span class="line">port: 端口号，缺省为 554，若为缺省可不填写，否则必须写明</span><br><span class="line">例如：rtsp://media.example.com:554/twister/audiotrack</span><br></pre></td></tr></table></figure>

<p>以海康摄像机为例，其 RTSP URL 格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rtsp://[username]:[password]@[ip]:[port]/[channel]/[subtype]/av_stream</span><br><span class="line">例如：</span><br><span class="line">rtsp://admin:12345@192.168.1.67:554/h264/ch1/main/av_stream</span><br><span class="line">rtsp://admin:12345@192.168.1.67/mpeg4/ch1/sub/av_stream</span><br></pre></td></tr></table></figure>

<h3 id="RTSP-报文"><a href="#RTSP-报文" class="headerlink" title="RTSP 报文"></a>RTSP 报文</h3><p>RTSP 是一种基于文本的协议，用 CRLF (回车换行) 作为每一行的结束符，其好处是，在使用过程中可以方便地增加自定义参数，也方便抓包分析。从消息传送方向上来分，RTSP 的报文有两类：请求报文和响应报文。请求报文是指从客户端向服务器发送的请求 (也有少量从服务器向客户端发送的请求)，响应报文是指从服务器到客户端的回应。</p>
<p>RTSP 请求报文的常用方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>方向</th>
<th>对象</th>
<th>是否必要</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>DESCRIBE</td>
<td>C-&gt;S</td>
<td>P, S</td>
<td>推荐</td>
<td>得到会话描述信息</td>
</tr>
<tr>
<td>ANNOUNCE</td>
<td>C-&gt;S, S-&gt;C</td>
<td>P, S</td>
<td>可选</td>
<td></td>
</tr>
<tr>
<td>GET_PARAMETER</td>
<td>C-&gt;S, S-&gt;C</td>
<td>P, S</td>
<td>可选</td>
<td></td>
</tr>
<tr>
<td>OPTIONS</td>
<td>C-&gt;S, S-&gt;C</td>
<td>P, S</td>
<td>必须 (S-&gt;C: 可选)</td>
<td>获得服务器提供的可用方法</td>
</tr>
<tr>
<td>PAUSE</td>
<td>C-&gt;S</td>
<td>P, S</td>
<td>推荐</td>
<td>客户端发起暂停播放请求</td>
</tr>
<tr>
<td>PLAY</td>
<td>C-&gt;S</td>
<td>P, S</td>
<td>必须</td>
<td>客户端发起播放请求</td>
</tr>
<tr>
<td>RECORD</td>
<td>C-&gt;S</td>
<td>P, S</td>
<td>可选</td>
<td></td>
</tr>
<tr>
<td>REDIRECT</td>
<td>S-&gt;C</td>
<td>P, S</td>
<td>可选</td>
<td></td>
</tr>
<tr>
<td>SETUP</td>
<td>C-&gt;S</td>
<td>S</td>
<td>必须</td>
<td>客户端请求建立会话</td>
</tr>
<tr>
<td>SET_PARAMETER</td>
<td>C-&gt;S, S-&gt;C</td>
<td>P, S</td>
<td>可选</td>
<td></td>
</tr>
<tr>
<td>TEARDOWN</td>
<td>C-&gt;S</td>
<td>P, S</td>
<td>必须</td>
<td>客户端发起关闭会话</td>
</tr>
</tbody></table>
<p>通过 <code>VLC</code> 播放 <code>RTSP</code> 网络流，经抓包得以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OPTIONS rtsp://192.168.199.152:554/live/test RTSP/1.0</span><br><span class="line">CSeq: 2</span><br><span class="line">User-Agent: LibVLC/3.0.8 (LIVE555 Streaming Media v2016.11.28)</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">CSeq: 2</span><br><span class="line">Date: Mon, Jul 27 2020 15:32:38 GMT</span><br><span class="line">Public: OPTIONS, DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE, ANNOUNCE, RECORD, SET_PARAMETER, GET_PARAMETER</span><br><span class="line">Server: ZLMediaKit-5.0(build <span class="keyword">in</span> Jul 12 2020 14:02:13)</span><br><span class="line"></span><br><span class="line">DESCRIBE rtsp://192.168.199.152:554/live/test RTSP/1.0</span><br><span class="line">CSeq: 3</span><br><span class="line">User-Agent: LibVLC/3.0.8 (LIVE555 Streaming Media v2016.11.28)</span><br><span class="line">Accept: application/sdp</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Content-Base: rtsp://192.168.199.152:554/live/test/</span><br><span class="line">Content-Length: 544</span><br><span class="line">Content-Type: application/sdp</span><br><span class="line">CSeq: 3</span><br><span class="line">Date: Mon, Jul 27 2020 15:32:38 GMT</span><br><span class="line">Server: ZLMediaKit-5.0(build <span class="keyword">in</span> Jul 12 2020 14:02:13)</span><br><span class="line">Session: hEu0JzMKcfK2</span><br><span class="line">x-Accept-Dynamic-Rate: 1</span><br><span class="line">x-Accept-Retransmit: our-retransmit</span><br><span class="line"></span><br><span class="line">v=0</span><br><span class="line">o=- 0 0 IN IP4 127.0.0.1</span><br><span class="line">c=IN IP4 127.0.0.1</span><br><span class="line">t=0 0</span><br><span class="line">s=Streamed by ZLMediaKit-5.0(build <span class="keyword">in</span> Jul 12 2020 14:01:57)</span><br><span class="line">a=tool:libavformat 58.29.100</span><br><span class="line">m=video 0 RTP/AVP 96</span><br><span class="line">a=fmtp:96 packetization-mode=1; sprop-parameter-sets=Z2QAHqzZQNg95f/wFAAUEQAAAwABAAADADIPFi2W,aOvjyyLA; profile-level-id=64001E</span><br><span class="line">a=rtpmap:96 H264/90000</span><br><span class="line">a=control:streamid=0</span><br><span class="line">m=audio 0 RTP/AVP 97</span><br><span class="line">b=AS:128</span><br><span class="line">a=fmtp:97 profile-level-id=1;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3; config=121056E500</span><br><span class="line">a=rtpmap:97 MPEG4-GENERIC/44100/2</span><br><span class="line">a=control:streamid=1</span><br><span class="line">SETUP rtsp://192.168.199.152:554/live/test/streamid=0 RTSP/1.0</span><br><span class="line">CSeq: 4</span><br><span class="line">User-Agent: LibVLC/3.0.8 (LIVE555 Streaming Media v2016.11.28)</span><br><span class="line">Transport: RTP/AVP;unicast;client_port=60836-60837</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">CSeq: 4</span><br><span class="line">Date: Mon, Jul 27 2020 15:32:38 GMT</span><br><span class="line">Server: ZLMediaKit-5.0(build <span class="keyword">in</span> Jul 12 2020 14:02:13)</span><br><span class="line">Session: hEu0JzMKcfK2</span><br><span class="line">Transport: RTP/AVP/UDP;unicast;client_port=60836-60837;server_port=41070-41071;ssrc=50E36E3B</span><br><span class="line"></span><br><span class="line">SETUP rtsp://192.168.199.152:554/live/test/streamid=1 RTSP/1.0</span><br><span class="line">CSeq: 5</span><br><span class="line">User-Agent: LibVLC/3.0.8 (LIVE555 Streaming Media v2016.11.28)</span><br><span class="line">Transport: RTP/AVP;unicast;client_port=60838-60839</span><br><span class="line">Session: hEu0JzMKcfK2</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">CSeq: 5</span><br><span class="line">Date: Mon, Jul 27 2020 15:32:38 GMT</span><br><span class="line">Server: ZLMediaKit-5.0(build <span class="keyword">in</span> Jul 12 2020 14:02:13)</span><br><span class="line">Session: hEu0JzMKcfK2</span><br><span class="line">Transport: RTP/AVP/UDP;unicast;client_port=60838-60839;server_port=58452-58453;ssrc=3463B21F</span><br><span class="line"></span><br><span class="line">PLAY rtsp://192.168.199.152:554/live/test/ RTSP/1.0</span><br><span class="line">CSeq: 6</span><br><span class="line">User-Agent: LibVLC/3.0.8 (LIVE555 Streaming Media v2016.11.28)</span><br><span class="line">Session: hEu0JzMKcfK2</span><br><span class="line">Range: npt=0.000-</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">CSeq: 6</span><br><span class="line">Date: Mon, Jul 27 2020 15:32:38 GMT</span><br><span class="line">Range: npt=42535.41</span><br><span class="line">RTP-Info: url=rtsp://192.168.199.152:554/live/test/streamid=0;<span class="built_in">seq</span>=3889;rtptime=-466780396,url=rtsp://192.168.199.152:554/live/test/streamid=1;<span class="built_in">seq</span>=1155;rtptime=-179511072</span><br><span class="line">Server: ZLMediaKit-5.0(build <span class="keyword">in</span> Jul 12 2020 14:02:13)</span><br><span class="line">Session: hEu0JzMKcfK2</span><br><span class="line"></span><br><span class="line">TEARDOWN rtsp://192.168.199.152:554/live/test/ RTSP/1.0</span><br><span class="line">CSeq: 7</span><br><span class="line">User-Agent: LibVLC/3.0.8 (LIVE555 Streaming Media v2016.11.28)</span><br><span class="line">Session: hEu0JzMKcfK2</span><br><span class="line"></span><br><span class="line">RTSP/1.0 200 OK</span><br><span class="line">CSeq: 7</span><br><span class="line">Date: Mon, Jul 27 2020 15:32:41 GMT</span><br><span class="line">Server: ZLMediaKit-5.0(build <span class="keyword">in</span> Jul 12 2020 14:02:13)</span><br><span class="line">Session: hEu0JzMKcfK2</span><br></pre></td></tr></table></figure>

<p>从上述抓包中看出，VLC 在播放 RTSP 网络流时，客户端与服务端经过了 6 次交互：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方向</th>
<th>方法</th>
<th>消息内容</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>C-&gt;S</td>
<td>OPTIONS</td>
<td>Client 询问 Server 有哪些方法可用</td>
</tr>
<tr>
<td>1</td>
<td>S-&gt;C</td>
<td>OPTIONS</td>
<td>Server 回应所有可用的方法</td>
</tr>
<tr>
<td>2</td>
<td>C-&gt;S</td>
<td>DESCRIBE</td>
<td>Client 请求得到 Server 提供的媒体初始化描述信息</td>
</tr>
<tr>
<td>2</td>
<td>S-&gt;C</td>
<td>DESCRIBE</td>
<td>Server 回应媒体初始化信息，主要是 SDP （会话描述协议）</td>
</tr>
<tr>
<td>3</td>
<td>C-&gt;S</td>
<td>SETUP</td>
<td>设置视频会话属性以及传输模式，请求建立会话</td>
</tr>
<tr>
<td>3</td>
<td>S-&gt;C</td>
<td>SETUP</td>
<td>Server 建立会话，返回会话标识以及会话相关信息</td>
</tr>
<tr>
<td>4</td>
<td>C-&gt;S</td>
<td>SETUP</td>
<td>设置音频会话属性以及传输模式，请求建立会话</td>
</tr>
<tr>
<td>4</td>
<td>S-&gt;C</td>
<td>SETUP</td>
<td>Server 建立会话，返回会话标识以及会话相关信息</td>
</tr>
<tr>
<td>5</td>
<td>C-&gt;S</td>
<td>PLAY</td>
<td>Client 请求播放</td>
</tr>
<tr>
<td>5</td>
<td>S-&gt;C</td>
<td>PLAY</td>
<td>Server 回应播放请求</td>
</tr>
<tr>
<td>6</td>
<td>C-&gt;S</td>
<td>TEARDOWN</td>
<td>Client 请求关闭会话</td>
</tr>
<tr>
<td>6</td>
<td>S-&gt;C</td>
<td>TEARDOWN</td>
<td>Server 回应关闭会话请求</td>
</tr>
</tbody></table>
<p>下面我们一步一步了解 RTSP 会话建立流程：</p>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>OPTIONS 请求可以在任何时间被发出，而且不会影响到 Server 的状态，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C-&gt;S:  OPTIONS * RTSP/1.0</span><br><span class="line">       CSeq: 1</span><br><span class="line">       Require: implicit-play</span><br><span class="line">       Proxy-Require: gzipped-messages</span><br><span class="line"></span><br><span class="line">S-&gt;C:  RTSP/1.0 200 OK</span><br><span class="line">       CSeq: 1</span><br><span class="line">       Public: DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE</span><br></pre></td></tr></table></figure>

<h3 id="DESCRIBE"><a href="#DESCRIBE" class="headerlink" title="DESCRIBE"></a>DESCRIBE</h3><p>客户端向服务器请求媒体资源描述，服务器端通过 SDP (Session Description Protocol) 格式回应客户端的请求。资源描述中会列出所请求媒体的媒体流及其相关信息，典型情况下，音频和视频分别作为一个媒体流传输。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C-&gt;S: DESCRIBE rtsp://server.example.com/fizzle/foo RTSP/1.0</span><br><span class="line">      CSeq: 312</span><br><span class="line">      Accept: application/sdp, application/rtsl, application/mheg</span><br><span class="line"></span><br><span class="line">S-&gt;C: RTSP/1.0 200 OK</span><br><span class="line">      CSeq: 312</span><br><span class="line">      Date: 23 Jan 1997 15:35:06 GMT</span><br><span class="line">      Content-Type: application/sdp</span><br><span class="line">      Content-Length: 376</span><br><span class="line"></span><br><span class="line">      v=0</span><br><span class="line">      o=mhandley 2890844526 2890842807 IN IP4 126.16.64.4</span><br><span class="line">      s=SDP Seminar</span><br><span class="line">      i=A Seminar on the session description protocol</span><br><span class="line">      u=http://www.cs.ucl.ac.uk/staff/M.Handley/sdp.03.ps</span><br><span class="line">      e=mjh@isi.edu (Mark Handley)</span><br><span class="line">      c=IN IP4 224.2.17.12/127</span><br><span class="line">      t=2873397496 2873404696</span><br><span class="line">      a=recvonly</span><br><span class="line">      m=audio 3456 RTP/AVP 0</span><br><span class="line">      m=video 2232 RTP/AVP 31</span><br><span class="line">      m=whiteboard 32416 UDP WB</span><br><span class="line">      a=orient:portrait</span><br></pre></td></tr></table></figure>

<blockquote>
<p>媒体流及其相关信息由 SDP (Session Description Protocol) 格式携带，关于 SDP 的详细说明，参见拓展阅读 5</p>
</blockquote>
<h3 id="SETUP"><a href="#SETUP" class="headerlink" title="SETUP"></a>SETUP</h3><p>SETUP 请求确定了具体的媒体流如何传输，该请求必须在 PLAY 请求之前发送。SETUP 请求包含媒体流的 URL 和客户端用于接收 RTP 数据 (audio or video) 的端口以及接收 RTCP 数据 (meta information) 的端口。服务器端的回复通常包含客户端请求参数的确认，并会补充缺失的部分，比如服务器选择的发送端口。每一个媒体流在发送 PLAY 请求之前，都要首先通过 SETUP 请求来进行相应的配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C-&gt;S: SETUP rtsp://example.com/foo/bar/baz.rm RTSP/1.0</span><br><span class="line">      CSeq: 302</span><br><span class="line">      Transport: RTP/AVP;unicast;client_port=4588-4589</span><br><span class="line"></span><br><span class="line">S-&gt;C: RTSP/1.0 200 OK</span><br><span class="line">      CSeq: 302</span><br><span class="line">      Date: 23 Jan 1997 15:35:06 GMT</span><br><span class="line">      Session: 47112344</span><br><span class="line">      Transport: RTP/AVP;unicast;client_port=4588-4589;server_port=6256-6257</span><br></pre></td></tr></table></figure>

<h3 id="PLAY"><a href="#PLAY" class="headerlink" title="PLAY"></a>PLAY</h3><p>客户端通过 PLAY 请求来播放一个或全部媒体流，PLAY 请求可以发送一次或多次，发送一次时，URL 为包含所有媒体流的地址，发送多次时，每一次请求携带的 URL 只包含一个相应的媒体流。PLAY 请求中可指定播放的 range，若未指定，则从媒体流的开始播放到结束，如果媒体流在播放过程中被暂停，则可在暂停处重新启动流的播放。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C-&gt;S: PLAY rtsp://example.com/media.mp4 RTSP/1.0</span><br><span class="line">      CSeq: 4</span><br><span class="line">      Range: npt=5-20</span><br><span class="line">      Session: 12345678</span><br><span class="line"></span><br><span class="line">S-&gt;C: RTSP/1.0 200 OK</span><br><span class="line">      CSeq: 4</span><br><span class="line">      Session: 12345678</span><br><span class="line">      RTP-Info: url=rtsp://example.com/media.mp4/streamid=0;<span class="built_in">seq</span>=9810092;rtptime=3450012</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Server 处理 client 发来的 PLAY 请求后，就会开始向 client 发送媒体数据，一般采用 RTP 协议进行发送，关于 RTP 协议的相关说明，参见拓展阅读 6</p>
</blockquote>
<h3 id="TEARDOWN"><a href="#TEARDOWN" class="headerlink" title="TEARDOWN"></a>TEARDOWN</h3><p>结束会话请求，该请求会停止所有媒体流，并释放服务器上的相关会话数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C-&gt;S: TEARDOWN rtsp://example.com/media.mp4 RTSP/1.0</span><br><span class="line">      CSeq: 8</span><br><span class="line">      Session: 12345678</span><br><span class="line"></span><br><span class="line">S-&gt;C: RTSP/1.0 200 OK</span><br><span class="line">      CSeq: 8</span><br></pre></td></tr></table></figure>

<h2 id="RTP-协议"><a href="#RTP-协议" class="headerlink" title="RTP 协议"></a>RTP 协议</h2><p>在 RTSP 的流媒体服务器中音视频的传输通过 RTP 封装将音视频帧封装为若干个 RTP 包。每个 RTP 包由 RTP Header 和音视频载荷(Payload)组成。RTP Header包含固定头和扩展头，RTP 固定头通常占 12 字节，扩展头大小可变通常不用。</p>
<h3 id="RTP-Header"><a href="#RTP-Header" class="headerlink" title="RTP Header"></a>RTP Header</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|V=2|P|X|  CC   |M|     PT      |       sequence number         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                           timestamp                           |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           synchronization <span class="built_in">source</span> (SSRC) identifier            |</span><br><span class="line">+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+</span><br><span class="line">|            contributing <span class="built_in">source</span> (CSRC) identifiers             |</span><br><span class="line">|                             ....                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>这 12 个字节组成的 RTP 固定头出现在每个 RTP 数据包中，这些字段具有的含义如下：</p>
<ul>
<li>**版本 (V)**：2 位，该字段标识 RTP 的版本。RFC3550 定义的版本规范为 2.</li>
<li>**填充 (P)**：1 位，如果设置了填充位，则数据包包含一个或多个末尾的其他填充字节不属于有效载荷。</li>
<li>**扩展名 (X)**：1 位，如果扩展位被置位，则固定报头必须后跟一个扩展头部。</li>
<li>**CSRC 计数 (CC)**：4 位，CSRC 计数包含随后的 CSRC 标识符的数量固定头。</li>
<li>**标记 (M)**：1 位，由配置文件定义，它允许诸如框架边界之类的重要事件发生在数据包流中被标记。</li>
</ul>
<blockquote>
<p>**标记 (M)**：1 位，标识此 RTP 包携带了一组 NAL 数据的最后一个 NAL Unit。（RFC 6184）</p>
</blockquote>
<ul>
<li>**有效载荷类型 (PT)**：7 位，该字段标识 RTP 有效负载的格式并确定由应用程序对其进行解释。一个配置文件可以指定一个负载类型代码到负载格式的默认静态映射。</li>
<li>**序列号 (sequence number)**：16 位，每个 RTP 数据包的序列号加 1 发送，接收方可以使用它来检测丢包并恢复报文序列，序号的初始值应该是随机的。</li>
<li>**时间戳 (timestamp)**：32 位，时间戳记录了该包中数据的第一个字节的采样时刻。在一次会话开始时，时间戳初始化成一个初始值。即使在没有信号发送时，时间戳的数值也要随时间而不断地增加（时间在流逝嘛）。时间戳是去除抖动和实现同步不可缺少的。</li>
<li>**同步源标识符 (SSRC)**：32 位，同步源就是指 RTP 包流的来源。在同一个 RTP 会话中不能有两个相同的 SSRC 值。该标识符是随机选取的 RFC1889 推荐了 MD5 随机算法。</li>
<li>**贡献源列表 (CSRC List)**：0～15 项，每项 32 位，用来标志对一个 RTP 混合器产生的新包有贡献的所有 RTP 包的源。由混合器将这些有贡献的 SSRC 标识符插入表中。SSRC 标识符都被列出来，以便接收端能正确指出交谈双方的身份。</li>
</ul>
<h3 id="RTP-载荷"><a href="#RTP-载荷" class="headerlink" title="RTP 载荷"></a>RTP 载荷</h3><p>在 RTSP 等实时流传输中常见的编码格式是 H264&#x2F;H265 以及音频 AAC。不同的编码格式在 RTP 包中的封装过程有所不同，比如 H264 和 H265 需要去掉码流中的启始码 (0x000001)，音频 AAC 需要去掉 AAC 的头部字段 ADTS 数据，在 H264 封装 RTP 包过程需要去掉1个字节的 NAL Unit 头，在 H265 封装过程需要去掉2个字节的 NAL Unit 头。</p>
<ul>
<li>[1] <a href="https://github.com/xia-chu/ZLMediaKit">ZLMediaKit</a> （作为 RTSP Server）</li>
<li>[2] <a href="https://www.videolan.org/">VLC</a> （作为 RTSP Client）</li>
<li>[3] <a href="https://www.cnblogs.com/linhaostudy/p/11140823.html">yooooooo 的博客园：《网络流媒体协议之 ——RTSP 协议》</a></li>
<li>[4] <a href="https://www.rfc-editor.org/rfc/rfc2326.txt">RFC 2326: Real Time Streaming Protocol (RTSP)</a></li>
<li>[5] <a href="https://www.rfc-editor.org/rfc/rfc3551.txt">RFC 3551: RTP Profile for Audio and Video Conferences with Minimal Control</a></li>
<li>[6] <a href="https://www.rfc-editor.org/rfc/rfc6184.txt">RFC 6184: RTP Payload Format for H.264 Video</a></li>
<li>[7] <a href="https://www.rfc-editor.org/rfc/rfc3550.txt">RFC 3550: RTP: A Transport Protocol for Real-Time Applications</a></li>
<li>[8] <a href="https://hezhaojiang.github.io/post/2020/cf84018a/">流媒体传输 - RTSP 协议</a></li>
</ul>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>Windows 和 Linux文件传输和管理</title>
    <url>/2023/06/04/Windows%20%E5%92%8C%20Linux%20%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%92%8C%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Windows-和-Linux文件传输和管理"><a href="#Windows-和-Linux文件传输和管理" class="headerlink" title="Windows 和 Linux文件传输和管理"></a>Windows 和 Linux文件传输和管理</h1><h2 id="局域网共享方案"><a href="#局域网共享方案" class="headerlink" title="局域网共享方案"></a>局域网共享方案</h2><h3 id="Samba-文件共享（全协议兼容）"><a href="#Samba-文件共享（全协议兼容）" class="headerlink" title="Samba 文件共享（全协议兼容）"></a>Samba 文件共享（全协议兼容）</h3><p><strong>适用场景</strong>：需要 Windows 原生支持且长期稳定的共享目录<br><strong>优势</strong>：读写性能好，支持权限管理<br><strong>劣势</strong>：需配置服务端</p>
<h4 id="配置流程（以-Arch-Linux-为例）"><a href="#配置流程（以-Arch-Linux-为例）" class="headerlink" title="配置流程（以 Arch Linux 为例）"></a>配置流程（以 Arch Linux 为例）</h4><ol>
<li><p>安装必要组件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S samba</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建共享目录并配置权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/public_files</span><br><span class="line"><span class="built_in">chmod</span> 1777 ~/public_files  <span class="comment"># 粘滞位防误删</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>/etc/samba/smb.conf</code>：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Public]</span></span><br><span class="line"><span class="attr">path</span> = /home/yourname/public_files</span><br><span class="line">valid <span class="attr">users</span> = yourname</span><br><span class="line">read <span class="attr">only</span> = <span class="literal">No</span></span><br><span class="line">create <span class="attr">mask</span> = <span class="number">0664</span></span><br><span class="line">directory <span class="attr">mask</span> = <span class="number">0775</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置访问密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> smbpasswd -a yourname</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动并设置开机自启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now smb nmb</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Windows-访问方式"><a href="#Windows-访问方式" class="headerlink" title="Windows 访问方式"></a>Windows 访问方式</h4><p>文件资源管理器地址栏输入 <code>\\Linux_IP\Public</code>，认证后即可读写。建议右键映射为网络驱动器方便长期使用。</p>
<h3 id="1-2-SSH-文件传输（加密通道）"><a href="#1-2-SSH-文件传输（加密通道）" class="headerlink" title="1.2 SSH 文件传输（加密通道）"></a>1.2 SSH 文件传输（加密通道）</h3><p><strong>适用场景</strong>：临时文件传输或远程管理<br><strong>优势</strong>：无需额外服务，天然加密<br><strong>劣势</strong>：大文件传输效率较低</p>
<h4 id="常用命令工具"><a href="#常用命令工具" class="headerlink" title="常用命令工具"></a>常用命令工具</h4><ol>
<li><p><strong>SCP 基础传输</strong>：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Win → Linux</span></span><br><span class="line">scp .\report.pdf user@<span class="number">192.168</span>.<span class="number">1.10</span>:~/Documents/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux → Win</span></span><br><span class="line">scp user@server:/var/log/app.log .\Downloads\</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Rsync 增量同步</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -avzP ./project/ user@host:~/backup/  <span class="comment"># 本地到远程</span></span><br><span class="line">rsync -avzP user@host:~/data/ ./local_copy/ <span class="comment"># 远程到本地</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SFTP 交互式传输</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sftp user@host</span><br><span class="line">sftp&gt; put local_file.txt</span><br><span class="line">sftp&gt; get remote_file.zip</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="互联网传输方案"><a href="#互联网传输方案" class="headerlink" title="互联网传输方案"></a>互联网传输方案</h2><h3 id="云存储同步"><a href="#云存储同步" class="headerlink" title="云存储同步"></a>云存储同步</h3><p><strong>推荐工具</strong>：</p>
<ul>
<li>Syncthing（P2P 同步）</li>
<li>Rclone（支持 40+ 云存储）</li>
<li>Nextcloud（自建私有云）</li>
</ul>
<h4 id="Syncthing-快速部署"><a href="#Syncthing-快速部署" class="headerlink" title="Syncthing 快速部署"></a>Syncthing 快速部署</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S syncthing</span><br><span class="line">systemctl --user <span class="built_in">enable</span> --now syncthing</span><br></pre></td></tr></table></figure>
<p>访问 <code>http://localhost:8384</code> 完成设备配对，设置同步文件夹。</p>
<hr>
<h3 id="临时文件快传"><a href="#临时文件快传" class="headerlink" title="临时文件快传"></a>临时文件快传</h3><p><strong>场景</strong>：快速分享单个文件<br><strong>工具选择</strong>：</p>
<ul>
<li>Python 临时 HTTP 服务：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m http.server 8000  <span class="comment"># Linux 开启服务</span></span><br><span class="line"><span class="comment"># Windows 访问 http://Linux_IP:8000 下载</span></span><br></pre></td></tr></table></figure></li>
<li>MagicWormhole（端到端加密传输）：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wormhole send file.zip  <span class="comment"># 发送端</span></span><br><span class="line">wormhole receive CODE   <span class="comment"># 接收端</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="混合开发注意事项"><a href="#混合开发注意事项" class="headerlink" title="混合开发注意事项"></a>混合开发注意事项</h2><h3 id="文件权限保留"><a href="#文件权限保留" class="headerlink" title="文件权限保留"></a>文件权限保留</h3><p>Windows 文件系统无 Linux 权限属性，通过以下方式保持一致性：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载时指定权限</span></span><br><span class="line">mount -t cifs //IP/share /mnt -o uid=1000,gid=1000,file_mode=0644</span><br></pre></td></tr></table></figure>

<h3 id="换行符转换"><a href="#换行符转换" class="headerlink" title="换行符转换"></a>换行符转换</h3><p>防止脚本文件换行符混乱：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局禁用 git 自动转换</span></span><br><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="磁盘挂载配置"><a href="#磁盘挂载配置" class="headerlink" title="磁盘挂载配置"></a>磁盘挂载配置</h3><p>自动挂载 NTFS 数据盘：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> blkid  <span class="comment"># 查看UUID</span></span><br><span class="line"><span class="built_in">sudo</span> nano /etc/fstab</span><br><span class="line"><span class="comment"># 添加条目：</span></span><br><span class="line">UUID=XXXX /mnt/win_disk ntfs-3g defaults,uid=1000,gid=1000 0 0</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="图形化工具推荐"><a href="#图形化工具推荐" class="headerlink" title="图形化工具推荐"></a>图形化工具推荐</h2><table>
<thead>
<tr>
<th>工具名称</th>
<th>平台支持</th>
<th>核心功能</th>
</tr>
</thead>
<tbody><tr>
<td>WinSCP</td>
<td>Windows</td>
<td>SFTP&#x2F;FTP&#x2F;SCP 图形客户端</td>
</tr>
<tr>
<td>FileZilla</td>
<td>跨平台</td>
<td>FTP&#x2F;SFTP 专业客户端</td>
</tr>
<tr>
<td>FreeFileSync</td>
<td>跨平台</td>
<td>双向文件同步</td>
</tr>
<tr>
<td>RaiDrive</td>
<td>Windows</td>
<td>云端存储挂载为本地磁盘</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>将 Python 程序打包为可执行文件（Windows &amp; Linux）</title>
    <url>/2025/01/06/%E5%B0%86%20Python%20%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="将-Python-程序打包为可执行文件（Windows-Linux）"><a href="#将-Python-程序打包为可执行文件（Windows-Linux）" class="headerlink" title="将 Python 程序打包为可执行文件（Windows &amp; Linux）"></a>将 Python 程序打包为可执行文件（Windows &amp; Linux）</h1><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>在开始之前，请根据目标平台准备开发环境：</p>
<p><strong>所有平台必备</strong></p>
<ul>
<li>Python 3.x</li>
<li>pip（Python包管理工具）</li>
</ul>
<p><strong>Windows 额外要求</strong></p>
<ul>
<li>建议使用 PowerShell 或 CMD 命令行工具</li>
</ul>
<p><strong>Linux 额外要求</strong></p>
<ul>
<li>需要安装基础开发工具包（以 Arch Linux 为例）：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S base-devel zlib</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="安装-PyInstaller"><a href="#安装-PyInstaller" class="headerlink" title="安装 PyInstaller"></a>安装 PyInstaller</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通用安装命令</span></span><br><span class="line">pip install pyinstaller</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux 系统建议使用虚拟环境</span></span><br><span class="line">python -m venv venv</span><br><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure>

<h2 id="打包程序"><a href="#打包程序" class="headerlink" title="打包程序"></a>打包程序</h2><h3 id="Windows-系统"><a href="#Windows-系统" class="headerlink" title="Windows 系统"></a>Windows 系统</h3><ol>
<li><p><strong>进入脚本目录</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\path\to\your\script</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生成可执行文件</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pyinstaller <span class="literal">--onefile</span> <span class="literal">--windowed</span> your_script.py</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取生成文件</strong></p>
<ul>
<li>在 <code>dist/</code> 目录中找到 <code>.exe</code> 文件</li>
<li>注意：首次打包可能较慢（5-30秒）</li>
</ul>
</li>
</ol>
<h3 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h3><ol>
<li><p><strong>进入脚本目录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/your/script</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生成可执行文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile your_script.py</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置执行权限</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x dist/your_script</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./dist/your_script</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="跨平台注意事项"><a href="#跨平台注意事项" class="headerlink" title="跨平台注意事项"></a>跨平台注意事项</h2><h3 id="部分参数"><a href="#部分参数" class="headerlink" title="部分参数"></a>部分参数</h3><ul>
<li><code>--onefile</code>：生成单文件可执行程序</li>
<li><code>--windowed</code>（仅Windows）：隐藏控制台窗口</li>
<li><code>--icon</code>：自定义程序图标（Windows使用.ico，Linux建议.svg或.png）</li>
<li><code>--add-data</code>：添加额外资源文件（例：<code>--add-data &#39;assets/*:assets&#39;</code>）</li>
</ul>
<h3 id="路径处理技巧"><a href="#路径处理技巧" class="headerlink" title="路径处理技巧"></a>路径处理技巧</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在代码中使用资源路径兼容写法</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">resource_path</span>(<span class="params">relative_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 获取资源的绝对路径&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(sys, <span class="string">&#x27;_MEIPASS&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span> os.path.join(sys._MEIPASS, relative_path)</span><br><span class="line">    <span class="keyword">return</span> os.path.join(os.path.abspath(<span class="string">&quot;.&quot;</span>), relative_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">icon_path = resource_path(<span class="string">&#x27;app_icon.ico&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="高级打包选项"><a href="#高级打包选项" class="headerlink" title="高级打包选项"></a>高级打包选项</h2><h3 id="压缩优化"><a href="#压缩优化" class="headerlink" title="压缩优化"></a>压缩优化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用UPX压缩（需提前安装）</span></span><br><span class="line"><span class="comment"># Windows：下载 upx.exe 添加到PATH</span></span><br><span class="line"><span class="comment"># Arch Linux：sudo pacman -S upx</span></span><br><span class="line">pyinstaller --onefile --upx-dir=/path/to/upx your_script.py</span><br></pre></td></tr></table></figure>

<h3 id="排除不需要的模块"><a href="#排除不需要的模块" class="headerlink" title="排除不需要的模块"></a>排除不需要的模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --exclude-module matplotlib your_script.py</span><br></pre></td></tr></table></figure>

<h3 id="指定Python解释器"><a href="#指定Python解释器" class="headerlink" title="指定Python解释器"></a>指定Python解释器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确保使用正确的Python版本</span></span><br><span class="line">pyinstaller --python /usr/bin/python3.8 your_script.py</span><br></pre></td></tr></table></figure>

<h2 id="测试与分发"><a href="#测试与分发" class="headerlink" title="测试与分发"></a>测试与分发</h2><h3 id="Windows-测试"><a href="#Windows-测试" class="headerlink" title="Windows 测试"></a>Windows 测试</h3><ul>
<li>直接双击.exe文件运行</li>
<li>若出现闪退，可在命令行中运行查看错误信息</li>
</ul>
<h3 id="Linux-测试"><a href="#Linux-测试" class="headerlink" title="Linux 测试"></a>Linux 测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查依赖库</span></span><br><span class="line">ldd dist/your_script</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看控制台输出</span></span><br><span class="line">./dist/your_script --debug</span><br></pre></td></tr></table></figure>

<h3 id="通用验证方法"><a href="#通用验证方法" class="headerlink" title="通用验证方法"></a>通用验证方法</h3><ol>
<li>在虚拟机&#x2F;干净系统中测试</li>
<li>检查临时解压目录（Windows：<code>%TEMP%\_MEIxxxxx</code>，Linux：<code>/tmp/_MEIxxxxx</code>）</li>
<li>使用<code>--log-level DEBUG</code>参数查看详细打包过程</li>
</ol>
<h2 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h2><p><strong>Q：程序找不到数据文件</strong></p>
<ul>
<li>确保使用<code>--add-data</code>添加资源文件</li>
<li>在代码中使用前文提到的<code>resource_path()</code>方法</li>
</ul>
<p><strong>Q：出现 ModuleNotFoundError</strong></p>
<ul>
<li>使用<code>--hidden-import</code>指定隐藏依赖<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --hidden-import sklearn.utils._weight_vector your_script.py</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Q：Linux打包后文件体积过大</strong></p>
<ul>
<li>使用UPX压缩</li>
<li>排除不需要的库（<code>--exclude-module</code>）</li>
<li>使用 Alpine Linux 进行最小化打包</li>
</ul>
<p><strong>Q：图形界面程序无法启动</strong></p>
<ul>
<li>Windows：安装VC++运行库</li>
<li>Linux：安装GTK&#x2F;Qt依赖<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于PyQt5程序</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S qt5-base</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="版本兼容性"><a href="#版本兼容性" class="headerlink" title="版本兼容性"></a>版本兼容性</h2><table>
<thead>
<tr>
<th>Python 版本</th>
<th>PyInstaller 推荐版本</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>3.6-3.7</td>
<td>4.x</td>
<td>停止维护版本</td>
</tr>
<tr>
<td>3.8-3.10</td>
<td>5.x</td>
<td>主流支持版本</td>
</tr>
<tr>
<td>3.11+</td>
<td>6.x</td>
<td>需要最新PyInstaller</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>随笔-24/3/25</title>
    <url>/2024/03/25/%E9%9A%8F%E7%AC%94_24-3-25/</url>
    <content><![CDATA[<h1 id="随笔-24-3-25"><a href="#随笔-24-3-25" class="headerlink" title="随笔-24&#x2F;3&#x2F;25"></a>随笔-24&#x2F;3&#x2F;25</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>3&#x2F;25 晚上整理博客，QQ上看到一段话，还不错，正好博客弄好了，”关于“这部分还不知道放些什么东西。随笔这些写上面感觉还不错，于是开始在博客上写随笔。但是敲来敲去，总觉得哪里有些怪，不自然。看着屏幕上写的东西，总感觉有那么一丝丝奇怪。</p>
<p><strong>逃避</strong>—差不多就是这样。选择困难症又开始了，博客上要不要”记录生活”，写写随笔，还是只写技术，写随笔写什么，怎么写。</p>
<h2 id="高中旧物"><a href="#高中旧物" class="headerlink" title="高中旧物"></a>高中旧物</h2><p>初中高中的时候也有写过一些记录当时所思所想的文字，尤其是高三压力大那时候，晚上猫在被窝打灯写，虽然大部分是和 ys 有关，但是也包含了自己当时的所思所想，也给了自己不少坚持下去的动力。</p>
<p>但毕业以后，人生开始踏入新的阶段，整理之前的旧物时又开始选择。那时的自己喜欢简约，什么东西都整整齐齐，有条理，同时也不想无关的东西来占用自己的空间和时间。”断舍离“践行的很好，包括现在也是。</p>
<p>“长时间用不到的东西扔掉就好了，即使未来某一天想用到它，也就是那么很短的一段时间。想回忆的时候感触万千，但部分时间他们都是无用之物“。就是这种想法。我现在也觉得没错。三年过去，对于那些记录，也就现在有那么一点”如果没有扔掉，现在看看也不不错“的想法，其他时间根本就没想。</p>
<h2 id="写吧"><a href="#写吧" class="headerlink" title="写吧"></a>写吧</h2><p>写随笔在自己看来其实一件很好的事情，鼓励自己，反省自己，记录生活，，但是“有写他们的时间我为什么不去做些其他的事情呢”这种想法总会占据上风。事实也确实如此，比如现在写这篇文章就要花不少时间。</p>
<p>正在纠结的时候学弟过来给我看了他昨晚写的博客，也是随笔，简单的记录生活，简单的排版，简单的描述，看着还不错，是自己犹犹豫豫不敢写的东西。</p>
<p>看完后又去看了一下他的友链中一个人的博客。是23 届一个学前端的女生，写了几篇博客记录自己的生活，文笔也不错，写的很好，一连看了几篇，虽然所有图片都无法查看（应该是图床没配好）但是让我看的心情变得不错。也下定决心开是写些东西。</p>
<h2 id="后谈"><a href="#后谈" class="headerlink" title="后谈"></a>后谈</h2><p>其实写这些花费时间是肯定的，但不一定就是”浪费“，写或者不写而引发的一系列反应会导致什么结果。写了这些可能让自己心情变好？影响学习效率？影响心态？时间总是要花费的，无非就是这段时间花费是不是花在你想做的事情上。如果写随笔是想做的事情，那也就是不用犹豫了。</p>
<p>以后有时间，想写了就写一些，随时、随地、随便。也不用太在乎排版啊，观感啊这些。始终觉得写东西首先是给自己看的，其次才是给别人看。</p>
<p>修博客的时候不知道写什么话放在首页好，后来发现自己用了很久的 QQ 签名不就很不错嘛：</p>
<p><strong>不乱于心，不困于情；不畏将来，不念过往。</strong></p>
<p>是丰子恺先生写的。顺带查了一下，这句话是丰子恺先生《无宠不惊过一生》的一句诗。</p>
<p>全诗如下：</p>
<p><em>不乱于心，不困于情；不畏将来，不念过往。如此，安好!</em><br><em>深谋若谷，深交若水；深明大义，深悉小节，已然，静舒!</em><br><em>善宽以怀，善感以恩；善博以浪，善精以业。这般。最佳!</em><br><em>勿感于时，勿伤于怀；勿耽美色，勿沉虚妄。从今，进取!</em><br><em>无愧于天，无愧于地。无怍于人，无惧于鬼。这样。人生!</em></p>
<p>写的是真不错啊。记下记下，后面还想开一些好词、好句之类的地方，收藏一下，初高中的东西都丢了，那时候因为要写作文，”顺带“收集了不少自己觉得不错的好词、好诗、好句，可惜都遗失了，不过现在开始，慢慢找回来吧。</p>
<p>打字打的手疼，好像还没一次性连续打这么多字。估计还有很多错字，已经不想再检查了，今天先到这里吧。</p>
<p>下面是那天晚上写的东西，也就先这么放着：</p>
<p>也不知道这里该写些什么，感觉有很多想写的，又感觉没什么写的。就瞎写得了，随性一点也不错。想起啥写啥。“以后会优化”</p>
<blockquote>
<p>三年后，你结婚了，下班回家看着你不爱的人，烦得吃不下饭，床都不愿意上，话也不想说，你会不会后悔曾经太听家人的话；</p>
<p>三年后，你结婚了，下班回家看着你当初奋不顾身要嫁的人，对你很是厌烦，只知道打游戏，话都懒得跟你说，再看看满屋的狼藉，吵闹的孩子，没洗的碗筷，他甚至家都不愿意回，你会不会后悔曾经不听家人的话；</p>
<p>三年后，你未婚，看见朋友都幸福美满，你流露出羡慕的眼神，可又看到他们为了房贷，车贷，孩子的费用，柴米油盐的平淡和枯燥锁纠缠，你庆幸自由且随意；</p>
<p>三年后，你仍没有结婚，看到别人家烟花满巷，内心的孤独和失落油然而生，对未来的迷茫无从安放。那一刻你会不会觉得自己是芸芸众生中最普通的一员，你是否会后悔当初决定不结婚；</p>
<p>巷子里的猫很自由，却没有归宿，围墙里的狗有归宿，终身都得低头，人生这道选择题，怎么选都会有遗憾，人总以为自己没有过的路上开满了鲜花，凡事看的太透，人间便无趣了，该来的都回来，该走的也都会走。别抗拒，别挽留，太注重细节的人注定不会快乐。</p>
</blockquote>
<p>QQ看点偶然看到的。例子终究是例子，你自己的生活什么样不是别人说出来的。有人陪或者三年后自己差不多也该到结婚的时候了吧，人生即将打下一个基调。婚可能还是要结的，孩子可能还是要要的，自己的想法应该还没到扭转这个路线的能力？决心？自己也说不清。“传统路线”还是自由选择，就交给将来的自己去抉择把。至少现在觉得养孩子，还贷还不是自己想要的生活。不喜欢背负着太多压力，不喜欢没有选择，不喜欢”不得不“，喜欢”所做的一切都是因为自己原意去做，想去做，想去过什么生活，想成为什么样的人“。未来的事情交给未来就好了，未来总会成为现在的。</p>
<p>最后几句话和前面关系不大吧。“凡事看的太透，人间便无趣了”这话怎么感觉说的这么像自己的状态。很多事情都没什么大兴趣，“无所谓”“都行”。</p>
<p>有些后悔初中高中写的东西没保存了，高三末写的那个本子啊，就，之前的心态好想是对过去的没什么可留恋的。</p>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>ArchLinux 使用记录</title>
    <url>/2025/01/10/ArchLinux%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="ArchLinux-使用记录"><a href="#ArchLinux-使用记录" class="headerlink" title="ArchLinux 使用记录"></a>ArchLinux 使用记录</h1><h2 id="零"><a href="#零" class="headerlink" title="零"></a>零</h2><p>强烈推荐阅读：<a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/?id=arch-linux-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-archtutorial-arch-linux-studio">Arch Linux 安装使用教程</a> 和 <a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/?id=arch-linux-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-archtutorial-arch-linux-studio">archlinux 简明指南</a> 。 这两本书都是内容非常详尽的 Arch Linux 安装和使用教程，包括Arch Linux安装、基本配置、日产使用、常用软件安装等内容，可以帮助初学者解决很多问题。 </p>
<p>笔者本人使用笔记本单固态应硬盘安装windows10 + ArchLinux双系统，推荐按照 <a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/?id=arch-linux-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-archtutorial-arch-linux-studio">archlinux 简明指南</a> 的安装步骤进行安装。</p>
<p>安装过程需要注意：</p>
<ol>
<li><p>清楚你即将使用的命令做了什么，不要一味回车回车…</p>
</li>
<li><p>按照教程的大纲，分模块进行，分清每一块做了什么，不要一行一行，遇见一个敲一个，先通读知晓这一块是做什么之后，返回来按照自己需要的去做。</p>
</li>
<li><p>不要过分地“多线程”操作试图节省时间，稳中前进，不出错就是最快的。</p>
</li>
<li><p>仔细对照好输入的命令是否正确，确认每个命令的结果是否符合预期。</p>
<p> <a href="https://bbs.archlinuxcn.org/index.php">Arclinux 中文论坛</a> 众多 Archlinux 使用者汇集的地方，同时有着较为官方的信息和软件包，很多问题可以在这里解决。</p>
</li>
</ol>
<h2 id="部分命令记录"><a href="#部分命令记录" class="headerlink" title="部分命令记录"></a>部分命令记录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fdisk -l   <span class="comment"># 查看磁盘和分区信息</span></span><br><span class="line">df-h <span class="comment"># 显示文件系统磁盘空间使用情况</span></span><br><span class="line"><span class="built_in">sudo</span> umount /dev/sdX <span class="comment"># 卸载U盘，“/dev/sdX”为你要卸载的U盘设备名称。</span></span><br><span class="line"><span class="built_in">sudo</span> mkfs.vfat /dev/sdX <span class="comment"># 将U盘格式化为FAT32文件系统/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printenv</span> <span class="comment"># 查看所有的环境变量</span></span><br><span class="line"><span class="built_in">echo</span> &amp;PATH <span class="comment"># 查看特定环境变量的值（echo $http_proxy）</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span>   <span class="comment"># 设置代理服务器，设置http_proxy和https_proxy环境变量</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br></pre></td></tr></table></figure>

<p>以下命令需要安装后才能使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tree -A 使用ASNI绘图字符显示树状图而非以ASCII字符组合</span><br><span class="line">     -C 使用颜色区分文件类型</span><br><span class="line">     -N 支持显示中文字符</span><br><span class="line">     -a 显示隐藏文件(以.开头)</span><br><span class="line">     -d 只显示目录</span><br><span class="line">     -h 使用人易读的单位显示文件大小</span><br><span class="line">     -L [num] 指定显示的最大深度</span><br></pre></td></tr></table></figure>

<p>##Pacman包管理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Syu                <span class="comment"># 升级系统</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S package_name     <span class="comment"># 安装软件包</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Syu package_name   <span class="comment"># 升级系统并安装软件包，ArchLinux 不支持部分升级，建议用此命令先升级再安装</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Syyu               <span class="comment"># 升级系统 yy标记强制刷新 u标记升级动作</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Ss package_name    <span class="comment"># 搜索包含相关内容的软件包</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -R package_name     <span class="comment"># 删除软件包</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Qi package_name    <span class="comment"># 查看软件包信息     </span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Q                  <span class="comment"># 查看安装的软件包      </span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Rs package_name    <span class="comment"># 删除软件包，及其所有没有被其他已安装软件包使用的依赖包</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Si package_name    <span class="comment"># 从数据库中搜索软件包的信息</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Qdt                <span class="comment"># 找出孤立包 Q为查询本地软件包数据库 d标记依赖包 t标记不需要的包 dt合并标记孤立包</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Rs $(pacman -Qtdq) <span class="comment"># 删除孤立软件包</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -U abc.pkg.tar.gz   <span class="comment"># 安装下载的abc包，或新编译的本地abc包</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Fy                 <span class="comment"># 更新命令查询文件列表数据库</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -F xxx              <span class="comment"># 当不知道某个命令属于哪个包时，用来查询某个xxx命令属于哪个包</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Sc                 <span class="comment"># 清理没有安装的所有缓存包，和没有被使用的同步数据库</span></span><br><span class="line"></span><br><span class="line">yay -Syu                        <span class="comment"># 升级官方和 AUR 的软件包, 包括pacman, -syyu强制升级</span></span><br><span class="line">yay -S abc                      <span class="comment"># 安装abc包</span></span><br><span class="line">yay -Ss abc | grep 已安装        <span class="comment"># 搜索已安装且包含abc的包</span></span><br><span class="line">yay -R 包名                      <span class="comment"># 删除软件包(不包括前后缀，版本号)</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /var/lib/pacman/db.lck  <span class="comment"># 删除/var/lib/pacman/db.lck锁</span></span><br></pre></td></tr></table></figure>
<h2 id="系统服务的操作与介绍"><a href="#系统服务的操作与介绍" class="headerlink" title="系统服务的操作与介绍"></a>系统服务的操作与介绍</h2><p>Linux 系统中运行着各种服务，你需要掌握查询，变更服务状态的方式。同时对创建服务最好也有大致的了解。这里讲述命令<code>systemctl</code>的用法。以 dhcpcd 为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start dhcpcd          <span class="comment"># 启动服务</span></span><br><span class="line">systemctl stop dhcpcd           <span class="comment"># 停止服务</span></span><br><span class="line">systemctl restart dhcpcd        <span class="comment"># 重启服务</span></span><br><span class="line">systemctl reload dhcpcd         <span class="comment"># 重新加载服务以及它的配置文件</span></span><br><span class="line">systemctl status dhcpcd         <span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl <span class="built_in">enable</span> dhcpcd         <span class="comment"># 设置开机启动服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> --now dhcpcd   <span class="comment"># 设置服务为开机启动并立即启动这个单元:</span></span><br><span class="line">systemctl <span class="built_in">disable</span> dhcpcd        <span class="comment"># 取消开机自动启动</span></span><br><span class="line">systemctl daemon-reload dhcpcd  <span class="comment"># 重新载入 systemd 配置 扫描新增或变更的服务单元 不会重新加载变更的配置 加载变更的配置用 reload</span></span><br></pre></td></tr></table></figure>

<h2 id="换源-阿里云"><a href="#换源-阿里云" class="headerlink" title="换源-阿里云"></a>换源-阿里云</h2><p>编辑文件<code>/etc/pacman.d/mirrorlist</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>
<p>在镜像源列表最顶端添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Server = http://mirrors.aliyun.com/archlinux/<span class="variable">$repo</span>/os/<span class="variable">$arch</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://developer.aliyun.com/mirror/archlinuxcn?spm=a2c6h.13651102.0.0.3e221b11Nc8UpY">阿里云开发者社区&gt; 镜像站&gt; archlinuxcn</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Syy &amp;&amp; <span class="built_in">sudo</span> pacman -S archlinuxcn-keyring <span class="comment"># 安装 archlinuxcn-keyring 包导入GPG key</span></span><br></pre></td></tr></table></figure>
<h2 id="安装yay"><a href="#安装yay" class="headerlink" title="安装yay"></a>安装yay</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S yay</span><br><span class="line"><span class="comment">#安装完成后再次更新</span></span><br><span class="line">yay -Syyu &amp;&amp; yay -Sys</span><br></pre></td></tr></table></figure>
<h2 id="设置某个命令不再需要-sudo-输入密码"><a href="#设置某个命令不再需要-sudo-输入密码" class="headerlink" title="设置某个命令不再需要 sudo 输入密码"></a>设置某个命令不再需要 sudo 输入密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/sudoers <span class="comment"># 编辑配置文件</span></span><br><span class="line"><span class="comment"># 在合适的行添加以下内容，username 是你的用户名，注意使用完整路径，不然每次都会提醒，不同命令用&quot;,&quot;隔开</span></span><br><span class="line">username ALL=(ALL) NOPASSWD: /usr/sbin/systemctl，/ust/sbin/pacman</span><br><span class="line"><span class="comment"># 使用which命令可以查看程序的完整路径。</span></span><br><span class="line"><span class="built_in">which</span> yay</span><br><span class="line"><span class="built_in">which</span> pacman</span><br><span class="line"><span class="comment"># 一键为当前用户设置免 sudo 权限，当前用户所有命令都不在需要sudo输入密码</span></span><br><span class="line"><span class="built_in">sudo</span> sh -c <span class="string">&quot;echo &#x27;<span class="variable">$USER</span> ALL = (ALL) NOPASSWD:ALL&#x27; &gt; /etc/sudoers.d/<span class="variable">$USER</span>&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="常见问题及其解决"><a href="#常见问题及其解决" class="headerlink" title="常见问题及其解决"></a>常见问题及其解决</h2><ul>
<li><p>使用yay命令时报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">搜索 AUR 时出错: response decoding failed: invalid character <span class="string">&#x27;&lt;&#x27;</span> looking <span class="keyword">for</span></span><br></pre></td></tr></table></figure>
<ul>
<li>解决：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay --aururl <span class="string">&quot;https://aur.archlinux.org&quot;</span> --save</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Telegram无法登陆：</p>
<ul>
<li>解决：<br>SETTING中添加地址，使用代理，port选择代理所使用端口号。</li>
</ul>
</li>
<li><p>连接显示器无法使用：</p>
<ul>
<li>解决：<br>根据<a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/">Linux 安装使用教程</a>中<strong>显卡驱动</strong>所描述进行即可。</li>
</ul>
</li>
<li><p>VSCode无法唤出外部终端：</p>
<ul>
<li>解决：<br><code>.vscode</code>文件中设置启用外部终端，在<code>settings.json</code>文件中加入”terminal.external.linuxExec”: “&#x2F;usr&#x2F;bin&#x2F;konsole”, “”内指要调用的终端bin&#x2F;konsole。</li>
</ul>
</li>
<li><p>在升级系统（syu）时，出现以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">错误：python-markdown: 来自 <span class="string">&quot;Caleb Maclennan &lt;alerque@archlinux.org&gt;&quot;</span> 的签名是勉强信任的</span><br><span class="line">:: 文件 /var/cache/pacman/pkg/python-markdown-3.3.6-1-any.pkg.tar.zst 已损坏 (无效或已损坏的软件包 (PGP 签名)).</span><br><span class="line">打算删除吗？ [Y/n] </span><br><span class="line">错误：trash-cli: 来自 <span class="string">&quot;Alexander Epaneshnikov &lt;alex19ep@archlinux.org&gt;&quot;</span> 的签名是勉强信任的</span><br><span class="line">:: 文件 /var/cache/pacman/pkg/trash-cli-0.21.10.24-1-any.pkg.tar.zst 已损坏 (无效或已损坏的软件包 (PGP 签名)).</span><br><span class="line">打算删除吗？ [Y/n] </span><br><span class="line">错误：无法提交处理 (无效或已损坏的软件包)</span><br><span class="line">发生错误，没有软件包被更新。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解决：</p>
<p>终端输入：<code>sudo pacman-key --init &amp;&amp; sudo pacman-key --populate &amp;&amp; sudo pacman -Syyu</code></p>
<p>可能的方法：<code>sudo pacman -S archlinux-keyring</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="使用Docker"><a href="#使用Docker" class="headerlink" title="使用Docker"></a>使用Docker</h2><ol>
<li><p>安装：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S docker <span class="comment"># 安装Docker -Ss搜索Docker软件包</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker.service <span class="comment"># 开启Docker开机自启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start docker.service  <span class="comment"># 启动Docker服务</span></span><br><span class="line"><span class="comment"># 安装好docker后自动建立了docker组，不需要自己添加docker组，只需要把当前工作用户加入docker组即可</span></span><br><span class="line"><span class="built_in">sudo</span> gpasswd -a <span class="variable">$USER</span> docker <span class="comment"># 把工作用户加入Docker组，避免使用root账号工作</span></span><br><span class="line"><span class="comment">#重启系统生效</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> docker.service <span class="comment"># 关闭开机自启动服务</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull archlinux  <span class="comment"># 下载镜像</span></span><br><span class="line">docker image <span class="built_in">ls</span>        <span class="comment"># 列出镜像列表</span></span><br><span class="line">docker ps -a           <span class="comment"># 列出容器列表</span></span><br><span class="line">docker run -it archlinux /bin/bash       <span class="comment"># 用所给镜像启动一个新的容器</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -it --net=host gpt-academic <span class="comment"># 用所给镜像启动一个新的容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;CONTAINER_NAME&gt; bash    <span class="comment"># 进入一个正在运行的docker(在容器内部创建一个子进程)</span></span><br><span class="line">docker stop [contaionerID]               <span class="comment"># 终止镜像</span></span><br><span class="line">docker rmi $(docker images -q)           <span class="comment"># 删除所有镜像</span></span><br><span class="line">docker stop $(docker ps -aq)             <span class="comment"># 停止所有容器</span></span><br><span class="line">docker container <span class="built_in">rm</span> [contaionerID]       <span class="comment"># 删除一个处于终止状态的容器</span></span><br><span class="line">docker container <span class="built_in">rm</span> $(docker images -q)  <span class="comment"># 删除所有容器</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置镜像：</p>
<p>启动镜像，配置初始开发环境，安装了一些包（可能有些没有用），</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -t -i archlinux /bin/bash <span class="comment"># 启动镜像</span></span><br><span class="line"><span class="comment"># 在docker内输入以下内容</span></span><br><span class="line">sed -i <span class="string">&#x27;1i Server = http://mirrors.aliyun.com/archlinux/$repo/os/$arch&#x27;</span> /etc/pacman.d/mirrorlist \</span><br><span class="line">    &amp;&amp; sed -i <span class="string">&#x27;1i Server = https://mirrors.tencent.com/archlinux/$repo/os/$arch&#x27;</span> /etc/pacman.d/mirrorlist \</span><br><span class="line">    &amp;&amp; sed -i <span class="string">&#x27;$i [archlinuxcn]&#x27;</span> /etc/pacman.conf \</span><br><span class="line">    &amp;&amp; sed -i <span class="string">&#x27;$i SigLevel = TrustAll&#x27;</span> /etc/pacman.conf \</span><br><span class="line">    &amp;&amp; sed -i <span class="string">&#x27;$i Server = https://repo.archlinuxcn.org/$arch&#x27;</span> /etc/pacman.conf \</span><br><span class="line">    &amp;&amp; sed -i -r <span class="string">&#x27;s/^NoExtract\s*=\s*.*/# \0/g&#x27;</span> /etc/pacman.conf \</span><br><span class="line">    &amp;&amp; pacman -Syyu --noconfirm \</span><br><span class="line">    &amp;&amp; pacman -Sy --noconfirm archlinuxcn-keyring &amp;&amp; pacman -Su --noconfirm\</span><br><span class="line">    &amp;&amp; pacman -Syy --noconfirm git vim neovim zsh oh-my-zsh-git jdk-openjdk jdk8-openjdk jdk11-openjdk \</span><br><span class="line">    maven yay zsh python3 go nodejs npm yarn tmux python2 zsh-autosuggestions zsh-syntax-highlighting \</span><br><span class="line">    zsh-theme-powerlevel10k ranger python-pip python-neovim wl-clipboard fzf ripgrep man-db \</span><br><span class="line">    gcc clang base-devel wqy-zenhei noto-fonts-cjk wget unzip thefuck \</span><br><span class="line">    &amp;&amp; <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><br><span class="line">    &amp;&amp; pacman -Scc --noconfirm \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/pacman/sync/* /var/cache/pacman/pkg/* \</span><br><span class="line">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; /var/log/pacman.log</span><br></pre></td></tr></table></figure>

<p>精简版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;1i Server = http://mirrors.aliyun.com/archlinux/$repo/os/$arch&#x27;</span> /etc/pacman.d/mirrorlist \</span><br><span class="line">    &amp;&amp; sed -i <span class="string">&#x27;1i Server = https://mirrors.tencent.com/archlinux/$repo/os/$arch&#x27;</span> /etc/pacman.d/mirrorlist \</span><br><span class="line">    &amp;&amp; sed -i <span class="string">&#x27;$i [archlinuxcn]&#x27;</span> /etc/pacman.conf \</span><br><span class="line">    &amp;&amp; sed -i <span class="string">&#x27;$i SigLevel = TrustAll&#x27;</span> /etc/pacman.conf \</span><br><span class="line">    &amp;&amp; sed -i <span class="string">&#x27;$i Server = https://repo.archlinuxcn.org/$arch&#x27;</span> /etc/pacman.conf \</span><br><span class="line">    &amp;&amp; sed -i -r <span class="string">&#x27;s/^NoExtract\s*=\s*.*/# \0/g&#x27;</span> /etc/pacman.conf \</span><br><span class="line">    &amp;&amp; pacman -Syyu --noconfirm \</span><br><span class="line">    &amp;&amp; pacman -Sy --noconfirm archlinuxcn-keyring &amp;&amp; pacman -Su --noconfirm\</span><br><span class="line">    &amp;&amp; pacman -Syy --noconfirm git vim neovim \</span><br><span class="line">    maven yay go npm yarn tmux \</span><br><span class="line">    ranger python-pip python-neovim wl-clipboard fzf ripgrep man-db \</span><br><span class="line">    gcc clang base-devel wqy-zenhei noto-fonts-cjk wget unzip thefuck \</span><br><span class="line">    &amp;&amp; <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><br><span class="line">    &amp;&amp; pacman -Scc --noconfirm \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/pacman/sync/* /var/cache/pacman/pkg/* \</span><br><span class="line">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; /var/log/pacman.log</span><br></pre></td></tr></table></figure>


</li>
<li><p>配置vscode：</p>
<p>下载插件：Remote Development Pack（包含Remote-Containers)，Docker。打开插件，在CONTAINERS中右键Attach Visual Studio Code，在vscode中运行了镜像，重新安装一些扩展，当作一个新的archlinux一样使用。</p>
</li>
<li><p>容器和本地间的文件传输：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a   <span class="comment"># 获得容器ID</span></span><br><span class="line">docker <span class="built_in">cp</span> 本地文件路径 ID全称:容器路径 <span class="comment"># 本地文件复制到容器</span></span><br><span class="line">docker <span class="built_in">cp</span> ID全称:容器文件路径 本地路径 <span class="comment"># 容器文件复制到本地</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Typora-PicGo-Github图床"><a href="#Typora-PicGo-Github图床" class="headerlink" title="Typora+PicGo+Github图床"></a>Typora+PicGo+Github图床</h2><p>整体遵循：<a href="https://juejin.cn/post/6844904137407086600#heading-8">https://juejin.cn/post/6844904137407086600#heading-8</a></p>
<ol>
<li>创建GIthub仓库并创建Token并复制</li>
<li>下载PicGo（app）并配置，包括时间戳命名，选择github图床，仓库名，分支用main，设定Token</li>
<li>下载并配置node.js</li>
<li>配置Typora并测试图床</li>
</ol>
<h3 id="编译安装从-GitHub-下载的源码"><a href="#编译安装从-GitHub-下载的源码" class="headerlink" title="编译安装从 GitHub 下载的源码"></a>编译安装从 GitHub 下载的源码</h3><ol>
<li><p>执行以下命令，生成 Makefile 文件：</p>
<p> <code>./autogen.sh</code> </p>
</li>
<li><p>如果下载的源代码中已经包含了 Makefile 文件，则可以跳过此步骤。</p>
</li>
<li><p>执行以下命令，配置编译选项：</p>
<p><code>./configure</code> </p>
<p>configure 脚本会检查系统环境和依赖库，并生成 Makefile 文件。可以通过指定不同的选项来定制编译过程。</p>
<p>例如，可以使用 –prefix 选项指定安装目录，使用 –enable-shared 选项生成共享库等。</p>
</li>
<li><p>执行以下命令，开始编译： </p>
<p> <code>make</code> </p>
<p> 这个命令会编译源代码，并生成可执行文件或共享库等。 </p>
</li>
<li><p>执行以下命令，安装编译好的文件：</p>
</li>
<li><p><code>sudo make install</code> </p>
<p>这个命令会将编译好的文件安装到系统中，通常是 &#x2F;usr&#x2F;local 目录。 如果在执行 configure 或 make 命令时遇到了错误，可以根据错误信息进行调整。通常情况下，错误信息会提示缺少依赖库或者系统环境不兼容等问题。</p>
</li>
</ol>
<h2 id="安装deb包"><a href="#安装deb包" class="headerlink" title="安装deb包"></a>安装deb包</h2><ol>
<li>使用yay安装debtap。 <code>yay -S debtap</code></li>
<li>升级的debtap。<code>sudo debtap -U</code></li>
<li>转换deb包，生成一个<code>yourfile.zst</code>文件。<code>sudo debtap yourfile.deb</code>（接两次回车）</li>
<li>安装转换后的包。<code>sudo pacman -U yourfile.zst</code></li>
</ol>
<h2 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h2><ul>
<li><code>-c</code> ：生成一个新的归档文件</li>
<li><code>-f</code> ：输出到文件中，</li>
<li><code>-z</code> &amp; <code>-j</code> ：将 tar 压缩成 gzip 和 bzip2 格式。</li>
<li><code>archive</code> ：压缩文件的名称</li>
<li><code>/path/to/folder</code> ：要压缩的文件夹的路径。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文件夹压缩成 .tar 文件:</span></span><br><span class="line">copy codetar -cf archive.tar /path/to/folder</span><br><span class="line"><span class="comment"># 将文件夹压缩成 .tar.gz 文件:</span></span><br><span class="line">copy codetar -czf archive.tar.gz /path/to/folder</span><br><span class="line"><span class="comment"># 将文件夹压缩成 .tar.bz2 文件:</span></span><br><span class="line">copy codetar -cjf archive.tar.bz2 /path/to/folder</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="安装QQ"><a href="#安装QQ" class="headerlink" title="安装QQ"></a>安装QQ</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -Ss linuxqq <span class="comment"># 在AUR查找linuxQQ </span></span><br><span class="line">yay -S linuxqq  <span class="comment"># 从AUR安装linuxqq</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Rns linuxqq <span class="comment"># 删除linuxqq及不再需要的依赖</span></span><br></pre></td></tr></table></figure>

<h3 id="登陆后闪退的可能解决办法："><a href="#登陆后闪退的可能解决办法：" class="headerlink" title="登陆后闪退的可能解决办法："></a>登陆后闪退的可能解决办法：</h3><p>删除<code>~/.config/QQ</code> 下的所有文件，重启QQ进行登陆并在设置里关闭QQ自己的更新。</p>
<p>其他问题请自行在Google或者在<a href="https://bbs.archlinuxcn.org/index.php">Arch中文社区</a>寻找解决方案</p>
<h2 id="安装-fcitx5及中文输入法"><a href="#安装-fcitx5及中文输入法" class="headerlink" title="安装 fcitx5及中文输入法"></a>安装 fcitx5及中文输入法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S fcitx5-im </span><br><span class="line"><span class="built_in">sudo</span> pacman -S fcitx5-chinese-addons  fcitx5-rime</span><br></pre></td></tr></table></figure>

<p><code>sudo vim /etc/environment</code>，添加如下内容，之后重启输入法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">SDL_IM_MODULE=fcitx</span><br></pre></td></tr></table></figure>

<p>在设置中找到输入法，添加输入法，选拼音</p>
<h3 id="中文标点消失："><a href="#中文标点消失：" class="headerlink" title="中文标点消失："></a>中文标点消失：</h3><ul>
<li><p>编辑~&#x2F;.config&#x2F;fcitx&#x2F;data&#x2F;punc.mb.zh_CN，自行查找</p>
</li>
<li><p>[ctrl+.]</p>
</li>
</ul>
<h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件:"></a>编辑配置文件:</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>目前的:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -r <span class="string">&quot;<span class="variable">$&#123;XDG_CACHE_HOME:-<span class="variable">$HOME</span>/.cache&#125;</span>/p12k-instant-prompt-<span class="variable">$&#123;(%):-%n&#125;</span>.zsh&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">source</span> <span class="string">&quot;<span class="variable">$&#123;XDG_CACHE_HOME:-<span class="variable">$HOME</span>/.cache&#125;</span>/p11k-instant-prompt-<span class="variable">$&#123;(%):-%n&#125;</span>.zsh&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ZSH=/usr/share/oh-my-zsh/</span><br><span class="line"></span><br><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span></span><br><span class="line"></span><br><span class="line">plugins=(</span><br><span class="line">	<span class="built_in">sudo</span></span><br><span class="line">	git</span><br><span class="line">	autojump</span><br><span class="line">	zsh-syntax-highlighting</span><br><span class="line">	zsh-autosuggestions</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ZSH_CACHE_DIR=<span class="variable">$HOME</span>/.cache/oh-my-zsh</span><br><span class="line"><span class="keyword">if</span> [[ ! -d <span class="variable">$ZSH_CACHE_DIR</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">mkdir</span> <span class="variable">$ZSH_CACHE_DIR</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.</span></span><br><span class="line">[[ ! -f ~/.p10k.zsh ]] || <span class="built_in">source</span> ~/.p10k.zsh</span><br><span class="line"><span class="comment"># other name</span></span><br><span class="line"><span class="built_in">alias</span> sp=<span class="string">&#x27;sudo pacman&#x27;</span> </span><br><span class="line"><span class="built_in">alias</span> syyu=<span class="string">&#x27;yay -Syyu&#x27;</span> <span class="comment"># 强制升级系统和软件包</span></span><br><span class="line"><span class="built_in">alias</span> syu=<span class="string">&#x27;yay -Syu&#x27;</span>   <span class="comment"># 升级系统和软件包</span></span><br><span class="line"><span class="built_in">alias</span> c=<span class="string">&#x27;clear&#x27;</span> <span class="comment"># 清屏</span></span><br><span class="line"><span class="built_in">alias</span> e=<span class="string">&#x27;exit&#x27;</span>  <span class="comment"># 退出终端</span></span><br><span class="line"><span class="built_in">alias</span> qq=<span class="string">&#x27;rm -rf ~/.config/QQ/ &amp;&amp; linuxqq &amp;&#x27;</span> <span class="comment"># 启动QQ时删除文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git快捷键 cd+add+commit+push+cd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地Note仓库提交到gihub</span></span><br><span class="line"><span class="built_in">alias</span> gpn=<span class="string">&#x27;cd /home/origin/Code/repository/Note &amp;&amp; git add . &amp;&amp; git commit -m \&quot;update\&quot; &amp;&amp; git push &amp;&amp; cd -&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地Code_c仓库提交到gihub</span></span><br><span class="line"><span class="built_in">alias</span> gpc=<span class="string">&#x27;cd /home/origin/Code/repository/Code_c &amp;&amp; git add . &amp;&amp; git commit -m \&quot;update\&quot; &amp;&amp; git push &amp;&amp; cd -&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地Code_cc仓库提交到gihub</span></span><br><span class="line"><span class="built_in">alias</span> gpcc=<span class="string">&#x27;cd /home/origin/Code/repository/Code_cc &amp;&amp; git add . &amp;&amp; git commit -m \&quot;update\&quot; &amp;&amp; git push &amp;&amp; cd -&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地Python仓库提交到gihub</span></span><br><span class="line"><span class="built_in">alias</span> gppy=<span class="string">&#x27;cd /home/origin/Code/repository/Code_py &amp;&amp; git add . &amp;&amp; git commit -m \&quot;update\&quot; &amp;&amp; git push &amp;&amp; cd -&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地my-xv6-labs-2022仓库提交到gihub</span></span><br><span class="line"><span class="built_in">alias</span> gplab=<span class="string">&#x27;cd /home/origin/Code/repository/my-xv6-labs-2022 &amp;&amp; git add . &amp;&amp; git commit -m \&quot;update\&quot; &amp;&amp; git push &amp;&amp;cd -&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="string">&quot;<span class="variable">$HOME</span>/go&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:/usr/lib/go/bin:<span class="variable">$GOPATH</span>/bin&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/sbin:<span class="variable">$PATH</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>##为一个文件或目录创建一个符号链接：</p>
<p>在<code>/usr/local/local</code>中存有已经建立的符号链接，在<code>/usr/share</code>中有通过自行下载的装包安装的软件，如通过官网安装包安装的code。</p>
<p>输入<code>ln -s [文件/目录路径] [建立后的软链接名称]</code>，即可建立链接。如：<code>ln -s /usr/share/code/code code</code></p>
<h2 id="更改默认Jva环境"><a href="#更改默认Jva环境" class="headerlink" title="更改默认Jva环境"></a>更改默认Jva环境</h2><h3 id="安装Java环境（Java-20-jdk）"><a href="#安装Java环境（Java-20-jdk）" class="headerlink" title="安装Java环境（Java-20-jdk）"></a>安装Java环境（Java-20-jdk）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Sy --needed --noconfirm jdk</span><br></pre></td></tr></table></figure>

<p>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">archlinux-java status</span><br></pre></td></tr></table></figure>

<p>若出现类似下面，即为安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Available Java environments:</span><br><span class="line">  java-21-jdk</span><br><span class="line">  java-21-openjdk</span><br><span class="line">  java-8-openjdk (default)</span><br></pre></td></tr></table></figure>

<p>若 java-21-openjdk 为 default 则已成功将 java21 设置为默认环境，若不是，则输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> archlinux-java <span class="built_in">set</span> java-20-openjdk[你想要设为默认的java环境名]</span><br></pre></td></tr></table></figure>

<p>后输入<code>archlinux-java status</code>查看， java-21-openjdk 已是 default</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Available Java environments:</span><br><span class="line">  java-21-jdk</span><br><span class="line">  java-21-openjdk (default)</span><br><span class="line">  java-8-openjdk</span><br></pre></td></tr></table></figure>

<h2 id="ArchLinux内存管理"><a href="#ArchLinux内存管理" class="headerlink" title="ArchLinux内存管理"></a>ArchLinux内存管理</h2><ol>
<li><p>清除 Arch Linux 上的包缓存和AUR 软件包</p>
<p> 在<code>/var/cache/pacman/pkg/</code>目录中存有下载的每个软件包；</p>
<p> 在<code>/home/Yuanmxc/.cache/yay</code>存有从 AUR 下载的软件包。</p>
<p> 这些软件包包括升级前的旧包，如果更新破坏了软件包，便于回滚到以前的版本。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除当前上面两个文件中未安装的所有软件包</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Sc</span><br><span class="line">yay -Sc</span><br><span class="line"><span class="comment"># -cc 标志删除所有缓存的包</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -Scc</span><br><span class="line">yay -Scc</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除孤立的软件包</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Qtdq 查看删除孤立的软件包</span><br><span class="line"><span class="built_in">sudo</span> pacman -Rns $(pacman -Qtdq)</span><br></pre></td></tr></table></figure>
</li>
<li><p>清理日志，设置了固定大小为50M，多的日志会被删掉。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> journalctl --vacuum-size=50M</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="python-使用-pip-遇到问题"><a href="#python-使用-pip-遇到问题" class="headerlink" title="python 使用 pip 遇到问题"></a>python 使用 pip 遇到问题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install scikit-learn</span><br><span class="line">error: externally-managed-environment</span><br><span class="line"></span><br><span class="line">× This environment is externally managed</span><br><span class="line">╰─&gt; To install Python packages system-wide, try <span class="string">&#x27;pacman -S</span></span><br><span class="line"><span class="string">    python-xyz&#x27;</span>, <span class="built_in">where</span> xyz is the package you are trying to</span><br><span class="line">    install.</span><br><span class="line">    </span><br><span class="line">    If you wish to install a non-Arch-packaged Python package,</span><br><span class="line">    create a virtual environment using <span class="string">&#x27;python -m venv path/to/venv&#x27;</span>.</span><br><span class="line">    Then use path/to/venv/bin/python and path/to/venv/bin/pip.</span><br><span class="line">    </span><br><span class="line">    If you wish to install a non-Arch packaged Python application,</span><br><span class="line">    it may be easiest to use <span class="string">&#x27;pipx install xyz&#x27;</span>, <span class="built_in">which</span> will manage a</span><br><span class="line">    virtual environment <span class="keyword">for</span> you. Make sure you have python-pipx</span><br><span class="line">    installed via pacman.</span><br><span class="line"></span><br><span class="line">note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.</span><br><span class="line">hint: See PEP 668 <span class="keyword">for</span> the detailed specification.</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /usr/lib/python3.12/EXTERNALLY-MANAGED <span class="comment"># python路径和版本要与系统中的相对应</span></span><br></pre></td></tr></table></figure>

<h2 id="修改用户名及用户目录"><a href="#修改用户名及用户目录" class="headerlink" title="修改用户名及用户目录"></a>修改用户名及用户目录</h2><ol>
<li>切换终端，用root账户登录; </li>
<li>编辑&#x2F;etc&#x2F;passwd文件，将旧用户名替换为新用户名; </li>
<li>编辑&#x2F;etc&#x2F;shadow文件，将旧用户名替换为新用户名；</li>
<li>编辑&#x2F;etc&#x2F;group文件，将旧用户名替换为新用户名；</li>
<li>重命名home文件： mv &#x2F;home&#x2F;oldusername &#x2F;home&#x2F;newusername</li>
</ol>
<p> 注：目录名的改变会导致一些固定路径的配置项发生错误，需要手动修改路径。</p>
<h2 id="Linux-修改U盘名称"><a href="#Linux-修改U盘名称" class="headerlink" title="Linux 修改U盘名称"></a>Linux 修改U盘名称</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S mtools <span class="comment"># 安装工具</span></span><br><span class="line"><span class="built_in">sudo</span> vim /etc/mtools.conf <span class="comment"># 然后修改配置文件</span></span><br><span class="line"><span class="comment"># 在这个文件最后添加下面一行</span></span><br><span class="line">mtools_skip_check=1</span><br><span class="line"><span class="built_in">sudo</span> mlabel -i /dev/sdb1 ::DISK2 <span class="comment"># sdb1是U盘，SISK2是修改后的名称（自动改大写）</span></span><br><span class="line"><span class="built_in">sudo</span> eject /dev/sdb1      <span class="comment"># 修改完成</span></span><br></pre></td></tr></table></figure>

<h2 id="安装使用-valgrind-检测内存泄露"><a href="#安装使用-valgrind-检测内存泄露" class="headerlink" title="安装使用 valgrind 检测内存泄露"></a>安装使用 valgrind 检测内存泄露</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S valgrind</span><br><span class="line">pacman -S debuginfod</span><br><span class="line">pacman -S glibc</span><br><span class="line"></span><br><span class="line">valgrind --leak-check=full ./your_program</span><br></pre></td></tr></table></figure>

<h2 id="syu升级软件包出现错误："><a href="#syu升级软件包出现错误：" class="headerlink" title="syu升级软件包出现错误："></a>syu升级软件包出现错误：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">google-chrome: 文件系统中已存在 /opt/google/chrome/CHROME_VERSION_EXTRA </span><br><span class="line">google-chrome: 文件系统中已存在 /opt/google/chrome/MEIPreload/manifest.json </span><br><span class="line">google-chrome: 文件系统中已存在 /opt/google/chrome/MEIPreload/preloaded_data.pb </span><br><span class="line"></span><br><span class="line">（多行类似,在<span class="string">&quot;/opt/google/chrome/&quot;</span>下）</span><br><span class="line"></span><br><span class="line">google-chrome: 文件系统中已存在 /usr/share/doc/google-chrome-stable/changelog.gz </span><br><span class="line">google-chrome: 文件系统中已存在 /usr/share/gnome-control-center/default-apps/google-chrome.xml </span><br><span class="line">google-chrome: 文件系统中已存在 /usr/share/icons/hicolor/128x128/apps/google-chrome.png </span><br><span class="line">google-chrome: 文件系统中已存在 </span><br><span class="line"></span><br><span class="line">（多行类似,在<span class="string">&quot;/usr/share&quot;</span>下）</span><br><span class="line"></span><br><span class="line">发生错误，没有软件包被更新。</span><br><span class="line"> -&gt; 安装时出错:  [/home/Yuanmxc/.cache/yay/google-chrome/google-chrome-124.0.6367.201-1-x86_64.pkg.tar.zst] - <span class="built_in">exit</span> status 1</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S google-chrome --overwrite=<span class="string">&#x27;/opt/*&#x27;</span> --overwrite=<span class="string">&#x27;/usr/*&#x27;</span></span><br><span class="line"><span class="comment"># 安装时覆盖这两个目录下与 Google Chrome 相关的文件</span></span><br></pre></td></tr></table></figure>

<h2 id="手动编译安装一些软件包，依赖库"><a href="#手动编译安装一些软件包，依赖库" class="headerlink" title="手动编译安装一些软件包，依赖库"></a>手动编译安装一些软件包，依赖库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S base-devel <span class="comment"># 安装必要编译工具和依赖项，已安装不用再安装</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/sctplab/usrsctp.git <span class="comment"># 克隆源码</span></span><br><span class="line"><span class="comment"># 进入目目录编译安装</span></span><br><span class="line"><span class="built_in">cd</span> usrsctp</span><br><span class="line">./bootstrap</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"><span class="comment"># 安装完后可以删除源码</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">rm</span> -rf usrsctp</span><br></pre></td></tr></table></figure>

<h2 id="KDE-显示相关"><a href="#KDE-显示相关" class="headerlink" title="KDE 显示相关"></a>KDE 显示相关</h2><p>安装 optimus-manager（<a href="https://github.com/Askannz/optimus-manager">AUR</a> &amp; <a href="https://github.com/Askannz/optimus-manager">GIthub</a>） 及 optimus-manager-qt 来进行 GPU 管理，适合 AMD+Nvida 独显用户，主要是便于连接显示器和显卡切换，方案参考来自 <a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/graphic_driver?id=%e6%98%be%e5%8d%a1%e9%a9%b1%e5%8a%a8">archlinuxstudio的显卡驱动部分</a>。</p>
<p>部分可能用到的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/bus/pci/devices/0000\:01\:00.0/power/runtime_status <span class="comment"># 查看 Nvida 是否active</span></span><br><span class="line">nvidia-smi <span class="comment"># 查看Nvida 显卡状态</span></span><br></pre></td></tr></table></figure>

<p>从530.41驱动版本开始，出现了卡被锁定在低功耗限制的情况（参见GitHub问题483）。 NVIDIA 驱动程序已禁用使用 <code>nvidia-smi</code> 命令手动设置功率限制的功能，因此许多笔记本电脑陷入低功耗和性能不佳的困境。</p>
<p>要解决此问题（对于 Ampere 一代或更新版本），请启动&#x2F;启用 <code>nvidia-powerd.service</code> ，这将启用 DynamicBoost。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status nvidia-powerd.service <span class="comment"># 查看状态</span></span><br><span class="line">systemctl start nvidia-powerd.service <span class="comment"># 启用</span></span><br><span class="line">systemctl stop nvidia-powerd.service <span class="comment"># 停用</span></span><br></pre></td></tr></table></figure>

<h4 id="查看磁盘信息"><a href="#查看磁盘信息" class="headerlink" title="查看磁盘信息"></a>查看磁盘信息</h4><p>也可使用 <code>fdisk -l</code> 等命令进行查看，这里采用 <code>lsblk</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure>

<p>假设U盘为 sdc</p>
<h3 id="卸载设备"><a href="#卸载设备" class="headerlink" title="卸载设备"></a>卸载设备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 卸载 sdc </span></span><br><span class="line"><span class="built_in">sudo</span> umount /dev/sdc*</span><br></pre></td></tr></table></figure>

<h3 id="格式化成功后，再次查看磁盘信息时，上面提到的3个分区就不存在了"><a href="#格式化成功后，再次查看磁盘信息时，上面提到的3个分区就不存在了" class="headerlink" title="格式化成功后，再次查看磁盘信息时，上面提到的3个分区就不存在了"></a>格式化成功后，再次查看磁盘信息时，上面提到的3个分区就不存在了</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式化成功后，再次查看磁盘信息时，上面提到的3个分区就不存在了</span></span><br><span class="line"><span class="built_in">sudo</span> mkfs.vfat /dev/sdc -I</span><br></pre></td></tr></table></figure>

<h4 id="制作系统启动盘"><a href="#制作系统启动盘" class="headerlink" title="制作系统启动盘"></a>制作系统启动盘</h4><p>采用 <code>dd</code> 命令将系统镜像写入U盘。执行完毕后，<code>Ubuntu</code> 系统启动盘就制作好了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># if=镜像的路径, of=写入的磁盘, status=progress方便查看下进度</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> bs=4M <span class="keyword">if</span>=ubuntu-20.04.2.0-desktop-amd64.iso of=/dev/sdc status=progress oflag=<span class="built_in">sync</span></span><br></pre></td></tr></table></figure>

<h2 id="使用ssh连接远程主机"><a href="#使用ssh连接远程主机" class="headerlink" title="使用ssh连接远程主机"></a>使用ssh连接远程主机</h2><p>在 Arch Linux 上，SSH 客户端是 OpenSSH 软件包的一部分：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Syu</span><br><span class="line"><span class="built_in">sudo</span> pacman -S openssh</span><br></pre></td></tr></table></figure>

<p>生成一对新的ssh密钥：</p>
<p>在终端中，使用以下命令生成一对新的 SSH 密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将在 <code>~/.ssh/</code> 目录下生成一个 RSA 4096 位的密钥对。私钥为<code>id_rsa</code>，公钥为<code>id_rsa.pub</code></p>
<p>编辑 <code>~/.ssh/config</code> 文件以便快速方便地连接多个主机：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Host myserver</span><br><span class="line">    HostName example.com</span><br><span class="line">    User username</span><br><span class="line">    Port 22</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<p>这样你可以通过 <code>ssh myserver</code> 来连接，而不需要每次都输入完整的命令。</p>
<h2 id="安装并且切换不同版本的-java-环境："><a href="#安装并且切换不同版本的-java-环境：" class="headerlink" title="安装并且切换不同版本的 java 环境："></a>安装并且切换不同版本的 java 环境：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pacman 或者 yay 安装不同版本，可同时存在</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S jdk21-openjdk</span><br><span class="line">yay -S jdk13-openjdk</span><br><span class="line"><span class="comment"># 使用 archlinux-java 工具来切换默认的Java版本</span></span><br><span class="line"><span class="built_in">sudo</span> archlinux-java <span class="built_in">set</span> java-21-openjdk</span><br><span class="line"><span class="comment"># 查看当前安装的所有Java版本</span></span><br><span class="line">archlinux-java status</span><br><span class="line">Available Java environments:</span><br><span class="line">  java-21-openjdk (default)</span><br><span class="line">  java-22-openjdk</span><br><span class="line"><span class="comment">#查看当前 java 版本</span></span><br><span class="line">java -version</span><br><span class="line"></span><br><span class="line">openjdk version <span class="string">&quot;21.0.4&quot;</span> 2024-07-16</span><br><span class="line">OpenJDK Runtime Environment (build 21.0.4+7)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 21.0.4+7, mixed mode, sharing)</span><br></pre></td></tr></table></figure>

<h2 id="安装-更新软件包出错"><a href="#安装-更新软件包出错" class="headerlink" title="安装&#x2F;更新软件包出错"></a>安装&#x2F;更新软件包出错</h2><p>问题：</p>
<p>更新 google-chrome 时报错无法安装 <code> python-ninja</code> ，需要手动处理，</p>
<p>解决：</p>
<p>方法一：清除缓存并重新下载</p>
<p>尝试清除 <code>python-ninja</code> 的缓存并重新下载源文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -Scc python-ninja</span><br><span class="line">yay -S python-ninja</span><br></pre></td></tr></table></figure>

<p>方法二：手动删除源文件并重新安装</p>
<p>如果清除缓存后问题仍然存在，你可以手动下载并验证源文件：</p>
<ol>
<li><p>进入缓存目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.cache/yay/python-ninja</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除现有的 <code>python-ninja-1.11.1.3.tar.gz</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> python-ninja-1.11.1.3.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新运行 <code>yay</code> 进行构建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S python-ninja</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
  <entry>
    <title>C/C++ 和 Cmake 格式化</title>
    <url>/2024/03/16/C++%20%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<h1 id="C-C-和-Cmake-格式化"><a href="#C-C-和-Cmake-格式化" class="headerlink" title="C&#x2F;C++ 和 Cmake 格式化"></a>C&#x2F;C++ 和 Cmake 格式化</h1><h2 id="安装-Clang-Format"><a href="#安装-Clang-Format" class="headerlink" title="安装 Clang-Format"></a>安装 <code>Clang-Format</code></h2><h3 id="ArchLinux-系统级安装"><a href="#ArchLinux-系统级安装" class="headerlink" title="ArchLinux 系统级安装"></a>ArchLinux 系统级安装</h3><p>运行以下命令安装 <code>clang</code> 包，其中包含了 <code>clang-format</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S clang</span><br></pre></td></tr></table></figure>

<p>之后你就可以在全局执行 <code>clang-format</code> 命令来格式化代码。可执行文件一般位于 <code>/usr/bin/clang-format</code> 。但是这里安装的而二进制程序使用的是动态库，你把二进制程序分发到其他没有安装 clang 动态库的计算机上，就会报找不到动态库的错误。</p>
<p>如果你有系统权限，或者是在你自己的计算机上开发，这样就可以了即使是把可执行程序拷贝的项目目录下，执行项目目录下的可执行程序，也可以正常运行（动态库还是使用系统目录下的）。</p>
<p>如果你想使用单独的使用静态库的可执行程序，需要手动构建。</p>
<h3 id="手动用户级安装"><a href="#手动用户级安装" class="headerlink" title="手动用户级安装"></a>手动用户级安装</h3><h4 id="方法-1：直接下载-clang-format-二进制文件"><a href="#方法-1：直接下载-clang-format-二进制文件" class="headerlink" title="方法 1：直接下载 clang-format 二进制文件"></a>方法 1：直接下载 <code>clang-format</code> 二进制文件</h4><p>LLVM 官方提供了单独的 <code>clang-format</code> 二进制文件，可以直接下载并解压到项目目录中。</p>
<ul>
<li><p>访问 <a href="https://releases.llvm.org/download.html">LLVM Download Page</a>。</p>
</li>
<li><p>找到适合你系统的预编译包（例如 Linux x86_64）。</p>
</li>
<li><p>下载 <code>clang+llvm-&lt;version&gt;-&lt;arch&gt;-linux-gnu.tar.xz</code>。</p>
</li>
<li><p>解压文件并提取 clang-format ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf clang+llvm-&lt;version&gt;-&lt;<span class="built_in">arch</span>&gt;-linux-gnu.tar.xzcp clang+llvm-&lt;version&gt;-&lt;<span class="built_in">arch</span>&gt;-linux-gnu/bin/clang-format /path/to/your/project/</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这个包里面的 clang-format 不知道是如何构建的，笔者没有尝试。</p>
<h4 id="方法-2：从源码构建仅-clang-format"><a href="#方法-2：从源码构建仅-clang-format" class="headerlink" title="方法 2：从源码构建仅 clang-format"></a>方法 2：从源码构建仅 <code>clang-format</code></h4><ol>
<li><p><strong>下载 LLVM 源码</strong><br>从 <a href="https://github.com/llvm/llvm-project">LLVM GitHub</a> 下载源码，或者直接克隆：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/llvm/llvm-project.git</span><br><span class="line"><span class="built_in">cd</span> llvm-project</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置并仅构建 <code>clang-format</code></strong></p>
<ul>
<li><p>创建构建目录并配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang&quot;</span> -DBUILD_SHARED_LIBS=OFF -DLLVM_BUILD_TOOLS=OFF -DCLANG_BUILD_TOOLS=OFF -DCLANG_ENABLE_FORMAT=ON ../llvm</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建 clang-format ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ninja clang-format</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>提取 <code>clang-format</code> 二进制文件</strong><br> 构建完成后，<code>clang-format</code> 二进制文件位于 <code>build/bin/clang-format</code>。可以将其复制到项目目录中，可以直接使用该可执行程序格式化。</p>
</li>
</ol>
<p>注：即便使用了静态库，但是你在你的机器上构建的 <code>clang-format</code> 依赖于你的版本的 GLIBC 和 libstdc++，而其他的系统上安装的 GLIBC 和 libstdc++ 版本可能较旧，无法满足要求。你可以升级 GLIBC 和 libstdc++ 或者在使用旧 GLIBC 和 libstdc++ 的版本系统上构建。</p>
<h2 id="使用和配置-clang-format"><a href="#使用和配置-clang-format" class="headerlink" title="使用和配置 clang-format"></a>使用和配置 <code>clang-format</code></h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>将可执行文件 <code>clang-format</code> 复制到项目目录下后，你可以运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang-format -i your_code.cpp</span><br></pre></td></tr></table></figure>

<p>来格式化代码。</p>
<h3 id="vscode-扩展"><a href="#vscode-扩展" class="headerlink" title="vscode 扩展"></a>vscode 扩展</h3><p>可以在 vscode 中安装 <strong>clang-format</strong> 扩展来使用在 vscode 中集成的格式化操作。</p>
<p>安装后，可以进行以下配置：</p>
<ul>
<li>Clang-Format: Path 指定了正确的 clang-format 可执行文件路径（如果 VS Code 没有自动找到它的话）。</li>
<li>Editor: Format On Save：在每次保存文件时，VS Code 会自动运行 clang-format 格式化代码。</li>
<li>Clang-Format: Style：选择格式化风格（例如 Google、LLVM、Chromium 等）。如果你有 <code>.clang-format </code> 文件，它会覆盖此设置。</li>
</ul>
<h3 id="自定义代码格式化规则"><a href="#自定义代码格式化规则" class="headerlink" title="自定义代码格式化规则"></a>自定义代码格式化规则</h3><h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><p><code>.clang-format</code> 文件是用来指定代码格式化规则的配置文件。你可以在项目根目录或用户级别目录下创建一个 <code>.clang-format</code> 文件。</p>
<p>你可以手动创建 <code>.clang-format</code> 文件然后自行配置格式化规则。</p>
<p>不过推荐使用以下命令生成默认配置文件，然后在其基础上进行修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang-format -style=llvm -dump-config &gt; .clang-format</span><br></pre></td></tr></table></figure>

<p>这会创建一个基于 llvm 风格的默认配置文件。</p>
<p>你也可以选择其他风格，如 LLVM、Microsoft、Google、Chromium 等，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang-format -style=llvm -dump-config &gt; .clang-format</span><br></pre></td></tr></table></figure>

<p> <code>.clang-format</code> 配置文件例子（中文注释）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">Language:</span>        <span class="string">Cpp</span>            <span class="comment"># 指定格式化语言为 C++</span></span><br><span class="line"><span class="attr">AccessModifierOffset:</span> <span class="number">-2</span>        <span class="comment"># 访问修饰符（如 public、private）的缩进偏移量，负数表示向左缩进</span></span><br><span class="line"><span class="attr">AlignAfterOpenBracket:</span> <span class="string">Align</span>    <span class="comment"># 在开括号后对齐内容</span></span><br><span class="line"><span class="attr">AlignArrayOfStructures:</span> <span class="string">None</span>    <span class="comment"># 不对齐结构体数组</span></span><br><span class="line"><span class="attr">AlignConsecutiveAssignments:</span></span><br><span class="line">  <span class="attr">Enabled:</span>         <span class="literal">false</span>        <span class="comment"># 不启用连续赋值对齐</span></span><br><span class="line">  <span class="attr">AcrossEmptyLines:</span> <span class="literal">false</span>       <span class="comment"># 跨空行不对齐赋值</span></span><br><span class="line">  <span class="attr">AcrossComments:</span>  <span class="literal">false</span>        <span class="comment"># 跨注释不对齐赋值</span></span><br><span class="line">  <span class="attr">AlignCompound:</span>   <span class="literal">false</span>        <span class="comment"># 不对齐复合赋值运算符</span></span><br><span class="line">  <span class="attr">AlignFunctionPointers:</span> <span class="literal">false</span>  <span class="comment"># 不对齐函数指针</span></span><br><span class="line">  <span class="attr">PadOperators:</span>    <span class="literal">true</span>         <span class="comment"># 在操作符周围填充空格</span></span><br><span class="line"><span class="attr">AlignConsecutiveBitFields:</span></span><br><span class="line">  <span class="attr">Enabled:</span>         <span class="literal">false</span>        <span class="comment"># 不启用连续位字段对齐</span></span><br><span class="line">  <span class="attr">AcrossEmptyLines:</span> <span class="literal">false</span>       <span class="comment"># 跨空行不对齐位字段</span></span><br><span class="line">  <span class="attr">AcrossComments:</span>  <span class="literal">false</span>        <span class="comment"># 跨注释不对齐位字段</span></span><br><span class="line">  <span class="attr">AlignCompound:</span>   <span class="literal">false</span>        <span class="comment"># 不对齐复合位字段</span></span><br><span class="line">  <span class="attr">AlignFunctionPointers:</span> <span class="literal">false</span>  <span class="comment"># 不对齐函数指针</span></span><br><span class="line">  <span class="attr">PadOperators:</span>    <span class="literal">false</span>        <span class="comment"># 不在操作符周围填充空格</span></span><br><span class="line"><span class="attr">AlignConsecutiveDeclarations:</span></span><br><span class="line">  <span class="attr">Enabled:</span>         <span class="literal">false</span>        <span class="comment"># 不启用连续声明对齐</span></span><br><span class="line">  <span class="attr">AcrossEmptyLines:</span> <span class="literal">false</span>       <span class="comment"># 跨空行不对齐声明</span></span><br><span class="line">  <span class="attr">AcrossComments:</span>  <span class="literal">false</span>        <span class="comment"># 跨注释不对齐声明</span></span><br><span class="line">  <span class="attr">AlignCompound:</span>   <span class="literal">false</span>        <span class="comment"># 不对齐复合声明</span></span><br><span class="line">  <span class="attr">AlignFunctionPointers:</span> <span class="literal">false</span>  <span class="comment"># 不对齐函数指针</span></span><br><span class="line">  <span class="attr">PadOperators:</span>    <span class="literal">false</span>        <span class="comment"># 不在操作符周围填充空格</span></span><br><span class="line"><span class="attr">AlignConsecutiveMacros:</span></span><br><span class="line">  <span class="attr">Enabled:</span>         <span class="literal">false</span>        <span class="comment"># 不启用连续宏对齐</span></span><br><span class="line">  <span class="attr">AcrossEmptyLines:</span> <span class="literal">false</span>       <span class="comment"># 跨空行不对齐宏</span></span><br><span class="line">  <span class="attr">AcrossComments:</span>  <span class="literal">false</span>        <span class="comment"># 跨注释不对齐宏</span></span><br><span class="line">  <span class="attr">AlignCompound:</span>   <span class="literal">false</span>        <span class="comment"># 不对齐复合宏</span></span><br><span class="line">  <span class="attr">AlignFunctionPointers:</span> <span class="literal">false</span>  <span class="comment"># 不对齐函数指针</span></span><br><span class="line">  <span class="attr">PadOperators:</span>    <span class="literal">false</span>        <span class="comment"># 不在操作符周围填充空格</span></span><br><span class="line"><span class="attr">AlignConsecutiveShortCaseStatements:</span></span><br><span class="line">  <span class="attr">Enabled:</span>         <span class="literal">false</span>        <span class="comment"># 不启用连续短 case 语句对齐</span></span><br><span class="line">  <span class="attr">AcrossEmptyLines:</span> <span class="literal">false</span>       <span class="comment"># 跨空行不对齐 case 语句</span></span><br><span class="line">  <span class="attr">AcrossComments:</span>  <span class="literal">false</span>        <span class="comment"># 跨注释不对齐 case 语句</span></span><br><span class="line">  <span class="attr">AlignCaseArrows:</span> <span class="literal">false</span>        <span class="comment"># 不对齐 case 箭头</span></span><br><span class="line">  <span class="attr">AlignCaseColons:</span> <span class="literal">false</span>        <span class="comment"># 不对齐 case 冒号</span></span><br><span class="line"><span class="attr">AlignConsecutiveTableGenBreakingDAGArgColons:</span></span><br><span class="line">  <span class="attr">Enabled:</span>         <span class="literal">false</span>        <span class="comment"># 不启用连续 TableGen DAG 参数冒号对齐</span></span><br><span class="line">  <span class="attr">AcrossEmptyLines:</span> <span class="literal">false</span>       <span class="comment"># 跨空行不对齐 DAG 参数冒号</span></span><br><span class="line">  <span class="attr">AcrossComments:</span>  <span class="literal">false</span>        <span class="comment"># 跨注释不对齐 DAG 参数冒号</span></span><br><span class="line">  <span class="attr">AlignCompound:</span>   <span class="literal">false</span>        <span class="comment"># 不对齐复合 DAG 参数冒号</span></span><br><span class="line">  <span class="attr">AlignFunctionPointers:</span> <span class="literal">false</span>  <span class="comment"># 不对齐函数指针</span></span><br><span class="line">  <span class="attr">PadOperators:</span>    <span class="literal">false</span>        <span class="comment"># 不在操作符周围填充空格</span></span><br><span class="line"><span class="attr">AlignConsecutiveTableGenCondOperatorColons:</span></span><br><span class="line">  <span class="attr">Enabled:</span>         <span class="literal">false</span>        <span class="comment"># 不启用连续 TableGen 条件操作符冒号对齐</span></span><br><span class="line">  <span class="attr">AcrossEmptyLines:</span> <span class="literal">false</span>       <span class="comment"># 跨空行不对齐条件操作符冒号</span></span><br><span class="line">  <span class="attr">AcrossComments:</span>  <span class="literal">false</span>        <span class="comment"># 跨注释不对齐条件操作符冒号</span></span><br><span class="line">  <span class="attr">AlignCompound:</span>   <span class="literal">false</span>        <span class="comment"># 不对齐复合条件操作符冒号</span></span><br><span class="line">  <span class="attr">AlignFunctionPointers:</span> <span class="literal">false</span>  <span class="comment"># 不对齐函数指针</span></span><br><span class="line">  <span class="attr">PadOperators:</span>    <span class="literal">false</span>        <span class="comment"># 不在操作符周围填充空格</span></span><br><span class="line"><span class="attr">AlignConsecutiveTableGenDefinitionColons:</span></span><br><span class="line">  <span class="attr">Enabled:</span>         <span class="literal">false</span>        <span class="comment"># 不启用连续 TableGen 定义冒号对齐</span></span><br><span class="line">  <span class="attr">AcrossEmptyLines:</span> <span class="literal">false</span>       <span class="comment"># 跨空行不对齐定义冒号</span></span><br><span class="line">  <span class="attr">AcrossComments:</span>  <span class="literal">false</span>        <span class="comment"># 跨注释不对齐定义冒号</span></span><br><span class="line">  <span class="attr">AlignCompound:</span>   <span class="literal">false</span>        <span class="comment"># 不对齐复合定义冒号</span></span><br><span class="line">  <span class="attr">AlignFunctionPointers:</span> <span class="literal">false</span>  <span class="comment"># 不对齐函数指针</span></span><br><span class="line">  <span class="attr">PadOperators:</span>    <span class="literal">false</span>        <span class="comment"># 不在操作符周围填充空格</span></span><br><span class="line"><span class="attr">AlignEscapedNewlines:</span> <span class="string">Right</span>     <span class="comment"># 对齐转义换行符到右侧</span></span><br><span class="line"><span class="attr">AlignOperands:</span>   <span class="string">Align</span>          <span class="comment"># 对齐操作数</span></span><br><span class="line"><span class="attr">AlignTrailingComments:</span></span><br><span class="line">  <span class="attr">Kind:</span>            <span class="string">Always</span>       <span class="comment"># 总是对齐尾随注释</span></span><br><span class="line">  <span class="attr">OverEmptyLines:</span>  <span class="number">0</span>            <span class="comment"># 跨空行不对齐注释</span></span><br><span class="line"><span class="attr">AllowAllArgumentsOnNextLine:</span> <span class="literal">true</span>                <span class="comment"># 允许所有参数在下一行</span></span><br><span class="line"><span class="attr">AllowAllParametersOfDeclarationOnNextLine:</span> <span class="literal">true</span>  <span class="comment"># 允许声明中的所有参数在下一行</span></span><br><span class="line"><span class="attr">AllowBreakBeforeNoexceptSpecifier:</span> <span class="string">Never</span>         <span class="comment"># 不允许在 noexcept 说明符前换行</span></span><br><span class="line"><span class="attr">AllowShortBlocksOnASingleLine:</span> <span class="string">Never</span>             <span class="comment"># 不允许短块在一行内</span></span><br><span class="line"><span class="attr">AllowShortCaseExpressionOnASingleLine:</span> <span class="literal">true</span>      <span class="comment"># 允许短 case 表达式在一行内</span></span><br><span class="line"><span class="attr">AllowShortCaseLabelsOnASingleLine:</span> <span class="literal">false</span>         <span class="comment"># 不允许短 case 标签在一行内</span></span><br><span class="line"><span class="attr">AllowShortCompoundRequirementOnASingleLine:</span> <span class="literal">true</span> <span class="comment"># 允许短复合要求在一行内</span></span><br><span class="line"><span class="attr">AllowShortEnumsOnASingleLine:</span> <span class="literal">true</span>               <span class="comment"># 允许短枚举在一行内</span></span><br><span class="line"><span class="attr">AllowShortFunctionsOnASingleLine:</span> <span class="string">All</span>            <span class="comment"># 允许所有短函数在一行内</span></span><br><span class="line"><span class="attr">AllowShortIfStatementsOnASingleLine:</span> <span class="string">Never</span>       <span class="comment"># 不允许短 if 语句在一行内</span></span><br><span class="line"><span class="attr">AllowShortLambdasOnASingleLine:</span> <span class="string">All</span>              <span class="comment"># 允许所有短 lambda 在一行内</span></span><br><span class="line"><span class="attr">AllowShortLoopsOnASingleLine:</span> <span class="literal">false</span>              <span class="comment"># 不允许短循环在一行内</span></span><br><span class="line"><span class="attr">AlwaysBreakAfterDefinitionReturnType:</span> <span class="string">None</span>       <span class="comment"># 不在定义返回类型后换行</span></span><br><span class="line"><span class="attr">AlwaysBreakBeforeMultilineStrings:</span> <span class="literal">false</span>         <span class="comment"># 不在多行字符串前换行</span></span><br><span class="line"><span class="attr">AttributeMacros:</span></span><br><span class="line">  <span class="string">•</span> <span class="string">__capability</span>              <span class="comment"># 定义属性宏</span></span><br><span class="line"><span class="attr">BinPackArguments:</span> <span class="literal">true</span>         <span class="comment"># 打包函数调用参数</span></span><br><span class="line"><span class="attr">BinPackParameters:</span> <span class="literal">true</span>        <span class="comment"># 打包函数声明参数</span></span><br><span class="line"><span class="attr">BitFieldColonSpacing:</span> <span class="string">Both</span>     <span class="comment"># 在位字段冒号两侧添加空格</span></span><br><span class="line"><span class="attr">BraceWrapping:</span></span><br><span class="line">  <span class="attr">AfterCaseLabel:</span>  <span class="literal">false</span>       <span class="comment"># 不在 case 标签后换行</span></span><br><span class="line">  <span class="attr">AfterClass:</span>      <span class="literal">false</span>       <span class="comment"># 不在类定义后换行</span></span><br><span class="line">  <span class="attr">AfterControlStatement:</span> <span class="string">Never</span> <span class="comment"># 不在控制语句后换行</span></span><br><span class="line">  <span class="attr">AfterEnum:</span>       <span class="literal">false</span>       <span class="comment"># 不在枚举定义后换行</span></span><br><span class="line">  <span class="attr">AfterExternBlock:</span> <span class="literal">false</span>      <span class="comment"># 不在 extern 块后换行</span></span><br><span class="line">  <span class="attr">AfterFunction:</span>   <span class="literal">false</span>       <span class="comment"># 不在函数定义后换行</span></span><br><span class="line">  <span class="attr">AfterNamespace:</span>  <span class="literal">false</span>       <span class="comment"># 不在命名空间定义后换行</span></span><br><span class="line">  <span class="attr">AfterObjCDeclaration:</span> <span class="literal">false</span>  <span class="comment"># 不在 Objective-C 声明后换行</span></span><br><span class="line">  <span class="attr">AfterStruct:</span>     <span class="literal">false</span>       <span class="comment"># 不在结构体定义后换行</span></span><br><span class="line">  <span class="attr">AfterUnion:</span>      <span class="literal">false</span>       <span class="comment"># 不在联合体定义后换行</span></span><br><span class="line">  <span class="attr">BeforeCatch:</span>     <span class="literal">false</span>       <span class="comment"># 不在 catch 前换行</span></span><br><span class="line">  <span class="attr">BeforeElse:</span>      <span class="literal">false</span>       <span class="comment"># 不在 else 前换行</span></span><br><span class="line">  <span class="attr">BeforeLambdaBody:</span> <span class="literal">false</span>      <span class="comment"># 不在 lambda 体前换行</span></span><br><span class="line">  <span class="attr">BeforeWhile:</span>     <span class="literal">false</span>       <span class="comment"># 不在 while 前换行</span></span><br><span class="line">  <span class="attr">IndentBraces:</span>    <span class="literal">false</span>       <span class="comment"># 不缩进大括号</span></span><br><span class="line">  <span class="attr">SplitEmptyFunction:</span> <span class="literal">true</span>     <span class="comment"># 拆分空函数</span></span><br><span class="line">  <span class="attr">SplitEmptyRecord:</span> <span class="literal">true</span>       <span class="comment"># 拆分空记录</span></span><br><span class="line">  <span class="attr">SplitEmptyNamespace:</span> <span class="literal">true</span>    <span class="comment"># 拆分空命名空间</span></span><br><span class="line"><span class="attr">BreakAdjacentStringLiterals:</span> <span class="literal">true</span>           <span class="comment"># 拆分相邻字符串字面量</span></span><br><span class="line"><span class="attr">BreakAfterAttributes:</span> <span class="string">Leave</span>                 <span class="comment"># 在属性后换行</span></span><br><span class="line"><span class="attr">BreakAfterJavaFieldAnnotations:</span> <span class="literal">false</span>       <span class="comment"># 不在 Java 字段注解后换行</span></span><br><span class="line"><span class="attr">BreakAfterReturnType:</span> <span class="string">None</span>                  <span class="comment"># 不在返回类型后换行</span></span><br><span class="line"><span class="attr">BreakArrays:</span>     <span class="literal">true</span>                       <span class="comment"># 拆分数组</span></span><br><span class="line"><span class="attr">BreakBeforeBinaryOperators:</span> <span class="string">None</span>            <span class="comment"># 不在二元操作符前换行</span></span><br><span class="line"><span class="attr">BreakBeforeConceptDeclarations:</span> <span class="string">Always</span>      <span class="comment"># 总是在概念声明前换行</span></span><br><span class="line"><span class="attr">BreakBeforeBraces:</span> <span class="string">Attach</span>                   <span class="comment"># 大括号前不换行</span></span><br><span class="line"><span class="attr">BreakBeforeInlineASMColon:</span> <span class="string">OnlyMultiline</span>    <span class="comment"># 只在多行内联汇编冒号前换行</span></span><br><span class="line"><span class="attr">BreakBeforeTernaryOperators:</span> <span class="literal">true</span>           <span class="comment"># 在三元操作符前换行</span></span><br><span class="line"><span class="attr">BreakConstructorInitializers:</span> <span class="string">BeforeColon</span>   <span class="comment"># 在构造函数初始化列表冒号前换行</span></span><br><span class="line"><span class="attr">BreakFunctionDefinitionParameters:</span> <span class="literal">false</span>    <span class="comment"># 不拆分函数定义参数</span></span><br><span class="line"><span class="attr">BreakInheritanceList:</span> <span class="string">BeforeColon</span>           <span class="comment"># 在继承列表冒号前换行</span></span><br><span class="line"><span class="attr">BreakStringLiterals:</span> <span class="literal">true</span>                   <span class="comment"># 拆分字符串字面量</span></span><br><span class="line"><span class="attr">BreakTemplateDeclarations:</span> <span class="string">MultiLine</span>        <span class="comment"># 多行模板声明</span></span><br><span class="line"><span class="attr">ColumnLimit:</span>  <span class="number">120</span>                           <span class="comment"># 列限制为 120</span></span><br><span class="line"><span class="attr">CommentPragmas:</span>  <span class="string">&#x27;^ IWYU pragma:&#x27;</span>           <span class="comment"># 注释 pragma 正则表达式</span></span><br><span class="line"><span class="attr">CompactNamespaces:</span> <span class="literal">false</span>                    <span class="comment"># 不压缩命名空间</span></span><br><span class="line"><span class="attr">ConstructorInitializerIndentWidth:</span> <span class="number">4</span>        <span class="comment"># 构造函数初始化列表缩进宽度为 4</span></span><br><span class="line"><span class="attr">ContinuationIndentWidth:</span> <span class="number">4</span>                  <span class="comment"># 续行缩进宽度为 4</span></span><br><span class="line"><span class="attr">Cpp11BracedListStyle:</span> <span class="literal">true</span>                  <span class="comment"># 使用 C++11 大括号列表样式</span></span><br><span class="line"><span class="attr">DerivePointerAlignment:</span> <span class="literal">false</span>               <span class="comment"># 不推导指针对齐</span></span><br><span class="line"><span class="attr">DisableFormat:</span>   <span class="literal">false</span>                      <span class="comment"># 不禁用格式化</span></span><br><span class="line"><span class="attr">EmptyLineAfterAccessModifier:</span> <span class="string">Never</span>         <span class="comment"># 不在访问修饰符后添加空行</span></span><br><span class="line"><span class="attr">EmptyLineBeforeAccessModifier:</span> <span class="string">LogicalBlock</span> <span class="comment"># 在逻辑块前添加空行</span></span><br><span class="line"><span class="attr">ExperimentalAutoDetectBinPacking:</span> <span class="literal">false</span>     <span class="comment"># 不启用实验性自动检测参数打包</span></span><br><span class="line"><span class="attr">FixNamespaceComments:</span> <span class="literal">true</span>                  <span class="comment"># 修复命名空间注释</span></span><br><span class="line"><span class="attr">ForEachMacros:</span></span><br><span class="line">  <span class="string">•</span> <span class="string">foreach</span>        <span class="comment"># 定义 foreach 宏</span></span><br><span class="line">  <span class="string">•</span> <span class="string">Q_FOREACH</span>      <span class="comment"># 定义 Q_FOREACH 宏</span></span><br><span class="line">  <span class="string">•</span> <span class="string">BOOST_FOREACH</span>  <span class="comment"># 定义 BOOST_FOREACH 宏</span></span><br><span class="line"><span class="attr">IfMacros:</span></span><br><span class="line">  <span class="string">•</span> <span class="string">KJ_IF_MAYBE</span>           <span class="comment"># 定义 KJ_IF_MAYBE 宏</span></span><br><span class="line"><span class="attr">IncludeBlocks:</span>   <span class="string">Preserve</span>  <span class="comment"># 保留 include 块顺序</span></span><br><span class="line"><span class="attr">IncludeCategories:</span></span><br><span class="line">  <span class="string">•</span> <span class="attr">Regex:</span>           <span class="string">&#x27;^&quot;(llvm|llvm-c|clang|clang-c)/&#x27;</span>  <span class="comment"># LLVM 相关头文件优先级</span></span><br><span class="line">    <span class="attr">Priority:</span>        <span class="number">2</span></span><br><span class="line">    <span class="attr">SortPriority:</span>    <span class="number">0</span></span><br><span class="line">    <span class="attr">CaseSensitive:</span>   <span class="literal">false</span></span><br><span class="line">  <span class="string">•</span> <span class="attr">Regex:</span>           <span class="string">&#x27;^(&lt;|&quot;(gtest|gmock|isl|json)/)&#x27;</span>  <span class="comment"># 测试相关头文件优先级</span></span><br><span class="line">    <span class="attr">Priority:</span>        <span class="number">3</span></span><br><span class="line">    <span class="attr">SortPriority:</span>    <span class="number">0</span></span><br><span class="line">    <span class="attr">CaseSensitive:</span>   <span class="literal">false</span></span><br><span class="line">  <span class="string">•</span> <span class="attr">Regex:</span>           <span class="string">&#x27;.*&#x27;</span>  <span class="comment"># 其他头文件优先级</span></span><br><span class="line">    <span class="attr">Priority:</span>        <span class="number">1</span></span><br><span class="line">    <span class="attr">SortPriority:</span>    <span class="number">0</span></span><br><span class="line">    <span class="attr">CaseSensitive:</span>   <span class="literal">false</span></span><br><span class="line"><span class="attr">IncludeIsMainRegex:</span> <span class="string">&#x27;(Test)?$&#x27;</span>       <span class="comment"># 主文件正则表达式</span></span><br><span class="line"><span class="attr">IncludeIsMainSourceRegex:</span> <span class="string">&#x27;&#x27;</span>         <span class="comment"># 主源文件正则表达式</span></span><br><span class="line"><span class="attr">IndentAccessModifiers:</span> <span class="literal">false</span>         <span class="comment"># 不缩进访问修饰符</span></span><br><span class="line"><span class="attr">IndentCaseBlocks:</span> <span class="literal">false</span>              <span class="comment"># 不缩进 case 块</span></span><br><span class="line"><span class="attr">IndentCaseLabels:</span> <span class="literal">false</span>              <span class="comment"># 不缩进 case 标签</span></span><br><span class="line"><span class="attr">IndentExternBlock:</span> <span class="string">AfterExternBlock</span>  <span class="comment"># 在 extern 块后缩进</span></span><br><span class="line"><span class="attr">IndentGotoLabels:</span> <span class="literal">true</span>               <span class="comment"># 缩进 goto 标签</span></span><br><span class="line"><span class="attr">IndentPPDirectives:</span> <span class="string">None</span>             <span class="comment"># 不缩进预处理指令</span></span><br><span class="line"><span class="attr">IndentRequiresClause:</span> <span class="literal">true</span>           <span class="comment"># 缩进 requires 子句</span></span><br><span class="line"><span class="attr">IndentWidth:</span>     <span class="number">2</span>                   <span class="comment"># 缩进宽度为 2</span></span><br><span class="line"><span class="attr">IndentWrappedFunctionNames:</span> <span class="literal">false</span>    <span class="comment"># 不缩进换行函数名</span></span><br><span class="line"><span class="attr">InsertBraces:</span>    <span class="literal">false</span>               <span class="comment"># 不插入大括号</span></span><br><span class="line"><span class="attr">InsertNewlineAtEOF:</span> <span class="literal">false</span>            <span class="comment"># 不在文件末尾插入换行</span></span><br><span class="line"><span class="attr">InsertTrailingCommas:</span> <span class="string">None</span>           <span class="comment"># 不插入尾随逗号</span></span><br><span class="line"><span class="attr">IntegerLiteralSeparator:</span></span><br><span class="line">  <span class="attr">Binary:</span>           <span class="number">0</span>        <span class="comment"># 二进制字面量分隔符</span></span><br><span class="line">  <span class="attr">BinaryMinDigits:</span>  <span class="number">0</span>        <span class="comment"># 二进制字面量最小位数</span></span><br><span class="line">  <span class="attr">Decimal:</span>          <span class="number">0</span>        <span class="comment"># 十进制字面量分隔符</span></span><br><span class="line">  <span class="attr">DecimalMinDigits:</span> <span class="number">0</span>        <span class="comment"># 十进制字面量最小位数</span></span><br><span class="line">  <span class="attr">Hex:</span>              <span class="number">0</span>        <span class="comment"># 十六进制字面量分隔符</span></span><br><span class="line">  <span class="attr">HexMinDigits:</span>     <span class="number">0</span>        <span class="comment"># 十六进制字面量最小位数</span></span><br><span class="line"><span class="attr">JavaScriptQuotes:</span> <span class="string">Leave</span>      <span class="comment"># 保留 JavaScript 引号</span></span><br><span class="line"><span class="attr">JavaScriptWrapImports:</span> <span class="literal">true</span>  <span class="comment"># 包装 JavaScript 导入</span></span><br><span class="line"><span class="attr">KeepEmptyLines:</span></span><br><span class="line">  <span class="attr">AtEndOfFile:</span>     <span class="literal">false</span> <span class="comment"># 不在文件末尾保留空行</span></span><br><span class="line">  <span class="attr">AtStartOfBlock:</span>  <span class="literal">true</span>  <span class="comment"># 在块开头保留空行</span></span><br><span class="line">  <span class="attr">AtStartOfFile:</span>   <span class="literal">true</span>  <span class="comment"># 在文件开头保留空行</span></span><br><span class="line"><span class="attr">LambdaBodyIndentation:</span> <span class="string">Signature</span>  <span class="comment"># lambda 体缩进与签名对齐</span></span><br><span class="line"><span class="attr">LineEnding:</span>      <span class="string">DeriveLF</span>         <span class="comment"># 推导行结束符为 LF</span></span><br><span class="line"><span class="attr">MacroBlockBegin:</span> <span class="string">&#x27;&#x27;</span>               <span class="comment"># 宏块开始标记</span></span><br><span class="line"><span class="attr">MacroBlockEnd:</span>   <span class="string">&#x27;&#x27;</span>               <span class="comment"># 宏块结束标记</span></span><br><span class="line"><span class="attr">MainIncludeChar:</span> <span class="string">Quote</span>            <span class="comment"># 主文件包含字符为引号</span></span><br><span class="line"><span class="attr">MaxEmptyLinesToKeep:</span> <span class="number">1</span>            <span class="comment"># 最大保留空行数为 1</span></span><br><span class="line"><span class="attr">NamespaceIndentation:</span> <span class="string">None</span>        <span class="comment"># 不缩进命名空间</span></span><br><span class="line"><span class="attr">ObjCBinPackProtocolList:</span> <span class="string">Auto</span>     <span class="comment"># 自动打包 Objective-C 协议列表</span></span><br><span class="line"><span class="attr">ObjCBlockIndentWidth:</span> <span class="number">2</span>           <span class="comment"># Objective-C 块缩进宽度为 2</span></span><br><span class="line"><span class="attr">ObjCBreakBeforeNestedBlockParam:</span> <span class="literal">true</span>  <span class="comment"># 在嵌套块参数前换行</span></span><br><span class="line"><span class="attr">ObjCSpaceAfterProperty:</span> <span class="literal">false</span>          <span class="comment"># 不在 Objective-C 属性后添加空格</span></span><br><span class="line"><span class="attr">ObjCSpaceBeforeProtocolList:</span> <span class="literal">true</span>      <span class="comment"># 在 Objective-C 协议列表前添加空格</span></span><br><span class="line"><span class="attr">PackConstructorInitializers:</span> <span class="string">BinPack</span>   <span class="comment"># 打包构造函数初始化列表</span></span><br><span class="line"><span class="attr">PenaltyBreakAssignment:</span> <span class="number">2</span>              <span class="comment"># 赋值换行惩罚</span></span><br><span class="line"><span class="attr">PenaltyBreakBeforeFirstCallParameter:</span> <span class="number">19</span>  <span class="comment"># 在第一个调用参数前换行惩罚</span></span><br><span class="line"><span class="attr">PenaltyBreakComment:</span> <span class="number">300</span>              <span class="comment"># 注释换行惩罚</span></span><br><span class="line"><span class="attr">PenaltyBreakFirstLessLess:</span> <span class="number">120</span>        <span class="comment"># 第一个 &lt;&lt; 换行惩罚</span></span><br><span class="line"><span class="attr">PenaltyBreakOpenParenthesis:</span> <span class="number">0</span>        <span class="comment"># 开括号换行惩罚</span></span><br><span class="line"><span class="attr">PenaltyBreakScopeResolution:</span> <span class="number">500</span>      <span class="comment"># 作用域解析换行惩罚</span></span><br><span class="line"><span class="attr">PenaltyBreakString:</span> <span class="number">1000</span>              <span class="comment"># 字符串换行惩罚</span></span><br><span class="line"><span class="attr">PenaltyBreakTemplateDeclaration:</span> <span class="number">10</span>   <span class="comment"># 模板声明换行惩罚</span></span><br><span class="line"><span class="attr">PenaltyExcessCharacter:</span> <span class="number">1000000</span>       <span class="comment"># 超出字符数惩罚</span></span><br><span class="line"><span class="attr">PenaltyIndentedWhitespace:</span> <span class="number">0</span>           <span class="comment"># 缩进空白惩罚</span></span><br><span class="line"><span class="attr">PenaltyReturnTypeOnItsOwnLine:</span> <span class="number">60</span>     <span class="comment"># 返回类型单独一行惩罚</span></span><br><span class="line"><span class="attr">PointerAlignment:</span> <span class="string">Right</span>        <span class="comment"># 指针对齐到右侧</span></span><br><span class="line"><span class="attr">PPIndentWidth:</span>   <span class="number">-1</span>            <span class="comment"># 预处理指令缩进宽度为 -1</span></span><br><span class="line"><span class="attr">QualifierAlignment:</span> <span class="string">Leave</span>      <span class="comment"># 保留限定符对齐</span></span><br><span class="line"><span class="attr">ReferenceAlignment:</span> <span class="string">Pointer</span>    <span class="comment"># 引用对齐与指针相同</span></span><br><span class="line"><span class="attr">ReflowComments:</span>  <span class="literal">true</span>     <span class="comment"># 重新格式化注释</span></span><br><span class="line"><span class="attr">RemoveBracesLLVM:</span> <span class="literal">false</span>   <span class="comment"># 不删除 LLVM 大括号</span></span><br><span class="line"><span class="attr">RemoveParentheses:</span> <span class="string">Leave</span>  <span class="comment"># 保留括号</span></span><br><span class="line"><span class="attr">RemoveSemicolon:</span> <span class="literal">false</span>    <span class="comment"># 不删除分号</span></span><br><span class="line"><span class="attr">RequiresClausePosition:</span> <span class="string">OwnLine</span>  <span class="comment"># requires 子句单独一行</span></span><br><span class="line"><span class="attr">RequiresExpressionIndentation:</span> <span class="string">OuterScope</span>  <span class="comment"># requires 表达式缩进与外部作用域对齐</span></span><br><span class="line"><span class="attr">SeparateDefinitionBlocks:</span> <span class="string">Leave</span>  <span class="comment"># 保留定义块分离</span></span><br><span class="line"><span class="attr">ShortNamespaceLines:</span> <span class="number">1</span>           <span class="comment"># 短命名空间行数为 1</span></span><br><span class="line"><span class="attr">SkipMacroDefinitionBody:</span> <span class="literal">false</span>   <span class="comment"># 不跳过宏定义体</span></span><br><span class="line"><span class="attr">SortIncludes:</span>    <span class="string">CaseSensitive</span>   <span class="comment"># 区分大小写排序 include</span></span><br><span class="line"><span class="attr">SortJavaStaticImport:</span> <span class="string">Before</span>     <span class="comment"># 在 Java 静态导入前排序</span></span><br><span class="line"><span class="attr">SortUsingDeclarations:</span> <span class="string">LexicographicNumeric</span>  <span class="comment"># 按字典序和数字排序 using 声明</span></span><br><span class="line"><span class="attr">SpaceAfterCStyleCast:</span> <span class="literal">false</span>  <span class="comment"># 不在 C 风格转换后添加空格</span></span><br><span class="line"><span class="attr">SpaceAfterLogicalNot:</span> <span class="literal">false</span>  <span class="comment"># 不在逻辑非后添加空格</span></span><br><span class="line"><span class="attr">SpaceAfterTemplateKeyword:</span> <span class="literal">true</span>        <span class="comment"># 在模板关键字后添加空格</span></span><br><span class="line"><span class="attr">SpaceAroundPointerQualifiers:</span> <span class="string">Default</span>  <span class="comment"># 默认在指针限定符周围添加空格</span></span><br><span class="line"><span class="attr">SpaceBeforeAssignmentOperators:</span> <span class="literal">true</span>   <span class="comment"># 在赋值操作符前添加空格</span></span><br><span class="line"><span class="attr">SpaceBeforeCaseColon:</span> <span class="literal">false</span>            <span class="comment"># 不在 case 冒号前添加空格</span></span><br><span class="line"><span class="attr">SpaceBeforeCpp11BracedList:</span> <span class="literal">false</span>      <span class="comment"># 不在 C++11 大括号列表前添加空格</span></span><br><span class="line"><span class="attr">SpaceBeforeCtorInitializerColon:</span> <span class="literal">true</span>  <span class="comment"># 在构造函数初始化列表冒号前添加空格</span></span><br><span class="line"><span class="attr">SpaceBeforeInheritanceColon:</span> <span class="literal">true</span>      <span class="comment"># 在继承冒号前添加空格</span></span><br><span class="line"><span class="attr">SpaceBeforeJsonColon:</span> <span class="literal">false</span>            <span class="comment"># 不在 JSON 冒号前添加空格</span></span><br><span class="line"><span class="attr">SpaceBeforeParens:</span> <span class="string">ControlStatements</span>   <span class="comment"># 在控制语句括号前添加空格</span></span><br><span class="line"><span class="attr">SpaceBeforeParensOptions:</span></span><br><span class="line">  <span class="attr">AfterControlStatements:</span> <span class="literal">true</span>         <span class="comment"># 在控制语句后添加空格</span></span><br><span class="line">  <span class="attr">AfterForeachMacros:</span> <span class="literal">true</span>             <span class="comment"># 在 foreach 宏后添加空格</span></span><br><span class="line">  <span class="attr">AfterFunctionDefinitionName:</span> <span class="literal">false</span>   <span class="comment"># 不在函数定义名后添加空格</span></span><br><span class="line">  <span class="attr">AfterFunctionDeclarationName:</span> <span class="literal">false</span>  <span class="comment"># 不在函数声明名后添加空格</span></span><br><span class="line">  <span class="attr">AfterIfMacros:</span>   <span class="literal">true</span>             <span class="comment"># 在 if 宏后添加空格</span></span><br><span class="line">  <span class="attr">AfterOverloadedOperator:</span> <span class="literal">false</span>    <span class="comment"># 不在重载操作符后添加空格</span></span><br><span class="line">  <span class="attr">AfterPlacementOperator:</span> <span class="literal">true</span>      <span class="comment"># 在 placement 操作符后添加空格</span></span><br><span class="line">  <span class="attr">AfterRequiresInClause:</span> <span class="literal">false</span>      <span class="comment"># 不在 requires 子句后添加空格</span></span><br><span class="line">  <span class="attr">AfterRequiresInExpression:</span> <span class="literal">false</span>  <span class="comment"># 不在 requires 表达式后添加空格</span></span><br><span class="line">  <span class="attr">BeforeNonEmptyParentheses:</span> <span class="literal">false</span>  <span class="comment"># 不在非空括号前添加空格</span></span><br><span class="line"><span class="attr">SpaceBeforeRangeBasedForLoopColon:</span> <span class="literal">true</span>  <span class="comment"># 在范围 for 循环冒号前添加空格</span></span><br><span class="line"><span class="attr">SpaceBeforeSquareBrackets:</span> <span class="literal">false</span>       <span class="comment"># 不在方括号前添加空格</span></span><br><span class="line"><span class="attr">SpaceInEmptyBlock:</span> <span class="literal">false</span>         <span class="comment"># 不在空块中添加空格</span></span><br><span class="line"><span class="attr">SpacesBeforeTrailingComments:</span> <span class="number">1</span>  <span class="comment"># 在尾随注释前添加 1 个空格</span></span><br><span class="line"><span class="attr">SpacesInAngles:</span>  <span class="string">Never</span>           <span class="comment"># 不在尖括号内添加空格</span></span><br><span class="line"><span class="attr">SpacesInContainerLiterals:</span> <span class="literal">true</span>  <span class="comment"># 在容器字面量内添加空格</span></span><br><span class="line"><span class="attr">SpacesInLineCommentPrefix:</span></span><br><span class="line">  <span class="attr">Minimum:</span>         <span class="number">1</span>    <span class="comment"># 行注释前缀最小空格数</span></span><br><span class="line">  <span class="attr">Maximum:</span>         <span class="number">-1</span>   <span class="comment"># 行注释前缀最大空格数</span></span><br><span class="line"><span class="attr">SpacesInParens:</span>  <span class="string">Never</span>  <span class="comment"># 不在括号内添加空格</span></span><br><span class="line"><span class="attr">SpacesInParensOptions:</span></span><br><span class="line">  <span class="attr">ExceptDoubleParentheses:</span> <span class="literal">false</span>  <span class="comment"># 不在双括号内添加空格</span></span><br><span class="line">  <span class="attr">InCStyleCasts:</span>   <span class="literal">false</span>          <span class="comment"># 不在 C 风格转换括号内添加空格</span></span><br><span class="line">  <span class="attr">InConditionalStatements:</span> <span class="literal">false</span>  <span class="comment"># 不在条件语句括号内添加空格</span></span><br><span class="line">  <span class="attr">InEmptyParentheses:</span> <span class="literal">false</span>       <span class="comment"># 不在空括号内添加空格</span></span><br><span class="line">  <span class="attr">Other:</span>           <span class="literal">false</span>       <span class="comment"># 不在其他括号内添加空格</span></span><br><span class="line"><span class="attr">SpacesInSquareBrackets:</span> <span class="literal">false</span>  <span class="comment"># 不在方括号内添加空格</span></span><br><span class="line"><span class="attr">Standard:</span>        <span class="string">Latest</span>        <span class="comment"># 使用最新的 C++ 标准</span></span><br><span class="line"><span class="attr">StatementAttributeLikeMacros:</span></span><br><span class="line">  <span class="string">•</span> <span class="string">Q_EMIT</span>        <span class="comment"># 定义类似语句属性的宏</span></span><br><span class="line"><span class="attr">StatementMacros:</span></span><br><span class="line">  <span class="string">•</span> <span class="string">Q_UNUSED</span>      <span class="comment"># 定义语句宏</span></span><br><span class="line">  <span class="string">•</span> <span class="string">QT_REQUIRE_VERSION</span>  <span class="comment"># 定义 QT_REQUIRE_VERSION 宏</span></span><br><span class="line"><span class="attr">TableGenBreakInsideDAGArg:</span> <span class="string">DontBreak</span>  <span class="comment"># 不在 TableGen DAG 参数内换行</span></span><br><span class="line"><span class="attr">TabWidth:</span>        <span class="number">8</span>      <span class="comment"># 制表符宽度为 8</span></span><br><span class="line"><span class="attr">UseTab:</span>          <span class="string">Never</span>  <span class="comment"># 不使用制表符</span></span><br><span class="line"><span class="attr">VerilogBreakBetweenInstancePorts:</span> <span class="literal">true</span>  <span class="comment"># 在 Verilog 实例端口间换行</span></span><br><span class="line"><span class="attr">WhitespaceSensitiveMacros:</span></span><br><span class="line">  <span class="string">•</span> <span class="string">BOOST_PP_STRINGIZE</span>  <span class="comment"># 定义对空格敏感的宏</span></span><br><span class="line">  <span class="string">•</span> <span class="string">CF_SWIFT_NAME</span>       <span class="comment"># 定义对空格敏感的宏</span></span><br><span class="line">  <span class="string">•</span> <span class="string">NS_SWIFT_NAME</span>       <span class="comment"># 定义对空格敏感的宏</span></span><br><span class="line">  <span class="string">•</span> <span class="string">PP_STRINGIZE</span>        <span class="comment"># 定义对空格敏感的宏</span></span><br><span class="line">  <span class="string">•</span> <span class="string">STRINGIZE</span>           <span class="comment"># 定义对空格敏感的宏</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="应用配置文件"><a href="#应用配置文件" class="headerlink" title="应用配置文件"></a>应用配置文件</h4><h5 id="未指定时自动查找"><a href="#未指定时自动查找" class="headerlink" title="未指定时自动查找"></a>未指定时自动查找</h5><p><code>clang-format</code> 在格式化代码时，会自动查找并使用 <code>.clang-format</code> 文件中的规则。查找规则如下：</p>
<ol>
<li><strong>当前工作目录</strong>：<code>clang-format</code> 会首先检查当前工作目录下是否存在 <code>.clang-format</code> 文件。</li>
<li><strong>父目录</strong>：如果当前目录没有找到 <code>.clang-format</code> 文件，<code>clang-format</code> 会递归地向父目录查找，直到找到 <code>.clang-format</code> 文件或到达文件系统的根目录。</li>
<li><strong>用户主目录</strong>：如果以上目录都没有找到 <code>.clang-format</code> 文件，<code>clang-format</code> 会检查用户的主目录（<code>~/.clang-format</code>）。</li>
<li><strong>内置默认规则</strong>：如果以上位置都没有找到 <code>.clang-format</code> 文件，<code>clang-format</code> 会使用其内置的默认格式化规则。</li>
</ol>
<h5 id="使用指定配置文件"><a href="#使用指定配置文件" class="headerlink" title="使用指定配置文件"></a>使用指定配置文件</h5><p>可以通过以下方式明确指定使用某个 <code>.clang-format</code> 文件：</p>
<ul>
<li><p>使用 <code>-style=file</code> 参数，并确保 <code>.clang-format</code> 文件位于当前目录或其父目录中。即 <code>yourfile.cpp</code> 要位于 <code>.clang-format</code> 文件所在目录下或者其子目录下。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang-format -style=file -i yourfile.cpp</span><br></pre></td></tr></table></figure>

<p>你也可以使用下面的命令还使用默认规则，若不指定 <code>-style</code> 参数，则默认是使用 LLVM 规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang-format -style=LLVM -i yourfile.cpp</span><br></pre></td></tr></table></figure>

<p><code>-style</code> 可选 LLVM、Microsoft、Google、Chromium 等。</p>
<p>这会强制 <code>clang-format</code> 使用 <code>.clang-format</code> 文件中的规则。</p>
</li>
<li><p>如果你想直接指定某个 <code>.clang-format</code> 文件的路径，可以使用 <code>-style</code> 参数并传递文件内容。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang-format -style=<span class="string">&quot;<span class="subst">$(cat /path/to/.clang-format)</span>&quot;</span> -i yourfile.cpp</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="格式化脚本"><a href="#格式化脚本" class="headerlink" title="格式化脚本"></a>格式化脚本</h3><p>当项目内代码文件过多时，一个个格式化代码太过繁琐了，我们可以写一个简单的脚本来帮我们遍历处理项目内的代码文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义颜色代码</span></span><br><span class="line">GREEN=<span class="string">&#x27;\033[0;32m&#x27;</span>  <span class="comment"># 绿色</span></span><br><span class="line">BLUE=<span class="string">&#x27;\033[0;34m&#x27;</span>   <span class="comment"># 蓝色</span></span><br><span class="line">NC=<span class="string">&#x27;\033[0m&#x27;</span>        <span class="comment"># 重置颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取脚本所在文件夹路径</span></span><br><span class="line">SCRIPT_DIR=$(<span class="built_in">dirname</span> <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span><br><span class="line">NEED_FORMAT_FILE=<span class="string">&quot;<span class="variable">$SCRIPT_DIR</span>/clang-format-files.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 C/C++ 相关源文件和头文件的函数（当前目录，不递归）</span></span><br><span class="line"><span class="keyword">function</span> get_cpp_files_in_dir &#123;</span><br><span class="line">    find <span class="string">&quot;<span class="variable">$1</span>&quot;</span> -maxdepth 1 \( -name <span class="string">&quot;*.cpp&quot;</span> -o -name <span class="string">&quot;*.hpp&quot;</span> -o -name <span class="string">&quot;*.h&quot;</span> -o -name <span class="string">&quot;*.cc&quot;</span> \) -<span class="built_in">type</span> f 2&gt;/dev/null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 C/C++ 相关源文件和头文件的函数（递归遍历）</span></span><br><span class="line"><span class="keyword">function</span> get_cpp_files_recursive &#123;</span><br><span class="line">    find <span class="string">&quot;<span class="variable">$1</span>&quot;</span> \( -name <span class="string">&quot;*.cpp&quot;</span> -o -name <span class="string">&quot;*.hpp&quot;</span> -o -name <span class="string">&quot;*.h&quot;</span> -o -name <span class="string">&quot;*.cc&quot;</span> \) -<span class="built_in">type</span> f 2&gt;/dev/null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式询问用户是否格式化</span></span><br><span class="line"><span class="keyword">function</span> ask_user &#123;</span><br><span class="line">    <span class="built_in">local</span> files=(<span class="string">&quot;<span class="variable">$&#123;(@f)1&#125;</span>&quot;</span>)  <span class="comment"># 按行读取文件列表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> total_lines=0</span><br><span class="line">    <span class="built_in">local</span> lines=0</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;匹配到以下 <span class="variable">$&#123;#files[@]&#125;</span> 个文件：&quot;</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">        lines=$(<span class="built_in">wc</span> -l &lt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span> 2&gt;/dev/null | <span class="built_in">tr</span> -d <span class="string">&#x27; &#x27;</span>)  <span class="comment"># 获取行数，忽略错误</span></span><br><span class="line">        total_lines=$((total_lines + lines))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用制表符对齐，并添加颜色</span></span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&quot;  <span class="variable">$&#123;GREEN&#125;</span>%s<span class="variable">$&#123;NC&#125;</span>\t(<span class="variable">$&#123;BLUE&#125;</span>%d 行<span class="variable">$&#123;NC&#125;</span>)\n&quot;</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span> <span class="string">&quot;<span class="variable">$lines</span>&quot;</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;总计：<span class="variable">$total_lines</span> 行&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">&quot;是否格式化这些文件？ (y/n, 默认 y): &quot;</span></span><br><span class="line">    <span class="built_in">read</span> -r answer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$answer</span>&quot;</span> || <span class="string">&quot;<span class="variable">$answer</span>&quot;</span> == <span class="string">&quot;y&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">local</span> count=0</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;files[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">            clang-format -i <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">            count=$((count + <span class="number">1</span>))</span><br><span class="line">            <span class="comment"># 打印进度，\r 将光标移动到行首，\c 表示不换行</span></span><br><span class="line">            <span class="built_in">printf</span> <span class="string">&quot;\r已按顺序格式化 %d 个文件。&quot;</span> <span class="string">&quot;<span class="variable">$count</span>&quot;</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&quot;\n&quot;</span>  <span class="comment"># 格式化完成后换行</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;格式化完成。&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;跳过格式化。&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理 clang-format-files.txt 文件</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$NEED_FORMAT_FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    matched_files=()</span><br><span class="line">    ignored_files=()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> IFS= <span class="built_in">read</span> -r line || [[ -n <span class="string">&quot;<span class="variable">$line</span>&quot;</span> ]]; <span class="keyword">do</span></span><br><span class="line">        <span class="comment"># 去除行首尾的空格</span></span><br><span class="line">        line=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$line</span>&quot;</span> | sed -e <span class="string">&#x27;s/^[ \t]*//&#x27;</span> -e <span class="string">&#x27;s/[ \t]*$//&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果行以 + 开头，表示需要格式化的路径</span></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$line</span>&quot;</span> == +* ]]; <span class="keyword">then</span></span><br><span class="line">            pattern=<span class="string">&quot;<span class="variable">$&#123;line:1&#125;</span>&quot;</span></span><br><span class="line">            matched_files+=($(<span class="built_in">eval</span> <span class="string">&quot;ls -d <span class="variable">$SCRIPT_DIR</span>/<span class="variable">$pattern</span>&quot;</span> 2&gt;/dev/null | grep -E <span class="string">&#x27;\.(cpp|hpp|h|cc)$&#x27;</span>))</span><br><span class="line">        <span class="comment"># 如果行以 - 开头，表示不需要格式化的路径</span></span><br><span class="line">        <span class="keyword">elif</span> [[ <span class="string">&quot;<span class="variable">$line</span>&quot;</span> == -* ]]; <span class="keyword">then</span></span><br><span class="line">            pattern=<span class="string">&quot;<span class="variable">$&#123;line:1&#125;</span>&quot;</span></span><br><span class="line">            ignored_files+=($(<span class="built_in">eval</span> <span class="string">&quot;ls -d <span class="variable">$SCRIPT_DIR</span>/<span class="variable">$pattern</span>&quot;</span> 2&gt;/dev/null | grep -E <span class="string">&#x27;\.(cpp|hpp|h|cc)$&#x27;</span>))</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span> &lt; <span class="string">&quot;<span class="variable">$NEED_FORMAT_FILE</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出需要格式化的文件</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$&#123;#matched_files[@]&#125;</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;没有匹配到 clang-format-files.txt 中需要格式化的文件&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;已匹配到 clang-format-files.txt 中需要格式化的文件&quot;</span></span><br><span class="line">        ask_user <span class="string">&quot;<span class="variable">$&#123;(F)matched_files&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出不需要格式化的文件</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$&#123;#ignored_files[@]&#125;</span> -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;以下文件被忽略，不会格式化：&quot;</span></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;ignored_files[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">printf</span> <span class="string">&quot;  <span class="variable">$&#123;GREEN&#125;</span>%s<span class="variable">$&#123;NC&#125;</span>\n&quot;</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有 need-format-files 文件，则先获取当前目录的 C/C++ 文件（不递归）</span></span><br><span class="line">current_dir_files=($(get_cpp_files_in_dir <span class="string">&quot;<span class="variable">$SCRIPT_DIR</span>&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;#current_dir_files[@]&#125;</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;工作目录内没有 C/C++ 文件。&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;当前目录的 C/C++ 文件：&quot;</span></span><br><span class="line">    ask_user <span class="string">&quot;<span class="variable">$&#123;(F)current_dir_files&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历当前目录的所有子目录，并递归获取 C/C++ 文件</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$SCRIPT_DIR</span>&quot;</span>/*(/); <span class="keyword">do</span></span><br><span class="line">    dir_files=($(get_cpp_files_recursive <span class="string">&quot;<span class="variable">$dir</span>&quot;</span>))</span><br><span class="line">    <span class="comment"># 如果当前目录没有 C/C++ 文件，则跳过</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$&#123;#dir_files[@]&#125;</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ask_user <span class="string">&quot;<span class="variable">$&#123;(F)dir_files&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>脚本执行流程：</p>
<p><strong>当存在配置文件 <code>clang-format-files.txt</code> 时：</strong></p>
<ol>
<li>解析配置文件的 <code>+</code>（包含）和 <code>-</code>（排除）规则</li>
<li>合并所有匹配文件并过滤排除项</li>
<li><strong>单次交互确认</strong>：列出所有目标文件及行数，确认后一次性完成格式化</li>
</ol>
<p><strong>当不存在配置文件时：</strong></p>
<ol>
<li>当前目录处理（非递归）：<ul>
<li>扫描当前层级的 C&#x2F;C++ 文件</li>
<li><strong>首次交互确认</strong>：用户确认是否格式化这些文件</li>
</ul>
</li>
<li>子目录递归处理：<ul>
<li>遍历当前目录的每个子目录</li>
<li>对每个子目录执行递归扫描（含所有嵌套子目录）</li>
<li><strong>逐目录交互确认</strong>：每个子目录的文件列表单独显示并请求确认</li>
</ul>
</li>
</ol>
<p><code>clang-format-files.txt</code> 文件说明：</p>
<p>文件路径前的 <code>+</code> 表示需要格式化后面的文件，执行脚本时会进行询问， <code>-</code> 表示不需要询问格式化后面的文件，执行脚本时会忽略。</p>
<ul>
<li><p><code>path/to/file</code> ：匹配普通文件。</p>
</li>
<li><p><code>path/to/directory/*</code> ：匹配 <code>path/to/directory</code> 目录中的所有 C&#x2F;C++ 相关文件。（需要支持 <code>**</code> 的 shell，如 <code>zsh</code>）。</p>
</li>
</ul>
<ul>
<li><code>path/to/directory/**/*</code>：匹配 <code>path/to/directory</code> 目录及其所有子目录中的所有 C&#x2F;C++ 相关文件（需要支持 <code>**</code> 的 shell，如 <code>zsh</code>）。</li>
</ul>
<h2 id="安装和使用-cmake-format"><a href="#安装和使用-cmake-format" class="headerlink" title="安装和使用 cmake-format"></a>安装和使用 cmake-format</h2><h3 id="Arch-Linux-系统安装"><a href="#Arch-Linux-系统安装" class="headerlink" title="Arch Linux 系统安装"></a>Arch Linux 系统安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S cmake-format</span><br></pre></td></tr></table></figure>

<h3 id="获取静态链接的-cmake-format"><a href="#获取静态链接的-cmake-format" class="headerlink" title="获取静态链接的 cmake-format"></a>获取静态链接的 <code>cmake-format</code></h3><p><code>cmake-format</code> 是一个 Python 工具，通常以 Python 包的形式分发。要将其打包为独立的二进制文件，可以使用工具如 <code>pyinstaller</code>。</p>
<ol>
<li><p><strong>安装依赖</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S python python-pip</span><br><span class="line">pip install cmake-format pyinstaller</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将 <code>cmake-format</code> 打包为独立二进制</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --collect-all cmakelang $(<span class="built_in">which</span> cmake-format)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取二进制文件</strong>： 打包完成后，独立的 <code>cmake-format</code> 可执行文件位于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./dist/cmake-format</span><br></pre></td></tr></table></figure>

<p>你可以将其复制到项目目录中使用。</p>
</li>
</ol>
<p>注意：<code>pyinstaller</code> 打包时会将动态库（如 <code>libz.so.1</code>）打包到可执行文件中，但这些动态库可能依赖于较新的 GLIBC 特性（如 <code>GLIBC_ABI_DT_RELR</code>）。如果使用可执行程序的系统 GLIBC 版本较旧，就会导致运行失败。</p>
<p>生成自定义格式化规则配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake-format --dump-config &gt; .cmake-format</span><br></pre></td></tr></table></figure>

<p><code>.cmake-format</code> 配置文件内容例子（中文注释）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ----------------------------------</span></span><br><span class="line"><span class="comment"># 影响 CMake 文件解析的选项</span></span><br><span class="line"><span class="comment"># ----------------------------------</span></span><br><span class="line"><span class="string">with</span> <span class="string">section(&quot;parse&quot;):</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 指定自定义 CMake 函数的结构</span></span><br><span class="line">  <span class="string">additional_commands</span> <span class="string">=</span> &#123; <span class="attr">&#x27;foo&#x27;:</span> &#123; <span class="attr">&#x27;flags&#x27;:</span> [<span class="string">&#x27;BAR&#x27;</span>, <span class="string">&#x27;BAZ&#x27;</span>],</span><br><span class="line">             <span class="attr">&#x27;kwargs&#x27;:</span> &#123;<span class="attr">&#x27;DEPENDS&#x27;:</span> <span class="string">&#x27;*&#x27;</span>, <span class="attr">&#x27;HEADERS&#x27;:</span> <span class="string">&#x27;*&#x27;</span>, <span class="attr">&#x27;SOURCES&#x27;:</span> <span class="string">&#x27;*&#x27;</span>&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 为每个命令覆盖配置（如果可用）</span></span><br><span class="line">  <span class="string">override_spec</span> <span class="string">=</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 指定变量标签</span></span><br><span class="line">  <span class="string">vartags</span> <span class="string">=</span> []</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 指定属性标签</span></span><br><span class="line">  <span class="string">proptags</span> <span class="string">=</span> []</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------</span></span><br><span class="line"><span class="comment"># 影响格式化的选项</span></span><br><span class="line"><span class="comment"># -----------------------------</span></span><br><span class="line"><span class="string">with</span> <span class="string">section(&quot;format&quot;):</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 完全禁用格式化，使 cmake-format 无效</span></span><br><span class="line">  <span class="string">disable</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 允许格式化的 CMake 文件的最大宽度</span></span><br><span class="line">  <span class="string">line_width</span> <span class="string">=</span> <span class="number">120</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 缩进使用的空格数</span></span><br><span class="line">  <span class="string">tab_size</span> <span class="string">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果为 True，则使用制表符（utf-8 0x09）而不是空格（utf-8 0x20）进行缩进</span></span><br><span class="line">  <span class="string">use_tabchars</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果 &lt;use_tabchars&gt; 为 True，则此变量控制如何处理缩进中的部分制表符</span></span><br><span class="line">  <span class="comment"># &#x27;use-space&#x27;: 保留为空格</span></span><br><span class="line">  <span class="comment"># &#x27;round-up&#x27;: 使用一个制表符代替，将列对齐到下一个制表位</span></span><br><span class="line">  <span class="string">fractional_tab_policy</span> <span class="string">=</span> <span class="string">&#x27;use-space&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果一个参数组包含超过此数量的子组（位置参数组或关键字参数组），则强制使用垂直布局</span></span><br><span class="line">  <span class="string">max_subgroups_hwrap</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果一个位置参数组包含超过此数量的参数，则强制使用垂直布局</span></span><br><span class="line">  <span class="string">max_pargs_hwrap</span> <span class="string">=</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果命令行位置组在没有嵌套的情况下占用超过此数量的行，则使布局无效（并嵌套）</span></span><br><span class="line">  <span class="string">max_rows_cmdline</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果为 True，则在控制语句名称和括号之间添加空格</span></span><br><span class="line">  <span class="string">separate_ctrl_name_with_space</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果为 True，则在函数名称和括号之间添加空格</span></span><br><span class="line">  <span class="string">separate_fn_name_with_space</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果语句被换行到多行，则将右括号单独放在一行</span></span><br><span class="line">  <span class="string">dangle_parens</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果右括号必须单独放在一行，则对齐到以下参考：</span></span><br><span class="line">  <span class="comment"># `prefix`: 语句的开头</span></span><br><span class="line">  <span class="comment"># `prefix-indent`: 语句开头加一个缩进级别</span></span><br><span class="line">  <span class="comment"># `child`: 对齐到参数的列</span></span><br><span class="line">  <span class="string">dangle_align</span> <span class="string">=</span> <span class="string">&#x27;prefix&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果语句的拼写长度（包括空格和括号）小于此值，则强制拒绝嵌套布局</span></span><br><span class="line">  <span class="string">min_prefix_chars</span> <span class="string">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果语句的拼写长度（包括空格和括号）比制表符宽度大超过此值，则强制拒绝非嵌套布局</span></span><br><span class="line">  <span class="string">max_prefix_chars</span> <span class="string">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果候选布局是水平换行但超过此行数，则拒绝该布局</span></span><br><span class="line">  <span class="string">max_lines_hwrap</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 输出中使用哪种样式的行尾符</span></span><br><span class="line">  <span class="string">line_ending</span> <span class="string">=</span> <span class="string">&#x27;unix&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 将命令名称格式化为 &#x27;lower&#x27;（小写）或 &#x27;upper&#x27;（大写）</span></span><br><span class="line">  <span class="string">command_case</span> <span class="string">=</span> <span class="string">&#x27;canonical&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 将关键字格式化为 &#x27;lower&#x27;（小写）或 &#x27;upper&#x27;（大写）</span></span><br><span class="line">  <span class="string">keyword_case</span> <span class="string">=</span> <span class="string">&#x27;unchanged&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 始终换行的命令名称列表</span></span><br><span class="line">  <span class="string">always_wrap</span> <span class="string">=</span> []</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果为 True，则将已知可排序的参数列表按字典顺序排序</span></span><br><span class="line">  <span class="string">enable_sort</span> <span class="string">=</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果为 True，解析器可以推断参数列表是否可排序（无需注释）</span></span><br><span class="line">  <span class="string">autosort</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 默认情况下，如果 cmake-format 无法将所有内容适配到所需的行宽，它将应用最后一次最激进的尝试</span></span><br><span class="line">  <span class="comment"># 如果此标志为 True，cmake-format 将打印错误，退出并返回非零状态码，且不输出任何内容</span></span><br><span class="line">  <span class="string">require_valid_layout</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 将布局节点映射到换行决策的字典</span></span><br><span class="line">  <span class="string">layout_passes</span> <span class="string">=</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"><span class="comment"># 影响注释重排和格式化的选项</span></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"><span class="string">with</span> <span class="string">section(&quot;markup&quot;):</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 用于项目符号列表的字符</span></span><br><span class="line">  <span class="string">bullet_char</span> <span class="string">=</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 用于枚举列表中数字后的标点符号的字符</span></span><br><span class="line">  <span class="string">enum_char</span> <span class="string">=</span> <span class="string">&#x27;.&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果启用了注释标记，不要重排每个文件中的第一个注释块</span></span><br><span class="line">  <span class="comment"># 用于保留版权/许可证声明的格式</span></span><br><span class="line">  <span class="string">first_comment_is_literal</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果启用了注释标记，不要重排匹配此正则表达式模式的注释块</span></span><br><span class="line">  <span class="string">literal_comment_pattern</span> <span class="string">=</span> <span class="string">None</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 用于匹配注释中预格式化栅栏的正则表达式</span></span><br><span class="line">  <span class="string">fence_pattern</span> <span class="string">=</span> <span class="string">&#x27;^\\s*([`~]&#123;3&#125;[`~]*)(.*)$&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 用于匹配注释中标尺的正则表达式</span></span><br><span class="line">  <span class="string">ruler_pattern</span> <span class="string">=</span> <span class="string">&#x27;^\\s*[^\\w\\s]&#123;3&#125;.*[^\\w\\s]&#123;3&#125;$&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果注释行以此模式开头，则它是前一个参数的显式尾随注释</span></span><br><span class="line">  <span class="string">explicit_trailing_pattern</span> <span class="string">=</span> <span class="string">&#x27;#&lt;&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果注释行以至少此数量的连续井号开头，则不要删除它们</span></span><br><span class="line">  <span class="string">hashruler_min_length</span> <span class="string">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果为 True，则在标尺的第一个井号和其余井号之间插入空格，并将其长度标准化以填充列</span></span><br><span class="line">  <span class="string">canonicalize_hashrulers</span> <span class="string">=</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 启用注释标记解析和重排</span></span><br><span class="line">  <span class="string">enable_markup</span> <span class="string">=</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------</span></span><br><span class="line"><span class="comment"># 影响代码检查的选项</span></span><br><span class="line"><span class="comment"># ----------------------------</span></span><br><span class="line"><span class="string">with</span> <span class="string">section(&quot;lint&quot;):</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 禁用的代码检查列表</span></span><br><span class="line">  <span class="string">disabled_codes</span> <span class="string">=</span> []</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 描述有效函数名称的正则表达式模式</span></span><br><span class="line">  <span class="string">function_pattern</span> <span class="string">=</span> <span class="string">&#x27;[0-9a-z_]+&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 描述有效宏名称的正则表达式模式</span></span><br><span class="line">  <span class="string">macro_pattern</span> <span class="string">=</span> <span class="string">&#x27;[0-9A-Z_]+&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 描述具有全局（缓存）作用域的变量名称的正则表达式模式</span></span><br><span class="line">  <span class="string">global_var_pattern</span> <span class="string">=</span> <span class="string">&#x27;[A-Z][0-9A-Z_]+&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 描述具有全局作用域（但内部语义）的变量名称的正则表达式模式</span></span><br><span class="line">  <span class="string">internal_var_pattern</span> <span class="string">=</span> <span class="string">&#x27;_[A-Z][0-9A-Z_]+&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 描述具有局部作用域的变量名称的正则表达式模式</span></span><br><span class="line">  <span class="string">local_var_pattern</span> <span class="string">=</span> <span class="string">&#x27;[a-z][a-z0-9_]+&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 描述私有目录变量名称的正则表达式模式</span></span><br><span class="line">  <span class="string">private_var_pattern</span> <span class="string">=</span> <span class="string">&#x27;_[0-9a-z_]+&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 描述公共目录变量名称的正则表达式模式</span></span><br><span class="line">  <span class="string">public_var_pattern</span> <span class="string">=</span> <span class="string">&#x27;[A-Z][0-9A-Z_]+&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 描述函数/宏参数和循环变量名称的正则表达式模式</span></span><br><span class="line">  <span class="string">argument_var_pattern</span> <span class="string">=</span> <span class="string">&#x27;[a-z][a-z0-9_]+&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 描述函数或宏中使用的关键字名称的正则表达式模式</span></span><br><span class="line">  <span class="string">keyword_pattern</span> <span class="string">=</span> <span class="string">&#x27;[A-Z][0-9A-Z_]+&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 在 C0201 启发式算法中，匹配循环中的条件语句数量，以将其视为解析器</span></span><br><span class="line">  <span class="string">max_conditionals_custom_parser</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 要求语句之间至少有多少个空行</span></span><br><span class="line">  <span class="string">min_statement_spacing</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 要求语句之间最多有多少个空行</span></span><br><span class="line">  <span class="string">max_statement_spacing</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line">  <span class="string">max_returns</span> <span class="string">=</span> <span class="number">6</span></span><br><span class="line">  <span class="string">max_branches</span> <span class="string">=</span> <span class="number">12</span></span><br><span class="line">  <span class="string">max_arguments</span> <span class="string">=</span> <span class="number">5</span></span><br><span class="line">  <span class="string">max_localvars</span> <span class="string">=</span> <span class="number">15</span></span><br><span class="line">  <span class="string">max_statements</span> <span class="string">=</span> <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"><span class="comment"># 影响文件编码的选项</span></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"><span class="string">with</span> <span class="string">section(&quot;encode&quot;):</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果为 True，则在文件开头发出 Unicode 字节顺序标记（BOM）</span></span><br><span class="line">  <span class="string">emit_byteorder_mark</span> <span class="string">=</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 指定输入文件的编码，默认为 utf-8</span></span><br><span class="line">  <span class="string">input_encoding</span> <span class="string">=</span> <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 指定输出文件的编码，默认为 utf-8</span></span><br><span class="line">  <span class="string">output_encoding</span> <span class="string">=</span> <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------------</span></span><br><span class="line"><span class="comment"># 其他配置选项</span></span><br><span class="line"><span class="comment"># -------------------------------------</span></span><br><span class="line"><span class="string">with</span> <span class="string">section(&quot;misc&quot;):</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 包含每个命令配置覆盖的字典，目前仅支持 `command_case`</span></span><br><span class="line">  <span class="string">per_command</span> <span class="string">=</span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>待分类</category>
      </categories>
  </entry>
</search>
